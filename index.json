[{"categories":["go"],"content":"表示熟悉 表示掌握 表示了解 ","date":"2023-05-31","objectID":"/posts/go/interview02/:0:0","tags":["go","面试"],"title":"Golang_Interview_概述","uri":"/posts/go/interview02/"},{"categories":["go"],"content":"进程、线程、协程的区别？ 进程：进程是每一次程序动态执行的过程，是程序运行的基本单位。进程占据独立的内存，有内存地址，有自己的堆，上级挂靠操作系统，操作系统以进程为单位分配资源(如CPU时间片、内存等)，进程是资源分配的最小单位。 线程：线程又叫做轻量级进程，是CPU调度的最小单元。线程从属于进程，是程序的实际执行者，一个进程至少包含一个主线程，也可以有多个子线程。线程会共享所属进程的资源，同时线程也有自己的独占资源。线程切换和线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。 协程：协程是一种用户态的轻量级线程，协程的调度完全由用户控制。一个线程可以有多个协程，协程不是被操作系统内核所管理，而是由程序所控制。 区别 拥有资源：进程是拥有资源的最小单位，线程不拥有资源，但是可以访问隶属进程的资源。进程所维护的是程序所包含的资源静态资源)， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler等；线程所维护的运行相关的资源(动态资源)，如：运行栈，调度相关的控制信息，待处理的信号集等。 并发性：不仅进程可以并发执行，同一进程的多个线程也可以并发执行。 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 协程和线程：协程避免了无意义的调度，由此可以提高性能，但是用户调度过程中可能存在风险。 ","date":"2023-05-31","objectID":"/posts/go/interview02/:1:0","tags":["go","面试"],"title":"Golang_Interview_概述","uri":"/posts/go/interview02/"},{"categories":["go"],"content":"goroutine相比线程的优势？ 协程拥有极高的执行效率，子程序切换不是线程切换而是由程序自身控制，所以没有线程切换的开销。和多线程比，线程的数量越多，协程的性能优势就越明显。 协程不需要多线程的锁机制，因为只有一个线程，所以不存在同时写变量的冲突。在协程中控制共享资源不加锁，只需要判断状态就可以，执行效率比多线程要高。 ","date":"2023-05-31","objectID":"/posts/go/interview02/:2:0","tags":["go","面试"],"title":"Golang_Interview_概述","uri":"/posts/go/interview02/"},{"categories":["go"],"content":"go与Java的区别？ 运行：go是静态编译语言；Java基于类的面向对象语言，Java应用程序在JVM上运行。 函数重载：go上不允许函数重载，必须具有方法和函数的唯一名称；java允许函数重载。 多态：Java默认允许多态，而go没有。 路由配置：go语言使用HTTP协议进行路由配置；java使用Akka.routing进行路由配置。 继承：go的继承通过匿名组合完成，基类以Struct的方式定义，子类只需要把基类作为成员放在子类的定义中，支持多继承；Java的继承通过extends关键字完成，不支持多继承。 ","date":"2023-05-31","objectID":"/posts/go/interview02/:3:0","tags":["go","面试"],"title":"Golang_Interview_概述","uri":"/posts/go/interview02/"},{"categories":["go"],"content":"go语言中是如何实现继承的？ 在go中没有extends关键字，所以go并没有原生级别的继承支持。本质上，Go使用组合来代替继承： type Person struct { Name string Age int } type Student struct { Person School string } ","date":"2023-05-31","objectID":"/posts/go/interview02/:4:0","tags":["go","面试"],"title":"Golang_Interview_概述","uri":"/posts/go/interview02/"},{"categories":["go"],"content":"for遍历多次执行goroutine会存在什么问题？ 在协程中打印for的下标i或当前下标的元素 会随机打印载体中的元素。 golang值拷贝传递，for循环很快就执行完了，但是创建的10个协程需要做初始化：上下文准备，堆栈，和内核态的线程映射关系的工作，是需要时间的，比for慢，等都准备好了的时候，会同时访问i。这个时候的i肯定是for执行完成后的下标(也可能有个别的协程已经准备好了，取i的时候，正好是5，或者7，就输出了这些数字)。 解决的方法就是闭包，给匿名函数增加入参，因为是值传递，所以每次for创建一个协程的时候，会拷贝一份i传到这个协程里面去，或者在开启协程之前声明一个新的变量 = i。 for并发读取文件 程序会panic:too many open files 解决的方法：通过带缓冲的channel和sync.waitgroup控制协程并发量。 ","date":"2023-05-31","objectID":"/posts/go/interview02/:5:0","tags":["go","面试"],"title":"Golang_Interview_概述","uri":"/posts/go/interview02/"},{"categories":["go"],"content":"init函数是什么时候执行的？ 特点： init函数先于main函数自动执行，不能被其他函数调用。 init函数没有输入参数、返回值。 每个包可以有多个init函数，包的每个源文件也可以有多个init函数。 go没有明确定义同一个包的init执行顺序，编程时程序不能依赖这个执行顺序。 不同包的init函数按照包导入的依赖关系决定执行顺序。 作用： 初始化不能采用初始化表达式初始化的变量。 程序运行前的注册。 实现sync.Once功能。 执行顺序： go程序初始化先于main函数执行，由runtime进行初始化，初始化顺序如下： 初始化导入的包，包的初始化顺序并不是按导入顺序执行的，runtime需要解析包依赖关系，没有依赖的包最先初始化 初始化包作用域的变量，runtime解析变量依赖关系，没有依赖的变量最先初始化 执行包的init函数 最终初始化顺序：变量初始化 -\u003e init() -\u003e main() ","date":"2023-05-31","objectID":"/posts/go/interview02/:6:0","tags":["go","面试"],"title":"Golang_Interview_概述","uri":"/posts/go/interview02/"},{"categories":["Gin"],"content":"Go操作MySQL","date":"2023-05-30","objectID":"/posts/gin/gin04/","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"Go操作MySQL ","date":"2023-05-30","objectID":"/posts/gin/gin04/:0:0","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"连接 Go语言中的database/sql包提供了保证SQL或类SQL数据库的泛用接口，并不提供具体的数据库驱动。使用database/sql包时必须注入（至少）一个数据库驱动。 我们常用的数据库基本上都有完整的第三方实现。例如：MySQL驱动 ","date":"2023-05-30","objectID":"/posts/gin/gin04/:1:0","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"下载依赖 连接mysql的驱动 go get -u github.com/go-sql-driver/mysql ","date":"2023-05-30","objectID":"/posts/gin/gin04/:1:1","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"使用MySQL驱动 func Open(driverName, dataSourceName string) (*DB, error) Open打开一个dirverName指定的数据库，dataSourceName指定数据源，一般至少包括数据库文件名和其它连接必要的信息。 import ( \"database/sql\" // 匿名导入，导入的时候执行该库里的init方法 _ \"github.com/go-sql-driver/mysql\" ) func main() { // DSN:Data Source Name // \"user:password@tcp(127.0.0.1:3306)/dbname\" dsn := \"root:root1234@tcp(127.0.0.1:3306)/sql_demo\" db, err := sql.Open(\"mysql\", dsn) if err != nil { panic(err) } defer db.Close() // 注意这行代码要写在上面err判断的下面 } 思考题： 为什么上面代码中的defer db.Close()语句不应该写在if err != nil的前面呢？ 做完检查之后，再defer，确保db不为nil，否则defer db.Close()就会出错。很多情况下都需要注意这点。 ","date":"2023-05-30","objectID":"/posts/gin/gin04/:1:2","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"初始化连接 Open可能只是验证其参数格式是否正确，实际上并不创建与数据库的连接。如果要检查数据源的名称是否真实有效，应该调用Ping方法。 返回的DB对象可以安全地被多个goroutine并发使用（并发安全的），并且维护其自己的空闲连接池。因此，Open函数应该仅被调用一次，很少需要关闭这个DB对象。 接下来，我们定义一个全局变量db，用来保存数据库连接对象。将上面的示例代码拆分出一个独立的initDB函数，只需要在程序启动时调用一次该函数完成全局变量db的初始化，其他函数中就可以直接使用全局变量db了。（注意下方的注意） // 定义一个全局对象db var db *sql.DB // 定义一个初始化数据库的函数 func initDB() (err error) { // DSN:Data Source Name dsn := \"user:password@tcp(127.0.0.1:3306)/sql_test?charset=utf8mb4\u0026parseTime=True\" // 不会校验账号密码是否正确 // 注意！！！这里不要使用:=，我们是给全局变量赋值，然后在main函数中使用全局变量db db, err = sql.Open(\"mysql\", dsn) if err != nil { return err } // 尝试与数据库建立连接（校验dsn是否正确） err = db.Ping() if err != nil { return err } return nil } func main() { err := initDB() // 调用输出化数据库的函数 if err != nil { fmt.Printf(\"init db failed,err:%v\\n\", err) return } defer db.Close() } 其中sql.DB是表示连接的数据库对象（结构体实例），它保存了连接数据库相关的所有信息。它内部维护着一个具有零到多个底层连接的连接池，它可以安全地被多个goroutine同时使用。 ","date":"2023-05-30","objectID":"/posts/gin/gin04/:1:3","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"SetMaxOpenConns func (db *DB) SetMaxOpenConns(n int) SetMaxOpenConns设置与数据库建立连接的最大数目。 如果n大于0且小于最大闲置连接数，会将最大闲置连接数减小到匹配最大开启连接数的限制。 如果n\u003c=0，不会限制最大开启连接数，默认为0（无限制）。 ","date":"2023-05-30","objectID":"/posts/gin/gin04/:1:4","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"SetMaxIdleConns func (db *DB) SetMaxIdleConns(n int) SetMaxIdleConns设置连接池中的最大空闲连接数。 如果n大于最大开启连接数，则新的最大闲置连接数会减小到匹配最大开启连接数的限制。 如果n\u003c=0，不会保留闲置连接。 ","date":"2023-05-30","objectID":"/posts/gin/gin04/:1:5","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"SetConnMaxLifetime 连接存活的最长时间。 func (db *DB) SetConnMaxLifetime(d time.Duration) 以上的数值根据业务具体的情况设定。 ","date":"2023-05-30","objectID":"/posts/gin/gin04/:1:6","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"源码部分 找到包下的一个文件，点击左侧的structure。 橙色的v表示value；蓝色的t表示类型；m表示method；f表示function Register var 中定义了一个全局变量的读写锁，类似于其他语言的单例模式，这种定义在go语言中很常见。单例？ ","date":"2023-05-30","objectID":"/posts/gin/gin04/:1:7","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"CRUD ","date":"2023-05-30","objectID":"/posts/gin/gin04/:2:0","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"建库建表 我们先在MySQL中创建一个名为sql_test的数据库 CREATE DATABASE sql_test; 进入该数据库: use sql_test; 执行以下命令创建一张用于测试的数据表： CREATE TABLE `user` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT, `name` VARCHAR(20) DEFAULT '', `age` INT(11) DEFAULT '0', PRIMARY KEY(`id`) )ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4; ","date":"2023-05-30","objectID":"/posts/gin/gin04/:2:1","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"查询 为了方便查询，我们事先定义好一个结构体来存储user表的数据。 type user struct { id int age int name string } 单行查询 其实如下这种方式，我们可以发现用起来比较麻烦，后面会讲sqlx的方式。 单行查询db.QueryRow()执行一次查询，并期望返回最多一行结果（即Row）。QueryRow总是返回非nil的值，直到返回值的Scan方法被调用时，才会返回被延迟的错误。（如：未找到结果） func (db *DB) QueryRow(query string, args ...interface{}) *Row 具体示例代码： // 查询单条数据示例 func queryRowDemo() { sqlStr := \"select id, name, age from user where id=?\" var u user // 非常重要：确保QueryRow之后调用Scan方法，否则持有的数据库链接不会被释放 err := db.QueryRow(sqlStr, 1).Scan(\u0026u.id, \u0026u.name, \u0026u.age) if err != nil { fmt.Printf(\"scan failed, err:%v\\n\", err) return } fmt.Printf(\"id:%d name:%s age:%d\\n\", u.id, u.name, u.age) } 多行查询 多行查询db.Query()执行一次查询，返回多行结果（即Rows），一般用于执行select命令。参数args表示query中的占位参数。 func (db *DB) Query(query string, args ...interface{}) (*Rows, error) 具体示例代码： // 查询多条数据示例 func queryMultiRowDemo() { sqlStr := \"select id, name, age from user where id \u003e ?\" rows, err := db.Query(sqlStr, 0) if err != nil { fmt.Printf(\"query failed, err:%v\\n\", err) return } // 非常重要：关闭rows释放持有的数据库链接 defer rows.Close() // 循环读取结果集中的数据 for rows.Next() { var u user err := rows.Scan(\u0026u.id, \u0026u.name, \u0026u.age) if err != nil { fmt.Printf(\"scan failed, err:%v\\n\", err) return } fmt.Printf(\"id:%d name:%s age:%d\\n\", u.id, u.name, u.age) } } ","date":"2023-05-30","objectID":"/posts/gin/gin04/:2:2","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"插入 数据 插入、更新和删除操作都使用Exec方法。只是sql语句不一样。 func (db *DB) Exec(query string, args ...interface{}) (Result, error) Exec执行一次命令（包括查询、删除、更新、插入等），返回的Result是对已执行的SQL命令的总结。参数args表示query中的占位参数。 具体插入数据示例代码如下： // 插入数据 func insertRowDemo() { sqlStr := \"insert into user(name, age) values (?,?)\" ret, err := db.Exec(sqlStr, \"王五\", 38) if err != nil { fmt.Printf(\"insert failed, err:%v\\n\", err) return } theID, err := ret.LastInsertId() // 新插入数据的id if err != nil { fmt.Printf(\"get lastinsert ID failed, err:%v\\n\", err) return } fmt.Printf(\"insert success, the id is %d.\\n\", theID) } ","date":"2023-05-30","objectID":"/posts/gin/gin04/:2:3","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"更新数据 具体更新数据示例代码如下： // 更新数据 func updateRowDemo() { sqlStr := \"update user set age=? where id = ?\" ret, err := db.Exec(sqlStr, 39, 3) if err != nil { fmt.Printf(\"update failed, err:%v\\n\", err) return } n, err := ret.RowsAffected() // 操作影响的行数 if err != nil { fmt.Printf(\"get RowsAffected failed, err:%v\\n\", err) return } fmt.Printf(\"update success, affected rows:%d\\n\", n) } ","date":"2023-05-30","objectID":"/posts/gin/gin04/:2:4","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"删除数据 具体删除数据的示例代码如下： // 删除数据 func deleteRowDemo() { sqlStr := \"delete from user where id = ?\" ret, err := db.Exec(sqlStr, 3) if err != nil { fmt.Printf(\"delete failed, err:%v\\n\", err) return } n, err := ret.RowsAffected() // 操作影响的行数 if err != nil { fmt.Printf(\"get RowsAffected failed, err:%v\\n\", err) return } fmt.Printf(\"delete success, affected rows:%d\\n\", n) } ","date":"2023-05-30","objectID":"/posts/gin/gin04/:2:5","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"MySQL预处理 ","date":"2023-05-30","objectID":"/posts/gin/gin04/:3:0","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"什么是预处理 普通SQL语句执行过程： 客户端对SQL语句进行占位符替换得到完整的SQL语句。 客户端发送完整SQL语句到MySQL服务端 MySQL服务端执行完整的SQL语句并将结果返回给客户端。 预处理执行过程： 把SQL语句分成两部分，命令部分与数据部分。 先把命令部分发送给MySQL服务端，MySQL服务端进行SQL预处理。 然后把数据部分发送给MySQL服务端，MySQL服务端对SQL语句进行占位符替换。 MySQL服务端执行完整的SQL语句并将结果返回给客户端。 ","date":"2023-05-30","objectID":"/posts/gin/gin04/:3:1","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"为什么要预处理 优化MySQL服务器重复执行SQL的方法，可以提升服务器性能，提前让服务器编译，一次编译多次执行，节省后续编译的成本。 避免SQL注入问题。 ","date":"2023-05-30","objectID":"/posts/gin/gin04/:3:2","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"Go实现MySQL预处理 database/sql中使用下面的Prepare方法来实现预处理操作。 func (db *DB) Prepare(query string) (*Stmt, error) Prepare方法会先将sql语句发送给MySQL服务端，返回一个准备好的状态用于之后的查询和命令。返回值可以同时执行多个查询和命令。 查询操作的预处理示例代码如下： // 预处理查询示例 func prepareQueryDemo() { sqlStr := \"select id, name, age from user where id \u003e ?\" stmt, err := db.Prepare(sqlStr) if err != nil { fmt.Printf(\"prepare failed, err:%v\\n\", err) return } defer stmt.Close() rows, err := stmt.Query(0) if err != nil { fmt.Printf(\"query failed, err:%v\\n\", err) return } defer rows.Close() // 循环读取结果集中的数据 for rows.Next() { var u user err := rows.Scan(\u0026u.id, \u0026u.name, \u0026u.age) if err != nil { fmt.Printf(\"scan failed, err:%v\\n\", err) return } fmt.Printf(\"id:%d name:%s age:%d\\n\", u.id, u.name, u.age) } } 插入、更新和删除操作的预处理十分类似，这里以插入操作的预处理为例： // 预处理插入示例 func prepareInsertDemo() { sqlStr := \"insert into user(name, age) values (?,?)\" stmt, err := db.Prepare(sqlStr) if err != nil { fmt.Printf(\"prepare failed, err:%v\\n\", err) return } defer stmt.Close() _, err = stmt.Exec(\"小王子\", 18) if err != nil { fmt.Printf(\"insert failed, err:%v\\n\", err) return } _, err = stmt.Exec(\"沙河娜扎\", 18) if err != nil { fmt.Printf(\"insert failed, err:%v\\n\", err) return } fmt.Println(\"insert success.\") } ","date":"2023-05-30","objectID":"/posts/gin/gin04/:3:3","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"SQL注入问题 我们任何时候都不应该自己拼接SQL语句！ 这里我们演示一个自行拼接SQL语句的示例，编写一个根据name字段查询user表的函数如下： // sql注入示例 func sqlInjectDemo(name string) { sqlStr := fmt.Sprintf(\"select id, name, age from user where name='%s'\", name) fmt.Printf(\"SQL:%s\\n\", sqlStr) var u user err := db.QueryRow(sqlStr).Scan(\u0026u.id, \u0026u.name, \u0026u.age) if err != nil { fmt.Printf(\"exec failed, err:%v\\n\", err) return } fmt.Printf(\"user:%#v\\n\", u) } 此时以下输入字符串都可以引发SQL注入问题： sqlInjectDemo(\"xxx' or 1=1#\") sqlInjectDemo(\"xxx' union select * from user #\") sqlInjectDemo(\"xxx' and (select count(*) from user) \u003c10 #\") **补充：**不同的数据库中，SQL语句使用的占位符语法不尽相同。 数据库 占位符语法 MySQL ? PostgreSQL $1, $2等 SQLite ? 和$1 Oracle :name ","date":"2023-05-30","objectID":"/posts/gin/gin04/:3:4","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"Go实现MySQL事务 ","date":"2023-05-30","objectID":"/posts/gin/gin04/:4:0","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"什么是事务 事务：一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)，同时这个完整的业务需要执行多次的DML(insert、update、delete)语句共同联合完成。A转账给B，这里面就需要执行两次update操作。 在MySQL中只有使用了Innodb数据库引擎的数据库或表才支持事务。事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行。通过A转账给B的例子来理解。 ","date":"2023-05-30","objectID":"/posts/gin/gin04/:4:1","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"事务的ACID 通常事务必须满足4个条件（ACID）：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 条件 解释 原子性 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 ","date":"2023-05-30","objectID":"/posts/gin/gin04/:4:2","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"事务相关方法 Go语言中使用以下三个方法实现MySQL中的事务操作。 开始事务 func (db *DB) Begin() (*Tx, error) 提交事务 func (tx *Tx) Commit() error 回滚事务 func (tx *Tx) Rollback() error ","date":"2023-05-30","objectID":"/posts/gin/gin04/:4:3","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["Gin"],"content":"事务示例 下面的代码演示了一个简单的事务操作，该事物操作能够确保两次更新操作要么同时成功要么同时失败，不会存在中间状态。 // 事务操作示例 func transactionDemo() { tx, err := db.Begin() // 开启事务 if err != nil { if tx != nil { tx.Rollback() // 回滚 } fmt.Printf(\"begin trans failed, err:%v\\n\", err) return } sqlStr1 := \"Update user set age=30 where id=?\" ret1, err := tx.Exec(sqlStr1, 2) if err != nil { tx.Rollback() // 回滚 fmt.Printf(\"exec sql1 failed, err:%v\\n\", err) return } affRow1, err := ret1.RowsAffected() if err != nil { tx.Rollback() // 回滚 fmt.Printf(\"exec ret1.RowsAffected() failed, err:%v\\n\", err) return } sqlStr2 := \"Update user set age=40 where id=?\" ret2, err := tx.Exec(sqlStr2, 3) if err != nil { tx.Rollback() // 回滚 fmt.Printf(\"exec sql2 failed, err:%v\\n\", err) return } affRow2, err := ret2.RowsAffected() if err != nil { tx.Rollback() // 回滚 fmt.Printf(\"exec ret1.RowsAffected() failed, err:%v\\n\", err) return } fmt.Println(affRow1, affRow2) // 受影响行数都是1时 if affRow1 == 1 \u0026\u0026 affRow2 == 1 { fmt.Println(\"事务提交啦...\") tx.Commit() // 提交事务 } else { tx.Rollback() fmt.Println(\"事务回滚啦...\") } fmt.Println(\"exec trans success!\") } ","date":"2023-05-30","objectID":"/posts/gin/gin04/:4:4","tags":["Gin","go"],"title":"Go操作数据库01","uri":"/posts/gin/gin04/"},{"categories":["go"],"content":"表示熟悉 表示掌握 表示了解 ","date":"2023-05-30","objectID":"/posts/go/interview01/:0:0","tags":["go","面试"],"title":"Golang_Interview_关键字","uri":"/posts/go/interview01/"},{"categories":["go"],"content":"make和new的区别 new(T) 和 make(T,args) 是 Go 语言内建函数，用来分配内存，但适用的类型不同。 new(T) 会为 T 类型的新值分配已置零的内存空间，并返回地址（指针），即类型为 *T的值。换句话说就是，返回一个指针，该指针指向新分配的、类型为 T 的零值。适用于值类型，如数组、结构体等；new可被替代，能够通过字面值快速初始化。 make(T,args) 分配并初始化，返回初始化之后的 T 类型的引用，而并不是 T 类型的零值，也不是指针 *T；make() 只适用于 slice、map 和 channel；make函数会对三种类型的内部数据结构（长度、容量等）赋值。 ","date":"2023-05-30","objectID":"/posts/go/interview01/:1:0","tags":["go","面试"],"title":"Golang_Interview_关键字","uri":"/posts/go/interview01/"},{"categories":["go"],"content":"slice的底层实现？ 切片的底层是一个结构体，对应三个参数，一个是unsafe.Pointer指针，指向一个具体的底层数组，一个是cap，切片的容量，一个是len，切片的长度。 因为切片是基于数组实现，所以它的底层的内存是连续分配的，效率非常高，可以通过索引获得数据。切片本身并不是动态数组或者数组指针，而是设定相关属性，将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。 如果make函数初始化了一个太大的切片，该切片就会逃逸到堆区；如果分配了一个比较小的切片，就会被分配到栈区，切片大小的临界值默认为64KB，因此make([]int64, 1023) 和 make([]int64, 1024) 是完全不同的内存布局。 type slice struct { array unsafe.Pointer len int cap int } ","date":"2023-05-30","objectID":"/posts/go/interview01/:2:0","tags":["go","面试"],"title":"Golang_Interview_关键字","uri":"/posts/go/interview01/"},{"categories":["go"],"content":"slice和数组的区别？ 切片是引用类型，数组是值类型 传递数组是通过拷贝的方式，传递切片是通过传递引用的方式。 数组的长度固定，而切片可以进行动态扩容 数组是一组内存空间连续的数据，一旦初始化长度大小就不会再改变，切片的长度可以进行扩展，当切片底层的数组容量不够时，切片会创建新的底层数组。 切片比数组多一个属性容量（cap) ","date":"2023-05-30","objectID":"/posts/go/interview01/:3:0","tags":["go","面试"],"title":"Golang_Interview_关键字","uri":"/posts/go/interview01/"},{"categories":["go"],"content":"slice的扩容机制？ 扩容主要分为两个过程：第一步是分配新的内存空间，第二步是将原有切片内容进行复制。分配新空间时候需要估计大致容量，然后再确定容量。 根据该切片当前容量选择不同的策略： 如果期望容量大于当前容量的两倍，就会使用期望容量 如果当前切片的长度小于 1024，容量就会翻倍 如果当前切片的长达大于 1024，每次扩容 25% 的容量，直到新容量大于期望容量 在进行循环1.25倍计算时，最终容量计算值发生溢出，即超过了int的最大范围，则最终容量就是新申请的容量 对于切片的扩容 当切片比较小的，采用较大的扩容倍速进行扩容，避免频繁扩容，从而减少内存分配的次数和数据拷贝的代价 当切片较大的时，采用较小的扩容倍速，主要避免空间浪费 ","date":"2023-05-30","objectID":"/posts/go/interview01/:4:0","tags":["go","面试"],"title":"Golang_Interview_关键字","uri":"/posts/go/interview01/"},{"categories":["go"],"content":"channel的概念？ channel又称为管道，用于数据传递或数据共享，其本质是一个先进先出的队列，使用goroutine+channel进行数据通讯简单高效，同时也线程安全，多个goroutine可同时修改一个channel，不需要加锁。 ","date":"2023-05-30","objectID":"/posts/go/interview01/:5:0","tags":["go","面试"],"title":"Golang_Interview_关键字","uri":"/posts/go/interview01/"},{"categories":["go"],"content":"channel有哪些状态？ nil：未初始化的状态，只进行了声明，或者手动赋值为nil。 active：正常的channel，可读或者可写。 closed：已关闭，channel的值不是nil。 关闭的状态的channel仍然可以读值（取值），但不能写值（会报panic: send on closed channel）。 nil状态的channel是不能close（panic: close of nil channel）的。 如果关闭后的 channel 没有数据可读取时，将得到零值，即对应类型的默认值。 操作 空channel 已关闭channel 活跃中的channel close(ch) panic panic 成功关闭 ch\u003c- v（写） 永远阻塞 panic 成功发送或阻塞 v,ok = \u003c-ch（读） 永远阻塞 不阻塞 成功接收或阻塞 ","date":"2023-05-30","objectID":"/posts/go/interview01/:6:0","tags":["go","面试"],"title":"Golang_Interview_关键字","uri":"/posts/go/interview01/"},{"categories":["go"],"content":"如何判断channel已经关闭？ if v, ok := \u003c-ch; !ok { fmt.Println(\"channel 已关闭，读取不到数据\") } ","date":"2023-05-30","objectID":"/posts/go/interview01/:7:0","tags":["go","面试"],"title":"Golang_Interview_关键字","uri":"/posts/go/interview01/"},{"categories":["go"],"content":"select的用途？ select可以理解为是在语言层面实现了和I/O多路复用相似的功能：监听多个描述符的读/写等事件，一旦某个描述符就绪(一般是读或者写事件发生了)，就能够将发生的事件通知给关心的应用程序去处理该事件。 golang的select机制是：监听多个channel，每一个case是一个事件，可以是读事件也可以是写事件，随机选择一个执行。可以设置default，它的作用是当监听的多个事件都阻塞住就会执行default的逻辑。 select { case \u003c-ch1: // 如果从 ch1 信道成功接收数据，则执行该分支代码 case ch2 \u003c- 1: // 如果成功向 ch2 信道成功发送数据，则执行该分支代码 default: // 如果上面都没有成功，则进入 default 分支处理流程 } 提示\rselect语句只能用于信道的读写操作 select中的case条件(非阻塞)是并发执行的，select会选择先操作成功的那个case条件去执行，如果多个同时返回，则随机选择一个执行，此时将无法保证执行顺序 对于case条件语句中，如果存在信道值为nil的读写操作，则该分支将被忽略，可以理解为从select语句中删除了这个case语句 如果有超时条件语句，判断逻辑为如果在这个时间段内一直没有满足条件的case，则执行这个超时case。如果此段时间内出现了可操作的case，则直接执行这个case。一般用超时语句代替了default语句。 对于空的select{}，会引起死锁 对于for中的select{}, 可能会引起cpu占用过高的问题 ","date":"2023-05-30","objectID":"/posts/go/interview01/:8:0","tags":["go","面试"],"title":"Golang_Interview_关键字","uri":"/posts/go/interview01/"},{"categories":["go"],"content":"defer的概述？ defer是go语言提供的一种用于注册延迟调用的机制：让函数或者语句在当前函数执行完毕(包括return正常结束或者panic导致的异常结束)之后进行调用。 panic和defer到底谁先执行，这个问题没有搞清楚，需要自己写代码测试一下，我好像知道怎么回事了，得分具体的情况 defer具有以下特性： 延迟调用：defer在main函数return之前调用，且defer必须置于函数内部 LIFO：后进先出，压栈式执行 作用域：defer只和defer所在函数绑定在一起，作用域也只在这个函数，如果defer处于匿名函数中，会先调用匿名函数中的defer ","date":"2023-05-30","objectID":"/posts/go/interview01/:9:0","tags":["go","面试"],"title":"Golang_Interview_关键字","uri":"/posts/go/interview01/"},{"categories":["go"],"content":"defer的使用场景？ defer关键字通常通常出现在一些成对出现的操作中，比如创建关闭链接、加锁解锁、打开关闭文件等操作。defer在一些资源回收的场景很有用。 ","date":"2023-05-30","objectID":"/posts/go/interview01/:10:0","tags":["go","面试"],"title":"Golang_Interview_关键字","uri":"/posts/go/interview01/"},{"categories":["go"],"content":"并发处理 var wg sync.WaitGroup for i := 0; i \u003c 2; i++ { wg.Add(1) go func() { defer wg.Done() // 程序逻辑 }() } wg.Wait() ","date":"2023-05-30","objectID":"/posts/go/interview01/:10:1","tags":["go","面试"],"title":"Golang_Interview_关键字","uri":"/posts/go/interview01/"},{"categories":["go"],"content":"锁场景 mu.RLock() defer mu.RUnlock() ","date":"2023-05-30","objectID":"/posts/go/interview01/:10:2","tags":["go","面试"],"title":"Golang_Interview_关键字","uri":"/posts/go/interview01/"},{"categories":["go"],"content":"资源释放 // new 一个客户端 client； cli, err := clientv3.New(clientv3.Config{Endpoints: endpoints}) if err != nil { log.Fatal(err) } // 释放该 client ，也就是说该 client 的声明周期就只在该函数中； defer cli.Close() ","date":"2023-05-30","objectID":"/posts/go/interview01/:10:3","tags":["go","面试"],"title":"Golang_Interview_关键字","uri":"/posts/go/interview01/"},{"categories":["go"],"content":"panic-recover defer func() { if v := recover(); v != nil { _ = fmt.Errorf(\"PANIC=%v\", v) } }() ","date":"2023-05-30","objectID":"/posts/go/interview01/:10:4","tags":["go","面试"],"title":"Golang_Interview_关键字","uri":"/posts/go/interview01/"},{"categories":["Go每日一练"],"content":"Day11 ","date":"2023-05-30","objectID":"/posts/go/day11-20/:1:0","tags":["go","面试"],"title":"Go Exercises(Day11-20)","uri":"/posts/go/day11-20/"},{"categories":["Go每日一练"],"content":"1.关于 cap() 函数的适用类型，下面说法正确的是? A. array B. slice C. map D. channel 参考答案及解析：ABD。知识点：cap()，cap() 函数不适用 map，适用于array、slice、channel。 ","date":"2023-05-30","objectID":"/posts/go/day11-20/:1:1","tags":["go","面试"],"title":"Go Exercises(Day11-20)","uri":"/posts/go/day11-20/"},{"categories":["Go每日一练"],"content":"2.下面这段代码输出什么？ func main() { var i interface{} if i == nil { fmt.Println(\"nil\") return } fmt.Println(\"not nil\") } A. nil B. not nil C. compilation error 参考答案及解析：A。当且仅当接口的动态值和动态类型都为 nil 时，接口类型值才为 nil。 ","date":"2023-05-30","objectID":"/posts/go/day11-20/:1:2","tags":["go","面试"],"title":"Go Exercises(Day11-20)","uri":"/posts/go/day11-20/"},{"categories":["Go每日一练"],"content":"3.下面这段代码输出什么？ func main() { s := make(map[string]int) delete(s, \"h\") fmt.Println(s[\"h\"]) } A. runtime panic B. 0 C. compilation error 参考答案及解析：B。删除 map 不存在的键值对时，不会报错，相当于没有任何作用；获取不存在的键值对时，返回值类型对应的零值，所以返回 0。 ","date":"2023-05-30","objectID":"/posts/go/day11-20/:1:3","tags":["go","面试"],"title":"Go Exercises(Day11-20)","uri":"/posts/go/day11-20/"},{"categories":["Go每日一练"],"content":"Day12 ","date":"2023-05-30","objectID":"/posts/go/day11-20/:2:0","tags":["go","面试"],"title":"Go Exercises(Day11-20)","uri":"/posts/go/day11-20/"},{"categories":["Go每日一练"],"content":"1.下面属于关键字的是？ A.func B.struct C.class D.defer 参考答案及解析：ABD。知识点：Go 语言的关键字。Go 语言有 25 个关键字，看下图： ","date":"2023-05-30","objectID":"/posts/go/day11-20/:2:1","tags":["go","面试"],"title":"Go Exercises(Day11-20)","uri":"/posts/go/day11-20/"},{"categories":["Go每日一练"],"content":"2.下面这段代码输出什么？ func main() { i := -5 j := +5 fmt.Printf(\"%+d %+d\", i, j) } A. -5 +5 B. +5 +5 C. 0 0 参考答案及解析：A。%d表示输出十进制数字，+表示输出数值的符号。这里不表示取反。 ","date":"2023-05-30","objectID":"/posts/go/day11-20/:2:2","tags":["go","面试"],"title":"Go Exercises(Day11-20)","uri":"/posts/go/day11-20/"},{"categories":["Go每日一练"],"content":"3.下面这段代码输出什么？ type People struct{} func (p *People) ShowA() { fmt.Println(\"showA\") p.ShowB() } func (p *People) ShowB() { fmt.Println(\"showB\") } type Teacher struct { People } func (t *Teacher) ShowB() { fmt.Println(\"teacher showB\") } func main() { t := Teacher{} t.ShowB() } 参考答案及解析：teacher showB。知识点：结构体嵌套。在嵌套结构体中，People 称为内部类型，Teacher 称为外部类型；通过嵌套，内部类型的属性、方法，可以为外部类型所有，就好像是外部类型自己的一样。此外，外部类型还可以定义自己的属性和方法，甚至可以定义与内部相同的方法，这样内部类型的方法就会被“屏蔽”。这个例子中的 ShowB() 就是同名方法。 ","date":"2023-05-30","objectID":"/posts/go/day11-20/:2:3","tags":["go","面试"],"title":"Go Exercises(Day11-20)","uri":"/posts/go/day11-20/"},{"categories":["Go每日一练"],"content":"Day13","date":"2023-05-30","objectID":"/posts/go/day11-20/:3:0","tags":["go","面试"],"title":"Go Exercises(Day11-20)","uri":"/posts/go/day11-20/"},{"categories":["Gin"],"content":"中间件的注册 gin框架中的中间件设计很巧妙，我们可以首先从我们最常用的r := gin.Default()的Default函数开始看，它内部构造一个新的engine之后就通过Use()函数注册了Logger中间件和Recovery中间件： Logger中间件用于在我们的开发阶段，在终端打印出一些可供调试的日志。 Recovery中间件是在我们的程序发生panic的时候，恢复一下现场，防止程序崩掉。 func Default() *Engine { debugPrintWARNINGDefault() engine := New() engine.Use(Logger(), Recovery()) // 默认注册的两个中间件 return engine } 继续往下查看一下Use()函数的代码： func (engine *Engine) Use(middleware ...HandlerFunc) IRoutes { engine.RouterGroup.Use(middleware...) // 实际上还是调用的RouterGroup的Use函数 engine.rebuild404Handlers() engine.rebuild405Handlers() return engine } engine.RouterGroup.Use 从下方的代码可以看出，注册中间件其实就是将中间件函数追加到group.Handlers中： func (group *RouterGroup) Use(middleware ...HandlerFunc) IRoutes { group.Handlers = append(group.Handlers, middleware...) return group.returnObj() } 而我们注册路由时会将对应路由的函数和之前的中间件函数结合到一起： func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes { absolutePath := group.calculateAbsolutePath(relativePath) handlers = group.combineHandlers(handlers) // 将处理请求的函数与中间件函数结合 group.engine.addRoute(httpMethod, absolutePath, handlers) return group.returnObj() } 其中结合操作的函数内容如下，注意观察这里是如何实现拼接两个切片得到一个新切片的。 const abortIndex int8 = math.MaxInt8 / 2 func (group *RouterGroup) combineHandlers(handlers HandlersChain) HandlersChain { finalSize := len(group.Handlers) + len(handlers) if finalSize \u003e= int(abortIndex) { // 这里有一个最大限制 panic(\"too many handlers\") } mergedHandlers := make(HandlersChain, finalSize) copy(mergedHandlers, group.Handlers) copy(mergedHandlers[len(group.Handlers):], handlers) return mergedHandlers } 也就是说，我们会将一个路由的中间件函数和处理函数结合到一起组成一条处理函数链条HandlersChain，而它本质上就是一个由HandlerFunc组成的切片： type HandlersChain []HandlerFunc ","date":"2023-05-29","objectID":"/posts/gin/gin03/:1:0","tags":["Gin"],"title":"Gin框架中间件详解","uri":"/posts/gin/gin03/"},{"categories":["Gin"],"content":"中间件的执行 我们在上面路由匹配的时候见过如下逻辑： value := root.getValue(rPath, c.Params, unescape) if value.handlers != nil { c.handlers = value.handlers c.Params = value.params c.fullPath = value.fullPath c.Next() // 执行函数链条 c.writermem.WriteHeaderNow() return } 其中c.Next()就是很关键的一步，它的代码很简单： func (c *Context) Next() { c.index++ for c.index \u003c int8(len(c.handlers)) { c.handlers[c.index](c) c.index++ } } 从上面的代码可以看到，这里通过索引遍历HandlersChain链条，从而实现依次调用该路由的每一个函数（中间件或处理请求的函数）。 我们可以在中间件函数中通过再次调用c.Next()实现嵌套调用（func1中调用func2；func2中调用func3）， 或者通过调用c.Abort()中断整个调用链条，从当前函数返回。 func (c *Context) Abort() { c.index = abortIndex // 直接将索引置为最大限制值，从而退出循环，循环说的是c.Next()的循环 } ","date":"2023-05-29","objectID":"/posts/gin/gin03/:2:0","tags":["Gin"],"title":"Gin框架中间件详解","uri":"/posts/gin/gin03/"},{"categories":["Gin"],"content":"c.Set()/c.Get( ) c.Set()和c.Get()这两个方法多用于在多个函数之间通过c传递数据的，比如我们可以在认证中间件中获取当前请求的相关信息（userID等）通过c.Set()存入c，然后在后续处理业务逻辑的函数中通过c.Get()来获取当前请求的用户。c就像是一根绳子，将该次请求相关的所有的函数都串起来了。c.Set()存的时候存的是一个空接口类型，get的时候的拿到的也是空接口，然后再转的具体类型。 正如下图的逻辑，我们拿到v之后需要将它转换成想要的类型。 ","date":"2023-05-29","objectID":"/posts/gin/gin03/:3:0","tags":["Gin"],"title":"Gin框架中间件详解","uri":"/posts/gin/gin03/"},{"categories":["Gin"],"content":"总结 gin框架路由使用前缀树，路由注册的过程是构造前缀树的过程，路由匹配的过程就是查找前缀树的过程。 gin框架的中间件函数和处理函数是以切片形式的调用链条存在的，我们可以顺序调用也可以借助c.Next()方法实现嵌套调用。 借助c.Set()和c.Get()方法我们能够在不同的中间件函数中传递数据。 ","date":"2023-05-29","objectID":"/posts/gin/gin03/:4:0","tags":["Gin"],"title":"Gin框架中间件详解","uri":"/posts/gin/gin03/"},{"categories":["k8s"],"content":"Kubernetes基础概念 ","date":"2023-05-29","objectID":"/posts/k8s/k8s01/:0:0","tags":["k8s"],"title":"K8s入门1","uri":"/posts/k8s/k8s01/"},{"categories":["k8s"],"content":"是什么 在有了容器的概念之后，我们急需要一个大规模的容器编排系统，而k8s就是这样的一个系统。 kubernetes具有以下特性： 服务发现和负载均衡 Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。 服务发现是说，k8s自己能知道那个服务是坏的，宕掉的；而负载均衡是说干同样事情的3台机器，k8s选择性地进行分配任务。 存储编排 Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。 自动部署和回滚 你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。 自动完成装箱计算 Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。 自我修复 Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。 密钥与配置管理 Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。 Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移、部署模式等。 例如，Kubernetes 可以轻松管理系统的 Canary 部署。 ","date":"2023-05-29","objectID":"/posts/k8s/k8s01/:1:0","tags":["k8s"],"title":"K8s入门1","uri":"/posts/k8s/k8s01/"},{"categories":["k8s"],"content":"K8s架构 ","date":"2023-05-29","objectID":"/posts/k8s/k8s01/:2:0","tags":["k8s"],"title":"K8s入门1","uri":"/posts/k8s/k8s01/"},{"categories":["k8s"],"content":"工作方式 Kubernetes Cluster = N Master Node + N Worker Node：N主节点+N工作节点； N\u003e=1 在生产环境的安装都是集群模式，很多台机器都安装k8s，每一台机器叫做一个节点。N通常选奇数，这样方便投票选领导。 ","date":"2023-05-29","objectID":"/posts/k8s/k8s01/:2:1","tags":["k8s"],"title":"K8s入门1","uri":"/posts/k8s/k8s01/"},{"categories":["k8s"],"content":"组件架构 先理解以下几点： 集群中所有组件的交互都是通过api-server交互的。 集群里面的网络都是通过kube-proxy访问的。 集群中所有运行的应用，都需要有一个容器运行时环境，如docker。 集群中每一个节点都需有一个kubelet，监控节点中部署的所有应用的情况。 控制平面组件（Control Plane Components） 控制平面的组件对集群做出全局决策(比如调度)，以及检测和响应集群事件（例如，当不满足部署的 replicas 字段时，启动新的 pod）。 控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。 请参阅使用 kubeadm 构建高可用性集群 中关于多 VM 控制平面设置的示例。 kube-apiserver API 服务器是 Kubernetes 控制面的组件， 该组件公开了 Kubernetes API。 API 服务器是 Kubernetes 控制面的前端。 Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。 etcd etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。 您的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。 要了解 etcd 更深层次的信息，请参考 etcd 文档。 kube-scheduler 控制平面组件，负责监视新创建的、未指定运行节点（node）的 Pods，选择节点让 Pod 在上面运行。 调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。 kube-controller-manager 在主节点上运行 控制器 的组件。 从逻辑上讲，每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。 这些控制器包括: 节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应 任务控制器（Job controller）: 监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成 端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod) 服务帐户和令牌控制器（Service Account \u0026 Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌 cloud-controller-manager 云控制器管理器是指嵌入特定云的控制逻辑的 控制平面组件。 云控制器管理器允许您链接集群到云提供商的应用编程接口中， 并把和该云平台交互的组件与只和您的集群交互的组件分离开。 cloud-controller-manager 仅运行特定于云平台的控制回路。 如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的环境中不需要云控制器管理器。 与 kube-controller-manager 类似，cloud-controller-manager 将若干逻辑上独立的 控制回路组合到同一个可执行文件中，供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。 下面的控制器都包含对云平台驱动的依赖： 节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除 路由控制器（Route Controller）: 用于在底层云基础架构中设置路由 服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器 Node组件 节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。 kubelet 一个在集群中每个节点（node）上运行的代理。 它保证容器（containers）都 运行在 Pod 中。 kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。 kube-proxy kube-proxy 是集群中每个节点上运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。 kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。 如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身。 ","date":"2023-05-29","objectID":"/posts/k8s/k8s01/:2:2","tags":["k8s"],"title":"K8s入门1","uri":"/posts/k8s/k8s01/"},{"categories":["k8s"],"content":"Kubeadm创建集群 ","date":"2023-05-29","objectID":"/posts/k8s/k8s01/:3:0","tags":["k8s"],"title":"K8s入门1","uri":"/posts/k8s/k8s01/"},{"categories":["k8s"],"content":"先为每台机器安装docker ","date":"2023-05-29","objectID":"/posts/k8s/k8s01/:3:1","tags":["k8s"],"title":"K8s入门1","uri":"/posts/k8s/k8s01/"},{"categories":["k8s"],"content":"安装kubeadm 一台兼容的 Linux 主机。Kubernetes 项目为基于 Debian 和 Red Hat 的 Linux 发行版以及一些不提供包管理器的发行版提供通用的指令 每台机器 2 GB 或更多的 RAM （如果少于这个数字将会影响你应用的运行内存) 2 CPU 核或更多 集群中的所有机器的网络彼此均能相互连接(公网和内网都可以) 设置防火墙放行规则 节点之中不可以有重复的主机名、MAC 地址或 product_uuid。请参见这里了解更多详细信息。 设置不同hostname 开启机器上的某些端口。请参见这里 了解更多详细信息。 内网互信 禁用交换分区。为了保证 kubelet 正常工作，你 必须 禁用交换分区。 永久关闭 基础环境 #各个机器设置自己的域名 hostnamectl set-hostname xxxx # 将 SELinux 设置为 permissive 模式（相当于将其禁用） sudo setenforce 0 sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config #关闭swap swapoff -a sed -ri 's/.*swap.*/#\u0026/' /etc/fstab #允许 iptables 检查桥接流量 cat \u003c\u003cEOF | sudo tee /etc/modules-load.d/k8s.conf br_netfilter EOF cat \u003c\u003cEOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sudo sysctl --system 安装kubelet、kubeadm、kubectl cat \u003c\u003cEOF | sudo tee /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=0 repo_gpgcheck=0 gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg exclude=kubelet kubeadm kubectl EOF sudo yum install -y kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9 --disableexcludes=kubernetes sudo systemctl enable --now kubelet kubelet 现在每隔几秒就会重启，因为它陷入了一个等待 kubeadm 指令的死循环 ","date":"2023-05-29","objectID":"/posts/k8s/k8s01/:3:2","tags":["k8s"],"title":"K8s入门1","uri":"/posts/k8s/k8s01/"},{"categories":["k8s"],"content":"使用kubeadm引导集群 下载各个机器需要的镜像 sudo tee ./images.sh \u003c\u003c-'EOF' #!/bin/bash images=( kube-apiserver:v1.20.9 kube-proxy:v1.20.9 kube-controller-manager:v1.20.9 kube-scheduler:v1.20.9 coredns:1.7.0 etcd:3.4.13-0 pause:3.2 ) for imageName in ${images[@]} ; do docker pull registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/$imageName done EOF chmod +x ./images.sh \u0026\u0026 ./images.sh 初始化节点 #所有机器添加master域名映射，以下需要修改为自己的 echo \"自己的master的ip cluster-endpoint\" \u003e\u003e /etc/hosts #主节点初始化 kubeadm init \\ --apiserver-advertise-address=自己的master的ip \\ --control-plane-endpoint=上面设置好的域名的值，比如这里就是cluster-endpoint \\ --image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \\ --kubernetes-version v1.20.9 \\ --service-cidr=10.96.0.0/16 \\ --pod-network-cidr=192.168.0.0/16 #所有网络范围不重叠（service和pod和主节点、工作节点） Your Kubernetes control-plane has initialized successfully! # 我们使用我们的集群，需要先做这一步 To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config Alternatively, if you are the root user, you can run: export KUBECONFIG=/etc/kubernetes/admin.conf # 部署网络插件，使K8s里面的机器串起来，打通 You should now deploy a pod network to the cluster. Run \"kubectl apply -f [podnetwork].yaml\" with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ # 使用这个命令可以使集群中的其他节点也变为主节点 You can now join any number of control-plane nodes by copying certificate authorities and service account keys on each node and then running the following as root: kubeadm join cluster-endpoint:6443 --token hums8f.vyx71prsg74ofce7 \\ --discovery-token-ca-cert-hash sha256:a394d059dd51d68bb007a532a037d0a477131480ae95f75840c461e85e2c6ae3 \\ --control-plane # 使用这个命令可以使集群中的其他节点变为工作节点 Then you can join any number of worker nodes by running the following on each as root: kubeadm join cluster-endpoint:6443 --token hums8f.vyx71prsg74ofce7 \\ --discovery-token-ca-cert-hash sha256:a394d059dd51d68bb007a532a037d0a477131480ae95f75840c461e85e2c6ae3 #查看集群所有节点 这个命令只能在主节点上运行 kubectl get nodes #根据配置文件，给集群创建资源 kubectl apply -f xxxx.yaml #查看集群部署了哪些应用？ docker ps === kubectl get pods -A # 运行中的应用在docker里面叫容器，在k8s里面叫Pod kubectl get pods -A 根据提示继续 master成功后提示如下： 1、设置.kube/config 复制上面命令 2、安装网络组件 calico官网 curl https://docs.projectcalico.org/manifests/calico.yaml -O kubectl apply -f calico.yaml 加入node节点（在相应的子机器里使用 ） kubeadm join cluster-endpoint:6443 --token x5g4uy.wpjjdbgra92s25pp \\ --discovery-token-ca-cert-hash sha256:6255797916eaee52bf9dda9429db616fcd828436708345a308f4b917d3457a22 上面的令牌只能维持24h，如果令牌过期了，在master下使用如下命令生成新的令牌。执行该命令后会得到一串命令，这串命令就是用来新加node节点的。 kubeadm token create –print-join-command 高可用部署方式，也是在这一步的时候，使用添加主节点的命令即可 验证集群 验证集群节点状态 kubectl get nodes 部署dashboard 部署 kubernetes官方提供的可视化界面 https://github.com/kubernetes/dashboard kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.3.1/aio/deploy/recommended.yaml # Copyright 2017 The Kubernetes Authors. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. apiVersion: v1 kind: Namespace metadata: name: kubernetes-dashboard --- apiVersion: v1 kind: ServiceAccount metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kubernetes-dashboard --- kind: Service apiVersion: v1 metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kubernetes-dashboard spec: ports: - port: 443 targetPort: 8443 selector: k8s-app: kubernetes-dashboard --- apiVersion: v1 kind: Secret metada","date":"2023-05-29","objectID":"/posts/k8s/k8s01/:3:3","tags":["k8s"],"title":"K8s入门1","uri":"/posts/k8s/k8s01/"},{"categories":["docker"],"content":"Docker原生命令 ","date":"2023-05-29","objectID":"/posts/docker/docker09/:1:0","tags":["docker"],"title":"Docke--CIG容器监控","uri":"/posts/docker/docker09/"},{"categories":["docker"],"content":"CIG是什么 CAdvisor监控收集 + InfluxDB存储数组 + Grafana展示图表 ","date":"2023-05-29","objectID":"/posts/docker/docker09/:2:0","tags":["docker"],"title":"Docke--CIG容器监控","uri":"/posts/docker/docker09/"},{"categories":["docker"],"content":"CAdvisor CAdvisor是一个容器资源监控工具，包括容器的内存，CPU，网络IO，磁盘IO，等监控，同时提供了一个WEB页面用于查看容器的实时运行状态。CAdvisor默认存储2分钟的数据，而且只是针对单物理机。 不过，CAdvisor提供了很多数据集成接口，支持InfluxDB，Redis，Kafka，Elasticsearch等集成，可以加上对应配置将监控数据发往这些数据库存储起来。 CAdvisor功能主要有两点: 展示Host和容器两个层次的监控数据。 展示历史变化数据。 ","date":"2023-05-29","objectID":"/posts/docker/docker09/:2:1","tags":["docker"],"title":"Docke--CIG容器监控","uri":"/posts/docker/docker09/"},{"categories":["docker"],"content":"InluxDB InfluxDB是用Go语言编写的一个开源分布式时序事件和指标数据库，无需外部依赖。CAdvisor默认只在本机保存最近2分钟的数据，为了持久化存储数据和统一收集展示监控数据，需要将数据存储到InfluxDB中。InfluxDB是一个时序数据库，专用于存储时序相关数据，很适合存储CAdvisor的数据。而且，Advisor本身己经提供了InfluxDB的集成方法，等启动容器时指定配置即可。 InfluxDB主要功能： 基于时间序列，支持与时间有关的相关函数（如最大、最小、求和等）； 可度量性：你可以实时对大量数据进行计算； 基于事件：它支持任意的事件数据； ","date":"2023-05-29","objectID":"/posts/docker/docker09/:2:2","tags":["docker"],"title":"Docke--CIG容器监控","uri":"/posts/docker/docker09/"},{"categories":["docker"],"content":"Grafana Grafana是一个开源的数据监控分析可视化平台，支 持多种数据源配置(支持的数据源包括InfluxDB，MySQL， Elasticsearch，OpenTSDB，Graphite等)和丰富的插件及模板功能,支持图表权限控制和报警。 Grafana主要特性： 灵活丰富的图形化选项 可以混合多种风格 支持白天和夜间模式 多个数据源 ","date":"2023-05-29","objectID":"/posts/docker/docker09/:2:3","tags":["docker"],"title":"Docke--CIG容器监控","uri":"/posts/docker/docker09/"},{"categories":["docker"],"content":"利用compose容器编排，搭建CIG mkdir /mydocker/cig cd cig vim docker-compose.yml # 见下面 docker-compose config -q # 若无输出，代表yml文件没有问题 docker-compose up docker ps # 查看3个容器是否正常启动 version:'3.1' volumes: drafana_data:{} services: influxdb: image: tutum/influxdb:0.9 restart: always environment: -PRE_CREATE_DB=cadvisor ports: -\"8083:8083\" -\"8086:8086\" volumes: -./data/influxdb:/data cadvisor: image: google/cadvisor links: -influxdb: ingluxsrn command: -storage=influxdb -storge_driverdb=cadvisor -storage_driver_host=influxsrv:8086 restart: always ports: -\"8080:8080\" volumes: -/:/rootfs:ro gradana: user: \"104\" image: grafana/grafana user: \"104\" restart: always links: -influxdb: influxsrv ports: -\"3000:3000\" volumes: -grafana_data: /var/lib/grafana environment: -HTTP_USER=admin -HTTP_PASS=admin -INFLUXDB_HOST=influxsrv\\ -INFLUXDB_PORT=8086 -INFLUXDB_NAME=cadvisor -INFLUXDB_USER=root -INFLUXDB_PASS=root 浏览cAdvisor收集服务，http://ip:8080/ 浏览influxdb存储服务，http://ip:8083/ 浏览grafana展现服务，http://ip:3000/ grafana，默认账户和密码都是admin。 grafana配置步骤： 配置数据源 选择influxdb数据源 配置细节 配置面板panel ","date":"2023-05-29","objectID":"/posts/docker/docker09/:3:0","tags":["docker"],"title":"Docke--CIG容器监控","uri":"/posts/docker/docker09/"},{"categories":["gin"],"content":"后面的代码太长了，还没有看…… gin框架使用的是定制版本的httprouter，其路由的原理是大量使用公共前缀的树结构，它基本上是一个紧凑的Trie tree（或者只是Radix Tree）。具有公共前缀的节点也共享一个公共父节点。 ","date":"2023-05-28","objectID":"/posts/gin/gin02/:0:0","tags":["gin","go web"],"title":"Gin框架路由详解","uri":"/posts/gin/gin02/"},{"categories":["gin"],"content":"Radix Tree 基数树（Radix Tree）又称为PAT位树（Patricia Trie or crit bit tree），是一种更节省空间的前缀树（Trie Tree）。对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。下图为一个基数树示例： Radix Tree可以被认为是一棵简洁版的前缀树。我们注册路由的过程就是构造前缀树的过程，具有公共前缀的节点也共享一个公共父节点。假设我们现在注册有以下路由信息： r := gin.Default() r.GET(\"/\", func1) r.GET(\"/search/\", func2) r.GET(\"/support/\", func3) r.GET(\"/blog/\", func4) r.GET(\"/blog/:post/\", func5) r.GET(\"/about-us/\", func6) r.GET(\"/about-us/team/\", func7) r.GET(\"/contact/\", func8) 那么我们会得到一个GET方法对应的路由树，具体结构如下： Priority Path Handle 9 \\ *\u003c1\u003e 3 ├s nil 2 |├earch\\ *\u003c2\u003e 1 |└upport\\ *\u003c3\u003e 2 ├blog\\ *\u003c4\u003e 1 | └:post nil 1 | └\\ *\u003c5\u003e 2 ├about-us\\ *\u003c6\u003e 1 | └team\\ *\u003c7\u003e 1 └contact\\ *\u003c8\u003e 上面最右边那一列每个*\u003c数字\u003e表示Handle处理函数的内存地址(一个指针)。从根节点遍历到叶子节点我们就能得到完整的路由表。 例如：blog/:post其中:post只是实际文章名称的占位符(参数)。与hash-maps不同，这种树结构还允许我们使用像:post参数这种动态部分，因为我们实际上是根据路由模式进行匹配，而不仅仅是比较哈希值。 由于URL路径具有层次结构，并且只使用有限的一组字符(字节值)，所以很可能有许多常见的前缀。这使我们可以很容易地将路由简化为更小的问题。此外，路由器为每种请求方法管理一棵单独的树。一方面，它比在每个节点中都保存一个method-\u003e handle map更加节省空间，它还使我们甚至可以在开始在前缀树中查找之前大大减少路由问题。 为了获得更好的可伸缩性，每个树级别上的子节点都按Priority(优先级)排序，其中优先级（最左列）就是在子节点(子节点、子子节点等等)中注册的句柄的数量。这样做有两个好处: 首先优先匹配被大多数路由路径包含的节点。这样可以让尽可能多的路由快速被定位。 类似于成本补偿。最长的路径可以被优先匹配，补偿体现在最长的路径需要花费更长的时间来定位，如果最长路径的节点能被优先匹配（即每次拿子节点都命中），那么路由匹配所花的时间不一定比短路径的路由长。下面展示了节点（每个-可以看做一个节点）匹配的路径：从左到右，从上到下。 总结一下就是说，这样可以平均长短路由的查找时间。因为如果我们先从短路由查起，短路由很快能匹配上，而长路由的时间需要很长很长很长。 ├------------ ├--------- ├----- ├---- ├-- ├-- └- ","date":"2023-05-28","objectID":"/posts/gin/gin02/:1:0","tags":["gin","go web"],"title":"Gin框架路由详解","uri":"/posts/gin/gin02/"},{"categories":["gin"],"content":"r.Run() func (engine *Engine) Run(addr ...string) (err error) { defer func() { debugPrintError(err) }() if engine.isUnsafeTrustedProxies() { debugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" + \"Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.\") } address := resolveAddress(addr) debugPrint(\"Listening and serving HTTP on %s\\n\", address) err = http.ListenAndServe(address, engine.Handler()) return } 查看ListenAndServe源码，ListenAndServe有两个参数addr string, handler Handler，其中第二个参数Handler是一个接口类型，实现的是ServeHTTP方法。所以说r就是一个实现了ServeHTTP方法的engine *Engine。 接下来我们去寻找，Engine中实现的ServerHTTP方法。查看Engine的源码结构。 ** 为我们阅读源代码总结的内容，学到的东西。 // ServeHTTP conforms to the http.Handler interface. func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { // **通过使用对象池减少每次临时创建对象的内存申请和垃圾回收的消耗 c := engine.pool.Get().(*Context) // **在从池子里取出对象之后，对其初始化 c.writermem.reset(w) c.Request = req c.reset() // 处理HTTP请求 engine.handleHTTPRequest(c) // 放回池子 engine.pool.Put(c) } //**相较于 for i := 0; i \u003c len(t); i++ 源码的方式更好，因为我们只求一遍len(t) for i, tl := 0, len(t); i \u003c tl; i++ { if t[i].method != httpMethod { //** 写代码的时候，把不可能实现的情况，如continue或者return写到前面，这样不就直接退出或者走下一步的流程了。 continue } ... } t := engine.trees 下图中也是一个常见的写法，先写一个结构体，再写一个 _ 接口类型 = 空结构体的指针，目的是确保结构体实现了我们写的这个接口。是想把问题暴露给编译器，便于我们解决bug，如果我们的结构体忘记实现了该接口，那么173行的这段代码就会编译报错，我们就能发现问题了。 可以看到该tree就是请求方法的树结构，我们之前讲过，每一个请求对应着一颗树。 methodTrees methodTree 可以发现Gin框架并没有使用hash，使用map去存请求，因为使用map会更占用内存，Gin选择的是树结构，一个请求方法对应一颗树。 get函数是根据请求方法遍历所有的请求树，返回给要的那颗。 r := gin.Default() *Engine 我们也可以看到Engine在初始化的时候，建的trees就是一个切片，切片的容量是9，是因为在http1.1中有9种请求方法，最多就有9颗树。我们也可以学到，像这种初始化，如果我们提前知道切片的最大容量是多少，最好在初始化的时候给出容量，将内存一次性申请到位，防止后面的动态申请、扩容内存，当然要具体根据我们的项目来定。 ","date":"2023-05-28","objectID":"/posts/gin/gin02/:2:0","tags":["gin","go web"],"title":"Gin框架路由详解","uri":"/posts/gin/gin02/"},{"categories":["gin"],"content":"查看go源码的一个小技巧 点击结构体左侧的向上的箭头，可以查看该结构体实现了那些接口 我们点进Handler接口进一步查看。点击下面的箭头还可以查看，实现了该接口的所有类型，以及具体的实现方法。 总结一下，通过上面的方法，我们可以快速找到一个结构体实现的接口，并且找到该结构体实现该接口的具体方法。 接下来我们继续看node，见下一章。 ","date":"2023-05-28","objectID":"/posts/gin/gin02/:3:0","tags":["gin","go web"],"title":"Gin框架路由详解","uri":"/posts/gin/gin02/"},{"categories":["gin"],"content":"路由树节点 路由树是由一个个节点构成的，gin框架路由树的节点由node结构体表示，它有以下字段： // tree.go type node struct { // 节点路径，比如上面的s，earch，和upport path string // 和children字段对应, 保存的是分裂的分支的第一个字符 // 例如search和support, 那么s节点的indices对应的\"eu\" // 代表有两个分支, 分支的首字母分别是e和u indices string // 儿子节点 children []*node // 处理函数链条（切片） handlers HandlersChain // 优先级，子节点、子子节点等注册的handler数量 priority uint32 // 节点类型，包括static, root, param, catchAll // static: 静态节点（默认），比如上面的s，earch等节点 // root: 树的根节点 // catchAll: 有*匹配的节点 // param: 参数节点 nType nodeType // 路径上最大参数个数 maxParams uint8 // 节点是否是参数节点，比如上面的:post wildChild bool // 完整路径 fullPath string } ","date":"2023-05-28","objectID":"/posts/gin/gin02/:4:0","tags":["gin","go web"],"title":"Gin框架路由详解","uri":"/posts/gin/gin02/"},{"categories":["gin"],"content":"请求方法树 这里前面阅读源代码的部分有的有讲过。 在gin的路由中，每一个HTTP Method(GET、POST、PUT、DELETE…)都对应了一棵 radix tree，我们注册路由的时候会调用下面的addRoute函数： // gin.go func (engine *Engine) addRoute(method, path string, handlers HandlersChain) { // liwenzhou.com... // 获取请求方法对应的树 root := engine.trees.get(method) if root == nil { // 如果没有就创建一个 root = new(node) root.fullPath = \"/\" engine.trees = append(engine.trees, methodTree{method: method, root: root}) } // 这里后面有讲 root.addRoute(path, handlers) } 从上面的代码中我们可以看到在注册路由的时候都是先根据请求方法获取对应的树，也就是gin框架会为每一个请求方法创建一棵对应的树。只不过需要注意到一个细节是gin框架中保存请求方法对应树关系并不是使用的map而是使用的切片，engine.trees的类型是methodTrees，其定义如下： type methodTree struct { method string root *node } type methodTrees []methodTree // slice 而获取请求方法对应树的get方法定义如下： func (trees methodTrees) get(method string) *node { for _, tree := range trees { if tree.method == method { return tree.root } } return nil } 为什么使用切片而不是map来存储请求方法-\u003e树的结构呢？我猜是出于节省内存的考虑吧，毕竟HTTP请求方法的数量是固定的，而且常用的就那几种，所以即使使用切片存储查询起来效率也足够了。顺着这个思路，我们可以看一下gin框架中engine的初始化方法中，确实对tress字段做了一次内存申请： func New() *Engine { debugPrintWARNINGNew() engine := \u0026Engine{ RouterGroup: RouterGroup{ Handlers: nil, basePath: \"/\", root: true, }, // liwenzhou.com ... // 初始化容量为9的切片（HTTP1.1请求方法共9种） trees: make(methodTrees, 0, 9), // liwenzhou.com... } engine.RouterGroup.engine = engine engine.pool.New = func() interface{} { return engine.allocateContext() } return engine } ","date":"2023-05-28","objectID":"/posts/gin/gin02/:5:0","tags":["gin","go web"],"title":"Gin框架路由详解","uri":"/posts/gin/gin02/"},{"categories":["gin"],"content":"注册路由 注册路由的逻辑主要有addRoute函数和insertChild方法。 ","date":"2023-05-28","objectID":"/posts/gin/gin02/:6:0","tags":["gin","go web"],"title":"Gin框架路由详解","uri":"/posts/gin/gin02/"},{"categories":["gin"],"content":"查看源码 r.GET() 插一嘴，这里为什么r作为Engine类型能调用GET方法，是因为下图，Engine中嵌套了RouterGroup。 接下来group.handle group.combineHandlers一个拼接的操作，看一下怎么实现的。 group.engine.addRoute是重点。 ","date":"2023-05-28","objectID":"/posts/gin/gin02/:6:1","tags":["gin","go web"],"title":"Gin框架路由详解","uri":"/posts/gin/gin02/"},{"categories":["gin"],"content":"addRoute // tree.go // addRoute 将具有给定句柄的节点添加到路径中。 // 不是并发安全的 func (n *node) addRoute(path string, handlers HandlersChain) { fullPath := path n.priority++ numParams := countParams(path) // 数一下参数个数 // 空树就直接插入当前节点 if len(n.path) == 0 \u0026\u0026 len(n.children) == 0 { n.insertChild(numParams, path, fullPath, handlers) n.nType = root return } parentFullPathIndex := 0 walk: for { // 更新当前节点的最大参数个数 if numParams \u003e n.maxParams { n.maxParams = numParams } // 找到最长的通用前缀 // 这也意味着公共前缀不包含“:”\"或“*” / // 因为现有键不能包含这些字符。 i := longestCommonPrefix(path, n.path) // 分裂边缘（此处分裂的是当前树节点） // 例如一开始path是search，新加入support，s是他们通用的最长前缀部分 // 那么会将s拿出来作为parent节点，增加earch和upport作为child节点 if i \u003c len(n.path) { child := node{ path: n.path[i:], // 公共前缀后的部分作为子节点 wildChild: n.wildChild, indices: n.indices, children: n.children, handlers: n.handlers, priority: n.priority - 1, //子节点优先级-1 fullPath: n.fullPath, } // Update maxParams (max of all children) for _, v := range child.children { if v.maxParams \u003e child.maxParams { child.maxParams = v.maxParams } } n.children = []*node{\u0026child} // []byte for proper unicode char conversion, see #65 n.indices = string([]byte{n.path[i]}) n.path = path[:i] n.handlers = nil n.wildChild = false n.fullPath = fullPath[:parentFullPathIndex+i] } // 将新来的节点插入新的parent节点作为子节点 if i \u003c len(path) { path = path[i:] if n.wildChild { // 如果是参数节点 parentFullPathIndex += len(n.path) n = n.children[0] n.priority++ // Update maxParams of the child node if numParams \u003e n.maxParams { n.maxParams = numParams } numParams-- // 检查通配符是否匹配 if len(path) \u003e= len(n.path) \u0026\u0026 n.path == path[:len(n.path)] { // 检查更长的通配符, 例如 :name and :names if len(n.path) \u003e= len(path) || path[len(n.path)] == '/' { continue walk } } pathSeg := path if n.nType != catchAll { pathSeg = strings.SplitN(path, \"/\", 2)[0] } prefix := fullPath[:strings.Index(fullPath, pathSeg)] + n.path panic(\"'\" + pathSeg + \"' in new path '\" + fullPath + \"' conflicts with existing wildcard '\" + n.path + \"' in existing prefix '\" + prefix + \"'\") } // 取path首字母，用来与indices做比较 c := path[0] // 处理参数后加斜线情况 if n.nType == param \u0026\u0026 c == '/' \u0026\u0026 len(n.children) == 1 { parentFullPathIndex += len(n.path) n = n.children[0] n.priority++ continue walk } // 检查路path下一个字节的子节点是否存在 // 比如s的子节点现在是earch和upport，indices为eu // 如果新加一个路由为super，那么就是和upport有匹配的部分u，将继续分列现在的upport节点 for i, max := 0, len(n.indices); i \u003c max; i++ { if c == n.indices[i] { parentFullPathIndex += len(n.path) i = n.incrementChildPrio(i) n = n.children[i] continue walk } } // 否则就插入 if c != ':' \u0026\u0026 c != '*' { // []byte for proper unicode char conversion, see #65 // 注意这里是直接拼接第一个字符到n.indices n.indices += string([]byte{c}) child := \u0026node{ maxParams: numParams, fullPath: fullPath, } // 追加子节点 n.children = append(n.children, child) n.incrementChildPrio(len(n.indices) - 1) n = child } n.insertChild(numParams, path, fullPath, handlers) return } // 已经注册过的节点 if n.handlers != nil { panic(\"handlers are already registered for path '\" + fullPath + \"'\") } n.handlers = handlers return } } 其实上面的代码很好理解，大家可以参照动画尝试将以下情形代入上面的代码逻辑，体味整个路由树构造的详细过程： 第一次注册路由，例如注册search 继续注册一条没有公共前缀的路由，例如blog 注册一条与先前注册的路由有公共前缀的路由，例如support insertChild // tree.go func (n *node) insertChild(numParams uint8, path string, fullPath string, handlers HandlersChain) { // 找到所有的参数 for numParams \u003e 0 { // 查找前缀直到第一个通配符 wildcard, i, valid := findWildcard(path) if i \u003c 0 { // 没有发现通配符 break } // 通配符的名称必须包含':' 和 '*' if !valid { panic(\"only one wildcard per path segment is allowed, has: '\" + wildcard + \"' in path '\" + fullPath + \"'\") } // 检查通配符是否有名称 if len(wildcard) \u003c 2 { panic(\"wildcards must be named with a non-empty name in path '\" + fullPath + \"'\") } // 检查这个节点是否有已经存在的子节点 // 如果我们在这里插入通配符，这些子节点将无法访问 if len(n.children) \u003e 0 { panic(\"wildcard segment '\" + wildcard + \"' conflicts with existing children in path '\" + fullPath + \"'\") } if wildcard[0] == ':' { // param if i \u003e 0 { // 在当前通配符之前插入前缀 n.path = path[:i] path = path[i:] } n.wildChild = true child := \u0026node{ nType: param, path: wildcard, maxParams: numParams, fullPath: fullPath, } n.children = []*nod","date":"2023-05-28","objectID":"/posts/gin/gin02/:6:2","tags":["gin","go web"],"title":"Gin框架路由详解","uri":"/posts/gin/gin02/"},{"categories":["gin"],"content":"路由匹配 我们先来看gin框架处理请求的入口函数ServeHTTP： // gin.go func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { // 这里使用了对象池 c := engine.pool.Get().(*Context) // 这里有一个细节就是Get对象后做初始化 c.writermem.reset(w) c.Request = req c.reset() engine.handleHTTPRequest(c) // 我们要找的处理HTTP请求的函数 engine.pool.Put(c) // 处理完请求后将对象放回池子 } 函数很长，这里省略了部分代码，只保留相关逻辑代码： // gin.go func (engine *Engine) handleHTTPRequest(c *Context) { // liwenzhou.com... // 根据请求方法找到对应的路由树 t := engine.trees for i, tl := 0, len(t); i \u003c tl; i++ { if t[i].method != httpMethod { continue } root := t[i].root // 在路由树中根据path查找 value := root.getValue(rPath, c.Params, unescape) if value.handlers != nil { c.handlers = value.handlers c.Params = value.params c.fullPath = value.fullPath c.Next() // 执行函数链条 c.writermem.WriteHeaderNow() return } // liwenzhou.com... c.handlers = engine.allNoRoute serveError(c, http.StatusNotFound, default404Body) } 路由匹配是由节点的 getValue方法实现的。getValue根据给定的路径(键)返回nodeValue值，保存注册的处理函数和匹配到的路径参数数据。 如果找不到任何处理函数，则会尝试TSR(尾随斜杠重定向)。 代码虽然很长，但还算比较工整。大家可以借助注释看一下路由查找及参数匹配的逻辑。 / tree.go type nodeValue struct { handlers HandlersChain params Params // []Param tsr bool fullPath string } // liwenzhou.com... func (n *node) getValue(path string, po Params, unescape bool) (value nodeValue) { value.params = po walk: // Outer loop for walking the tree for { prefix := n.path if path == prefix { // 我们应该已经到达包含处理函数的节点。 // 检查该节点是否注册有处理函数 if value.handlers = n.handlers; value.handlers != nil { value.fullPath = n.fullPath return } if path == \"/\" \u0026\u0026 n.wildChild \u0026\u0026 n.nType != root { value.tsr = true return } // 没有找到处理函数 检查这个路径末尾+/ 是否存在注册函数 indices := n.indices for i, max := 0, len(indices); i \u003c max; i++ { if indices[i] == '/' { n = n.children[i] value.tsr = (len(n.path) == 1 \u0026\u0026 n.handlers != nil) || (n.nType == catchAll \u0026\u0026 n.children[0].handlers != nil) return } } return } if len(path) \u003e len(prefix) \u0026\u0026 path[:len(prefix)] == prefix { path = path[len(prefix):] // 如果该节点没有通配符(param或catchAll)子节点 // 我们可以继续查找下一个子节点 if !n.wildChild { c := path[0] indices := n.indices for i, max := 0, len(indices); i \u003c max; i++ { if c == indices[i] { n = n.children[i] // 遍历树 continue walk } } // 没找到 // 如果存在一个相同的URL但没有末尾/的叶子节点 // 我们可以建议重定向到那里 value.tsr = path == \"/\" \u0026\u0026 n.handlers != nil return } // 根据节点类型处理通配符子节点 n = n.children[0] switch n.nType { case param: // find param end (either '/' or path end) end := 0 for end \u003c len(path) \u0026\u0026 path[end] != '/' { end++ } // 保存通配符的值 if cap(value.params) \u003c int(n.maxParams) { value.params = make(Params, 0, n.maxParams) } i := len(value.params) value.params = value.params[:i+1] // 在预先分配的容量内扩展slice value.params[i].Key = n.path[1:] val := path[:end] if unescape { var err error if value.params[i].Value, err = url.QueryUnescape(val); err != nil { value.params[i].Value = val // fallback, in case of error } } else { value.params[i].Value = val } // 继续向下查询 if end \u003c len(path) { if len(n.children) \u003e 0 { path = path[end:] n = n.children[0] continue walk } // ... but we can't value.tsr = len(path) == end+1 return } if value.handlers = n.handlers; value.handlers != nil { value.fullPath = n.fullPath return } if len(n.children) == 1 { // 没有找到处理函数. 检查此路径末尾加/的路由是否存在注册函数 // 用于 TSR 推荐 n = n.children[0] value.tsr = n.path == \"/\" \u0026\u0026 n.handlers != nil } return case catchAll: // 保存通配符的值 if cap(value.params) \u003c int(n.maxParams) { value.params = make(Params, 0, n.maxParams) } i := len(value.params) value.params = value.params[:i+1] // 在预先分配的容量内扩展slice value.params[i].Key = n.path[2:] if unescape { var err error if value.params[i].Value, err = url.QueryUnescape(path); err != nil { value.params[i].Value = path // fallback, in case of error } } else { value.params[i].Value = path } value.handlers = n.handlers value.fullPath = n.fullPath return default: panic(\"invalid node type\") } } // 找不到，如果存在一个在当前路径最后添加/的路由 // 我们会建议重定向到那里 value.tsr = (path == \"/\") || (len(prefix) == len(path)+1 \u0026\u0026 prefix[len(path)] == '/' \u0026\u0026 path == prefix[:len(prefix)-1] \u0026\u0026 n.handlers != nil) return } } ","date":"2023-05-28","objectID":"/posts/gin/gin02/:7:0","tags":["gin","go web"],"title":"Gin框架路由详解","uri":"/posts/gin/gin02/"},{"categories":["docker"],"content":"是什么 Portainer是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。 ","date":"2023-05-28","objectID":"/posts/docker/docker08/:1:0","tags":["docker"],"title":"Docker轻量级可视化工具Portainer","uri":"/posts/docker/docker08/"},{"categories":["docker"],"content":"安装 官网 ，下载 stack指的是编排好的组。 第一次登录创建admin，访问地址：xxx.xxx.xxx.xxx:9000 设置admin用户和密码后首次登录 选择local选项卡后本地docker详细信息展示 docker svstem df ","date":"2023-05-28","objectID":"/posts/docker/docker08/:2:0","tags":["docker"],"title":"Docker轻量级可视化工具Portainer","uri":"/posts/docker/docker08/"},{"categories":["docker"],"content":"常用操作 很简单，自己玩。 ","date":"2023-05-28","objectID":"/posts/docker/docker08/:3:0","tags":["docker"],"title":"Docker轻量级可视化工具Portainer","uri":"/posts/docker/docker08/"},{"categories":["docker"],"content":"Compose是什么 Docker-Compose是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。 Compose是Docker公司推出的一个工具软件，可以管理多个Docker容器组成一个应用。 你需要定义一个YAML格式的配置文件docker-compose.yml，写好多个容器之间的调用关系。然后，只要一个命令， 就能同时启动或关闭这些容器。通俗的解释就是，当我们的容器很多的时候，就不同一个个去run，一个个stop了，同时通过Compose也可以控制容器启动的先后顺序。 ","date":"2023-05-28","objectID":"/posts/docker/docker07/:1:0","tags":["docker","微服务"],"title":"Docker-compose容器编排","uri":"/posts/docker/docker07/"},{"categories":["docker"],"content":"Compose能干嘛 docker建议我们每一个容器中只运行一个服务，因为docker容器本身占用资源极少，所以最好是将每个服务单独的分割开来，但是这样我们又面临了一个 问题? 如果我需要同时部署好多个服务，难道要每个服务单独写Dockerfile然后在构建镜像，构建容器，这样累都累死了,所以docker官方给我们提供了docker-compose多服务部署的工具。 例如要实现一个Web微服务项目，除了Web服务容器本身，往往还需要再加上后端的数据库mysq|服务容器，redis服务器，注册中心eureka，甚至还包括负载均衡容器等等。 Compose允许用户通过一 个单独的docker-compose.yml模板文件(YAML格式)来定义一组相关联的应用容器为一个项目(project) 。可以很容易地用一个配置 文件定义一个多 容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。 ","date":"2023-05-28","objectID":"/posts/docker/docker07/:2:0","tags":["docker","微服务"],"title":"Docker-compose容器编排","uri":"/posts/docker/docker07/"},{"categories":["docker"],"content":"去哪里下载 官网、[官网下载](https://docs.docker .com/compose/install/) 卸载：sudo rm /usr/local/bin/docker-compose ","date":"2023-05-28","objectID":"/posts/docker/docker07/:3:0","tags":["docker","微服务"],"title":"Docker-compose容器编排","uri":"/posts/docker/docker07/"},{"categories":["docker"],"content":"Compose核心概念 ","date":"2023-05-28","objectID":"/posts/docker/docker07/:4:0","tags":["docker","微服务"],"title":"Docker-compose容器编排","uri":"/posts/docker/docker07/"},{"categories":["docker"],"content":"一文件 docker-compose.yml ","date":"2023-05-28","objectID":"/posts/docker/docker07/:4:1","tags":["docker","微服务"],"title":"Docker-compose容器编排","uri":"/posts/docker/docker07/"},{"categories":["docker"],"content":"两要素 服务（service）与工程（project） 服务是指一个个应用容器实例，比如订单微服务、库存微服务、mysql容器、nginx容器或者redis容器。 由一组关联的应用容器组成的一个完整业务单元，在docker-compose.yml文件中定义。 即 工程 = 多个服务（容器应用实例） ","date":"2023-05-28","objectID":"/posts/docker/docker07/:4:2","tags":["docker","微服务"],"title":"Docker-compose容器编排","uri":"/posts/docker/docker07/"},{"categories":["docker"],"content":"Compose使用的三个步骤 编写Dockerfile定义各个微服务应用并构建出对应的镜像文件； 使用docker-compose.yml定义一个完整业务单元，安排好整体应用中的各个容器服务。 最后，执行docker-compose up 命令来启动并运行整个应用程序，完成一键部署上线。 ","date":"2023-05-28","objectID":"/posts/docker/docker07/:5:0","tags":["docker","微服务"],"title":"Docker-compose容器编排","uri":"/posts/docker/docker07/"},{"categories":["docker"],"content":"Compose常用命令 docker-compose -h # 查看帮助 docker-compose up # 启动所有docker-compose服务 docker-compose up -d # 启动所有docker-compose服务并后台运行 docker-compose down # 停止并删除容器、网络、卷、镜像 docker-compose exec yml里面的服务id # 进入容器实例内部 docker-compose exec docker-compose.yml文件中写的服务id /bin/bash docker-compose ps # 展示当前docker-compose编排过的运行的所有容器 docker-compose top # 展示当前docker-compose编排过的容器进程 docker-compose logs yml里面的服务id # 查看容器输出日志 docker-compose config # 检查配置 docker-compose config -q # 检查配置，有问题才有输出 docker-compose restart docker-compose start docker-compose stop ","date":"2023-05-28","objectID":"/posts/docker/docker07/:6:0","tags":["docker","微服务"],"title":"Docker-compose容器编排","uri":"/posts/docker/docker07/"},{"categories":["docker"],"content":"Compose编排微服务（这块没学，等学完微服务的）","date":"2023-05-28","objectID":"/posts/docker/docker07/:7:0","tags":["docker","微服务"],"title":"Docker-compose容器编排","uri":"/posts/docker/docker07/"},{"categories":["docker"],"content":"为什么会有docker的出现 ","date":"2023-05-27","objectID":"/posts/docker/docker01/:1:0","tags":["docker"],"title":"Docker介绍","uri":"/posts/docker/docker01/"},{"categories":["docker"],"content":"Docker理念 ","date":"2023-05-27","objectID":"/posts/docker/docker01/:2:0","tags":["docker"],"title":"Docker介绍","uri":"/posts/docker/docker01/"},{"categories":["docker"],"content":"容器与虚拟机比较 ","date":"2023-05-27","objectID":"/posts/docker/docker01/:3:0","tags":["docker"],"title":"Docker介绍","uri":"/posts/docker/docker01/"},{"categories":["docker"],"content":"传统虚拟机技术 缺点： 资源占用多 冗余步骤多 启动慢 ","date":"2023-05-27","objectID":"/posts/docker/docker01/:3:1","tags":["docker"],"title":"Docker介绍","uri":"/posts/docker/docker01/"},{"categories":["docker"],"content":"容器虚拟化技术 ","date":"2023-05-27","objectID":"/posts/docker/docker01/:3:2","tags":["docker"],"title":"Docker介绍","uri":"/posts/docker/docker01/"},{"categories":["docker"],"content":"Docker能干嘛 ","date":"2023-05-27","objectID":"/posts/docker/docker01/:4:0","tags":["docker"],"title":"Docker介绍","uri":"/posts/docker/docker01/"},{"categories":["docker"],"content":"Docker的基本组成 ","date":"2023-05-27","objectID":"/posts/docker/docker01/:5:0","tags":["docker"],"title":"Docker介绍","uri":"/posts/docker/docker01/"},{"categories":["docker"],"content":"1.镜像(image) ","date":"2023-05-27","objectID":"/posts/docker/docker01/:5:1","tags":["docker"],"title":"Docker介绍","uri":"/posts/docker/docker01/"},{"categories":["docker"],"content":"2.容器(container) ","date":"2023-05-27","objectID":"/posts/docker/docker01/:5:2","tags":["docker"],"title":"Docker介绍","uri":"/posts/docker/docker01/"},{"categories":["docker"],"content":"3.仓库(repository) ","date":"2023-05-27","objectID":"/posts/docker/docker01/:5:3","tags":["docker"],"title":"Docker介绍","uri":"/posts/docker/docker01/"},{"categories":["docker"],"content":"4.小总结 ","date":"2023-05-27","objectID":"/posts/docker/docker01/:5:4","tags":["docker"],"title":"Docker介绍","uri":"/posts/docker/docker01/"},{"categories":["docker"],"content":"Docker架构图解 ","date":"2023-05-27","objectID":"/posts/docker/docker01/:6:0","tags":["docker"],"title":"Docker介绍","uri":"/posts/docker/docker01/"},{"categories":["docker"],"content":"Docker安装 不用这条命令去安装，因为访问外网的请求会超时，所以要设置镜像 底层原理，为什么docker比虚拟机快 ","date":"2023-05-27","objectID":"/posts/docker/docker01/:7:0","tags":["docker"],"title":"Docker介绍","uri":"/posts/docker/docker01/"},{"categories":["docker"],"content":"Docker常用命令 ","date":"2023-05-27","objectID":"/posts/docker/docker01/:8:0","tags":["docker"],"title":"Docker介绍","uri":"/posts/docker/docker01/"},{"categories":["docker"],"content":"帮助启动类命令 systemctl start docker systemctl stop docker systemctl restart docker systemctl status docker systemctl enable docker docker info docker --help docker \u003c具体命令\u003e --help ","date":"2023-05-27","objectID":"/posts/docker/docker01/:8:1","tags":["docker"],"title":"Docker介绍","uri":"/posts/docker/docker01/"},{"categories":["docker"],"content":"镜像命令 docker images [-a] [-p] # -a 列出本地所有的镜像（含历史映像层） -p 只显示镜像ID docker search [--limit n] \u003c镜像名\u003e # 只列出n个，默认25个 docker pull \u003c镜像名字\u003e [:TAG] # 没有tag就是最新版 docker system df # 查看镜像/容器/数据卷/所占的空间 docker rmi -f \u003c镜像ID\u003e docker rmi -f \u003c镜像名1\u003e:TAG \u003c镜像名2\u003e:TAG docker rmi -f $(docker images -qa) ","date":"2023-05-27","objectID":"/posts/docker/docker01/:8:2","tags":["docker"],"title":"Docker介绍","uri":"/posts/docker/docker01/"},{"categories":["docker"],"content":"容器命令 docker run [OPTIONS] \u003c镜像名\u003e [COMMAND][ARG...] docker ps [-a][-l][-n][-q] # -a 正在+历史；-l 最近；-n 最近n个；-q只显示容器编号 exit # run进去容器，exit退出，容器停止 ctrl+p+q # run进去容器，ctrl+p+q退出，容器不停止 docker start \u003c容器ID\u003e或\u003c容器名\u003e docker restart \u003c容器ID\u003e或\u003c容器名\u003e docker stop \u003c容器ID\u003e或\u003c容器名\u003e docker kill \u003c容器ID\u003e或\u003c容器名\u003e docker rm \u003c容器ID\u003e docker rm -f $(docker ps -a -q) docker ps -a -q | xargs docker rm ","date":"2023-05-27","objectID":"/posts/docker/docker01/:8:3","tags":["docker"],"title":"Docker介绍","uri":"/posts/docker/docker01/"},{"categories":["docker"],"content":"Docker平台架构图解 整体说明 从其架构和运行流程来看，Docker是一个C/S模式的架构，后端是一个松耦合架构，众多模块各司其职。 Docker运行的基本流程为： 用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。 Docker Daemon作为Docker架构中的主体部分，首先提供Docker Server的功能使其可以接受Docker Client的请求。 Docker Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。 Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动Graph driver将下载镜像以Graph的形式存储。 当需要为Docker创建网络环境时，通过网络管理驱动Network driver创建并配置Docker容器网络环境。 当需要限制Docker容器运行资源或执行用户指令等操作时，则通过Execdriver 来完成。 Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。 整体架构 ","date":"2023-05-24","objectID":"/posts/docker/docker06/:1:0","tags":["docker"],"title":"Docker网络","uri":"/posts/docker/docker06/"},{"categories":["docker"],"content":"Docker网络是什么 docker不启动时，默认网络情况。 docker启动后，网络情况。 docker启动后，发现会产生一个名为docker0的虚拟网桥。 inet 172.17.0.1 ：通过docker0这个虚拟网桥和宿主机通信，同时保证容器与容器之间的通信。 docker network ls会发现，docker启动后会默认创建3大网络模式，我们常用的是bridge模式，偶尔会用到host模式。 ","date":"2023-05-24","objectID":"/posts/docker/docker06/:2:0","tags":["docker"],"title":"Docker网络","uri":"/posts/docker/docker06/"},{"categories":["docker"],"content":"Docker网络常用基本命令 docker network --help查看docker网络常用命令。 docker network connect # 连接 docker network create # 创建 docker network disconnect # 中断 docker network inspect # 查看 docker network ls # list docker network prune # 删除所有无效网络 docker network rm # remove ","date":"2023-05-24","objectID":"/posts/docker/docker06/:3:0","tags":["docker"],"title":"Docker网络","uri":"/posts/docker/docker06/"},{"categories":["docker"],"content":"Docker网络能干嘛 所有网络的访问前提是网络需要处于同一网段。我们现在使用单机版的docker实例，感受的不明显，但是如果我们在工作中，是要做docker的网路管理和容器调用之间的规划的。 Docker网络与容器间的互联和通信以及端口映射有关。 同时，容器IP变动时可以通过服务名直接网络通信而不受到影响。 ","date":"2023-05-24","objectID":"/posts/docker/docker06/:4:0","tags":["docker"],"title":"Docker网络","uri":"/posts/docker/docker06/"},{"categories":["docker"],"content":"Docker网络模式 ","date":"2023-05-24","objectID":"/posts/docker/docker06/:5:0","tags":["docker"],"title":"Docker网络","uri":"/posts/docker/docker06/"},{"categories":["docker"],"content":"总体介绍 网络模式 简介 指令 bridge 为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，默认为该模式。 --network bridge，默认使用docker0 host 容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。 --network host none 容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair和网桥连接、IP等。 --network none container 新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP，端口范围等。 --network container:NAME或者容器ID指定 ","date":"2023-05-24","objectID":"/posts/docker/docker06/:5:1","tags":["docker"],"title":"Docker网络","uri":"/posts/docker/docker06/"},{"categories":["docker"],"content":"容器实例内默认网络IP生成规则 说明 结论 docker容器内部的ip是有可能会发生改变的。比如上面的情况中，原来172.17.0.3是属于u2的，后来u2挂了，该ip归新启动的u3所有了，如果我们其他的服务是按照ip互相连接的，就会出现错误。 ","date":"2023-05-24","objectID":"/posts/docker/docker06/:5:2","tags":["docker"],"title":"Docker网络","uri":"/posts/docker/docker06/"},{"categories":["docker"],"content":"案例说明 bridge 是什么 Docker服务默认会创建一个docker0网桥（其上有一个docker0内部接口），该桥接网络的名称为docker0，它在内核层联通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。Docker默认指定了docker0接口的IP地址和子网掩码，让主机和容器之间可以通过网桥相互通信。 查看bridge网络的详细信息，并通过grep获取名称项。 docker network inspect bridge | grep name ifconfig | grep docker 案例 说明 Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥（docker0），Docker启动一个容器时会根据Docker网桥的桥段分配给容器一个IP地址，成为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能通过容器的Container-IP直接通信。 docker run的时候，没有指定network的话默认使用的网络模式是bridge，使用的就是docker0。在宿主机ifconfig，就可以看到docker0和自己create的network，eth0，eth1，eth2……，lo代表127.0.0.1，即localhost，inet addr用来表示网卡的IP地址。 网桥docker0创建一对 对等的虚拟设备接口一个叫veth，另一个叫eth0，成对匹配。 整个宿主机的网桥模式都是docker0，类似一个交换机有一堆接口，每个接口叫veth，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫veth pair） 每个容器实例内部也有一块网卡，每个接口叫eth0。 docker0上面的每个veth匹配某个容器实例内部的eth0，两两配对，一一匹配。 通过上述，将宿主机上的所有容器都连接到这个网络内部上，两个容器在同一个网络下，会从这个网关下各自拿到分配的ip，此时两个容器的网络是互通的。 代码 docker run -d -p 8081:8080 --name tomcat81 billygoo/tomcat8-jdk8 docker run -d -p 8082:8080 --name tomcat81 billygoo/tomcat8-jdk8 两两匹配验证 host 是什么 直接使用宿主机的ip地址与外界进行通信，不再需要额外进行NAT转换。 案例 容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口。 docker run -d -p 8083:8080 --network host --name tomcat83 billygoo/tomcat8-jdk8 WARNING：Published ports are discarded when using host network mode 这样启动会遇到警告，原因是docker启动时指定--network=host或-net=host，如果还指定了-p映射端口，那这个时候就会有此警告，并且通过-p设置的参数将不会起到任何作用，端口号会以主机端口号为主，重复时则递增。解决方法就是使用docker的其他网络模式，例如bridge或者直接无视。 正确的写法应该是docker run -d --network host --name tomcat83 billygoo/tomcat8-jdk8 none 禁用网络功能，只有lo（localhost）。在none模式下，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息，只有一个lo，需要我们自己为Docker容器添加网卡、配置IP等。 docker run -d -p 8084:8080 --network none --name tomcat84 billigoo/tomcat8-jdk8 container 新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。 错误案例 docker run -d -p 8085:8080 --name tomcat85 billygoo/tomcat8-jdk8 docker run -d -p 8086:8080 --network container:tomcat85 --name tomcat85 billygoo/tomcat8-jdk8 正确案例 自定义网络 使用自定义网络之前 案例： docker run -d -p 8081:8080 --name tomcat81 billygoo/tomcat8-jdk8 docker run -d -p 8082:8080 --name tomcat82 billygoo/tomcat8-jdk8 上述成功启动并用docker exec进入各自容器实例内部 使用自定义网络之后 案例： 自定义桥接网络，自定义网络默认使用的是桥接网络bridge。 新建自定义网络。 docker network create nzR_network 新建容器加入上一步新建的自定义网络。 docker run -d -p 8081:8080 --network nzR_neetwork --name tomcat81 billygoo/tomcat8-jdk8 docker run -d -p 8082:8080 --network nzR_neetwork --name tomcat81 billygoo/tomcat8-jdk8 互相ping测试 此时在tomcat81下ping tomcat82或在tomcat82下ping tomcat81均可成功。 ","date":"2023-05-24","objectID":"/posts/docker/docker06/:5:3","tags":["docker"],"title":"Docker网络","uri":"/posts/docker/docker06/"},{"categories":["WSL"],"content":"WSL启动Ubuntu时报错“参考的对象类型不支持尝试的操作” 用root权限打开powershell，输入netsh winsock reset ","date":"2023-05-23","objectID":"/posts/wsl/:1:0","tags":["WSL"],"title":"WSL","uri":"/posts/wsl/"},{"categories":["docker"],"content":"没学过spring boot、spring cloud。以后用go写个微服务再更新。 ","date":"2023-05-23","objectID":"/posts/docker/docker05/:0:0","tags":["docker","微服务"],"title":"Docker微服务实战","uri":"/posts/docker/docker05/"},{"categories":["docker"],"content":"通过IDEA新建一个普通微服务模块 ","date":"2023-05-23","objectID":"/posts/docker/docker05/:1:0","tags":["docker","微服务"],"title":"Docker微服务实战","uri":"/posts/docker/docker05/"},{"categories":["docker"],"content":"通过dockerfile发布微服务部署到docker容器","date":"2023-05-23","objectID":"/posts/docker/docker05/:2:0","tags":["docker","微服务"],"title":"Docker微服务实战","uri":"/posts/docker/docker05/"},{"categories":["Git"],"content":"Git基础指令 ","date":"2023-05-22","objectID":"/posts/git/git/:1:0","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"安装git git -v # 查看版本 git config --global user.name \"Lizhe1228\" # 基本配置 git config --global user.email \"2181426542@qq.com\" ","date":"2023-05-22","objectID":"/posts/git/git/:1:1","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"创建版本库 版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以还原。注意，目前这里说的版本库都是本地仓库。 # 初始化本地仓库 git init # 添加文件到仓库 # 添加单个文件 git add \u003cfile\u003e # 添加多个文件 git add file1 file2 ... # 添加全部已修改文件 git add . # 提交文件到仓库 git commit -m \"说明\" ","date":"2023-05-22","objectID":"/posts/git/git/:1:2","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"版本回退 # git工作区状态 git status # 查看全部修改内容 git diff # 查看指定文件修改内容 git diff \u003cfile\u003e # 回退到指定版本 git reset --hard commit_id # 这里的commit_id 通过git log查看 # 回退到上一个版本 git reset --hard HEAD^ # 回退到上上一个版本 git reset --hard HEAD^^ # 回退到上n个版本 git reset --hard HEAD~n # 看详细提交历史 git log # 查看简化提交历史 git log --pretty=oneline # 查看分支合并图 git log --graph # 查看命令历史 git reflog ","date":"2023-05-22","objectID":"/posts/git/git/:1:3","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"工作区和暂存区 结论 工作区Working Directory 就是你在电脑里能看到的目录，在创建版本库时新建的那个目录 版本库Repository 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区 说明 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 ","date":"2023-05-22","objectID":"/posts/git/git/:1:4","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"管理修改 结论 Git跟踪并管理的是修改，而非文件 Git只能追踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。 图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 说明 需要注意的是，如果你按照下述方式提交： 第一次修改-\u003eadd-\u003e第二次修改-\u003ecommit 那么，第二次修改的内容不会被提交 按照下述方式提交，则两次修改都会被提交 第一次修改-\u003eadd-\u003e第二次修改-\u003eadd-\u003ecommit 所以，没有add的内容，即使commit之后也不会被提交 ","date":"2023-05-22","objectID":"/posts/git/git/:1:5","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"撤销修改 丢弃工作区的修改（未提交至暂存区，也就是未add） # 丢弃指定文件的修改 git checkout -- file git restore \u003cfile\u003e # 丢弃所有文件的修改 git checkout -- . git restore . 丢弃已添加到暂存区的修改 # 丢弃指定文件的修改 git reset HEAD \u003cfile\u003e git restore --staged \u003cfile\u003e # 丢弃所有文件的修改 git reset HEAD . git restore --staged . ","date":"2023-05-22","objectID":"/posts/git/git/:1:6","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"删除文件？？？ # 删除未添加到暂存区的文件 # 显示将要删除的文件和目录 git clean -n # 删除文件和目录 git clean -df # 删除文件 git clean -f git rm \u003cfile\u003e ","date":"2023-05-22","objectID":"/posts/git/git/:1:7","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"远程仓库 ","date":"2023-05-22","objectID":"/posts/git/git/:2:0","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"添加远程仓库 # 关联远程仓库 # 其中origin是默认的远程仓库名，也可以自行修改 # url可以是ssh链接，也可以是http链接，推荐使用ssh，安全高速 git remote add origin \u003curl\u003e # 删除远程仓库 git remote rm origin # 查看远程仓库 git remote -v # 推送提交到远程仓库 一般用于非首次推送 git push origin master git push -f origin master # -f是强制推送 好用慎用 # -u参数是将本地master分支与远程仓库master分支关联起来，一般用于第一次推送代码到远程库 git push -u origin master ","date":"2023-05-22","objectID":"/posts/git/git/:2:1","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"从远程仓库克隆 之前讲的内容都是先有本地库，后有远程库，然后再关联远程库。 而一般大多数情形都是先有远程库，然后克隆远程库到本地，再进行工作。 # url可以是ssh或http，建议使用原生ssh链接，高速安全 git clone url ","date":"2023-05-22","objectID":"/posts/git/git/:2:2","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"分支管理 ","date":"2023-05-22","objectID":"/posts/git/git/:3:0","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"创建与合并分支 # 查看分支 git branch # 创建分支 git branch \u003cname\u003e # 切换分支 switch是2.23版本新增命令 git checkout \u003cname\u003e git switch \u003cname\u003e # 创建并切换到该分支 git checkout -b \u003cname\u003e git switch -c \u003cname\u003e # 合并指定分支到当前分支 git merge \u003cname\u003e # 删除本地已合并分支 ??? git branch -d \u003cname\u003e # 删除远程分支 git push \u003c远程仓库名\u003e --delete \u003c远程分支名\u003e # 推送本地分支到远程仓库并在远程仓库创建新分支 git push \u003c远程仓库名\u003e \u003c本地分支名\u003e:\u003c远程分支名\u003e ","date":"2023-05-22","objectID":"/posts/git/git/:3:1","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"解决冲突 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 查看分支合并图： git log --graph 冲突的产生一般都是这两种情况： 远程仓库的代码落后于本地仓库 远程仓库的代码远超本地仓库 在你还未提交代码的时候，你的同事已经提交了代码，就会导致远程仓库代码领先于你的代码 冲突是如何表示的 当产生合并冲突时，该部分会以\u003c\u003c\u003c\u003c\u003c\u003c\u003c, =======和 \u003e\u003e\u003e\u003e\u003e\u003e\u003e表示。在=======之前的部分是当前分支这边的情况，在=======之后的部分是传入分支的情况。 如何解决冲突 ？？？ 在看到冲突以后，你可以选择以下两种方式： 决定不合并。这时，唯一要做的就是重置index到HEAD节点。git merge --abort用于这种情况。 解决冲突。Git会标记冲突的地方，解决完冲突的地方后使用git add加入到index中，然后使用git commit产生合并节点。 你可以用以下工具来解决冲突: 使用合并工具。git mergetool将会调用一个可视化的合并工具来处理冲突合并。 查看差异。git diff将会显示三路差异（三路合并中所采用的三路比较算法）。 查看每个分支的差异。git log --merge -p \u003cpath\u003e将会显示HEAD版本和MERGE_HEAD版本的差异。 查看合并前的版本。git show :1:文件名显示共同祖先的版本，git show :2:文件名显示当前分支的HEAD版本，git show :3:文件名显示对方分支的MERGE_HEAD版本。 ","date":"2023-05-22","objectID":"/posts/git/git/:3:2","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"分支管理策略 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： ","date":"2023-05-22","objectID":"/posts/git/git/:3:3","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"Bug分支 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场； 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick \u003ccommit_id\u003e命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 # 暂存工作区状态 git stash # 查看暂存的工作区状态 git stash list # 恢复全部暂存状态，但不删除暂存内容 git stash apply # 恢复指定暂存状态，但不删除暂存内容 git stash apply stash@{\u003cid\u003e} # 删除暂存内容 git stash drop # 恢复暂存状态，同时删除暂存内容 git stash pop # 复制一个特定的提交到当前分支 git cherry-pick \u003ccommit_id\u003e ","date":"2023-05-22","objectID":"/posts/git/git/:3:4","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"Feature分支 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D \u003cname\u003e强行删除。 强制删除分支（会丢失分支上的修改） git branch -D \u003cname\u003e ","date":"2023-05-22","objectID":"/posts/git/git/:3:5","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"多人协作 多人协作的工作模式通常是这样： 首先，可以试图用git push origin \u003cbranch-name\u003e推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin \u003cbranch-name\u003e推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 本地新建的分支如果不推送到远程，对其他人就是不可见的； 在本地创建和远程分支对应的分支，本地和远程分支的名称最好一致； 从远程抓取分支，如果有冲突，要先处理冲突。 查看远程仓库信息 git remote 查看远程仓库详细信息 git remote -v 与远程仓库代码同步 git pull # git pull = git fetch + git merge 在本地创建和远程分支对应的分支 git checkout -b branch-name origin/branch-name git switch -c branch-name origin/branch-name 将本地分支与远程仓库关联 git branch --set-upstream-to \u003cbranch-name\u003e origin/\u003cbranch-name\u003e 推送本地分支到远程仓库 git push origin \u003cbranch-name\u003e ","date":"2023-05-22","objectID":"/posts/git/git/:3:6","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"标签管理 ","date":"2023-05-22","objectID":"/posts/git/git/:4:0","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"创建标签 # 新建标签（指向最新的commit_id） git tag \u003ctag_name\u003e # 新建标签（指向特定commit_id） git tag \u003ctag_name\u003e \u003ccommit_id\u003e # 查看所有标签 git tag # 显示某个标签的详细信息 git show \u003ctag_name\u003e # 新建带有说明的标签 git tag -a \u003ctag_name\u003e -m \"说明\" \u003ccommit_id\u003e ","date":"2023-05-22","objectID":"/posts/git/git/:4:1","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Git"],"content":"操作标签 # 删除指定本地标签 git tag -d \u003ctag_name\u003e # 删除指定远程标签 git push origin :refs/tags/\u003ctag_name\u003e # 推送一个本地标签 git push origin \u003ctag_name\u003e # 推送全部未推送过的本地标签 git push origin --tags ","date":"2023-05-22","objectID":"/posts/git/git/:4:2","tags":["Git"],"title":"Git的基本使用","uri":"/posts/git/git/"},{"categories":["Go每日一练"],"content":"题目来源于 https://www.topgoer.cn/docs/gomianshiti/mianshiti","date":"2023-05-22","objectID":"/posts/go/day1-10/","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"题目来源于 https://www.topgoer.cn/docs/gomianshiti/mianshiti ","date":"2023-05-22","objectID":"/posts/go/day1-10/:0:0","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"Day1 下面这段代码输出的内容是什么? package main import ( \"fmt\" ) func main() { defer_call() } func defer_call() { defer func() { fmt.Println(\"打印前\") }() defer func() { fmt.Println(\"打印中\") }() defer func() { fmt.Println(\"打印后\") }() panic(\"触发异常\") } 答案： 打印后 打印中 打印前 panic: 触发异常 解析： defer 的执行顺序是后进先出。当出现 panic 语句的时候，会先按照 defer 的后进先出的顺序执行，最后才会执行panic。 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:1:0","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"Day2 下面这段代码输出什么，说明原因。 func main() { slice := []int{0,1,2,3} m := make(map[int]*int) for key,val := range slice { m[key] = \u0026val } for k,v := range m { fmt.Println(k,\"-\u003e\",*v) } } 答案： 0 -\u003e 3 1 -\u003e 3 2 -\u003e 3 3 -\u003e 3 解析： 这是新手常会犯的错误写法，for range 循环的时候会创建每个元素的副本，而不是元素的引用，所以 m[key] = \u0026val 取的都是变量 val 的地址，所以最后 map 中的所有元素的值都是变量 val 的地址，因为最后 val 被赋值为3，所有输出都是3. 正确写法： func main() { slice := []int{0,1,2,3} m := make(map[int]*int) for key,val := range slice { // 创建一个临时变量value，每次range的时候这里都是一个新的 value := val m[key] = \u0026value } for k,v := range m { fmt.Println(k,\"===\u003e\",*v) } } ","date":"2023-05-22","objectID":"/posts/go/day1-10/:2:0","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"Day3 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:3:0","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"1.下面两段代码输出什么？ // 1. func main() { s := make([]int, 5) s = append(s, 1, 2, 3) fmt.Println(s) } // 2. func main() { s := make([]int,0) s = append(s,1,2,3,4) fmt.Println(s) } 1 : 0 0 0 0 0 1 2 3 2 ：1 2 3 4 解析：这道题考的是使用 append 向 slice 添加元素，第一段代码常见的错误是 [1 2 3]，需要注意。 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:3:1","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"2.下面这段代码有什么缺陷? func funcMui(x,y int)(sum int,error) { return x+y,nil } 缺陷：第二个返回值没有命名。 解析：在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。如果有多个返回值必须加上括号()；如果只有一个返回值且命名也必须加上括号()。这里的第一个返回值有命名 sum，第二个没有命名，所以错误。 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:3:2","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"3.new()与make()的区别？ new(T) 和 make(T,args) 是 Go 语言内建函数，用来分配内存，但适用的类型不同。 new(T) 会为 T 类型的新值分配已置零的内存空间，并返回地址（指针），即类型为 *T的值。换句话说就是，返回一个指针，该指针指向新分配的、类型为 T 的零值。适用于值类型，如数组、结构体等；new可被替代，能够通过字面值快速初始化。 make(T,args) 分配并初始化，返回初始化之后的 T 类型的引用，而并不是 T 类型的零值，也不是指针 *T；make() 只适用于 slice、map 和 channel；make函数会对三种类型的内部数据结构（长度、容量等）赋值。 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:3:3","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"一些延伸 引用（reference）是指可以让程序间接访问其它值的值。指针是引用的一种，是一类简单的透明引用，区别于不透明的引用。（还没有弄懂） C++ 既有指针也有引用。C++ 的引用更接近别名（alias），是受限的指针（不能读取或修改地址值，也不需要显式的解引用，所有操作都作用于指向的值）。 Go 的引用，则是在已经有了 直接值 和 指针 的前提下，针对特定类型的优化：为了兼顾易用性和性能，针对具体类型，在 值 和 指针 之间折中。每种引用类型，有自己独特的机制。一般是由一个结构体负责管理元数据，结构体里有一个指针，指向真正要使用的目标数据。 Go 的引用类型有： 字符串 string：底层的数据结构为 stringStruct ，里面有一个指针指向实际存放数据的字节数组，另外还记录着字符串的长度。不过由于 string 是只读类型（所有看起来对 string 变量的修改，实际上都是生成了新的实例），在使用上常常把它当做值类型看待。由于做了特殊处理，它甚至可以作为常量。string 也是唯一零值不为 nil 的引用类型。 切片（slice）：底层数据结构为 slice 结构体 ，整体结构跟 stringStruct 接近，只是多了一个容量（capacity）字段。数据存放在指针指向的底层数组里。 映射（map）：底层数据结构为 hmap ，数据存放在数据桶（buckets）中，桶对应的数据结构为 bmap 。 函数（func）：底层数据结构为 funcval ，有一个指向真正函数的指针，指向另外的 _func 或者 funcinl 结构体（funcinl 代表被行内优化之后的函数）。 接口（interface）：底层数据结构为 iface 或 eface （专门为空接口优化的结构体），里面持有动态值和值对应的真实类型。 通道（chan）：底层数据结构为 hchan，分别持有一个数据缓冲区，一个发送者队列和一个接收者队列。 如果觉得不好记忆，有一个识别引用类型的快捷办法：凡是零值是 nil 的，都是引用类型。指针作为特殊的透明引用，一般单独讨论。而 字符串 string 因为做了特殊处理，零值为 \"\" ，需要额外记住。除了引用类型和指针，剩下的类型都是直接值类型。 那些说引用类型只有需要 make() 的切片、映射、通道 三种的说法，是错误的！ ","date":"2023-05-22","objectID":"/posts/go/day1-10/:3:4","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"Day4 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:4:0","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"1.下面这段代码能否通过编译，不能的话原因是什么；如果能，输出什么? func main() { list := new([]int) list = append(list, 1) fmt.Println(list) } 参考答案及解析：不能通过编译，new([]int) 之后的 list 是一个 *[]int 类型的指针，不能对指针执行 append 操作。可以使用 make() 初始化之后再用。同样的，map 和 channel 建议使用 make() 或字面量的方式初始化，不要用 new() 。 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:4:1","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"2.下面这段代码能否通过编译，如果可以，输出什么？ func main() { s1 := []int{1, 2, 3} s2 := []int{4, 5} s1 = append(s1, s2) fmt.Println(s1) } 参考答案及解析：不能通过编译。append() 的第二个参数不能直接使用 slice，需使用 … 操作符，将一个切片追加到另一个切片上：append(s1,s2…)。或者直接跟上元素，形如：append(s1,1,2,3)。 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:4:2","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"3.下面这段代码能否通过编译，如果可以，输出什么？ var( size := 1024 max_size = size*2 ) func main() { fmt.Println(size, max_size) } 参考答案及解析：不能通过编译。这道题的主要知识点是变量声明的简短模式，形如：x := 100。但这种声明方式有限制： 必须使用显示初始化； 不能提供数据类型，编译器会自动推导； 只能在函数内部使用简短模式； ","date":"2023-05-22","objectID":"/posts/go/day1-10/:4:3","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"Day5 下面这段代码能否通过编译？不能的话，原因是什么？如果通过，输出什么？ func main() { sn1 := struct { age int name string }{age: 11, name: \"qq\"} sn2 := struct { age int name string }{age: 11, name: \"qq\"} if sn1 == sn2 { fmt.Println(\"sn1 == sn2\") } sm1 := struct { age int m map[string]string }{age: 11, m: map[string]string{\"a\": \"1\"}} sm2 := struct { age int m map[string]string }{age: 11, m: map[string]string{\"a\": \"1\"}} if sm1 == sm2 { fmt.Println(\"sm1 == sm2\") } } 参考答案及解析：编译不通过 invalid operation: sm1 == sm2 这道题目考的是结构体的比较，有几个需要注意的地方： 结构体只能比较是否相等，但是不能比较大小。 相同类型的结构体才能够进行比较，结构体是否相同不但与属性类型有关，还与属性顺序相关，sn3 与 sn1 就是不同的结构体； sn3:= struct { name string age int }{age:11,name:\"qq\"} 如果 struct 的所有成员都可以比较，则该 struct 就可以通过 == 或 != 进行比较是否相等，比较时逐个项进行比较，如果每一项都相等，则两个结构体才相等，否则不相等； 那什么是可比较的呢，常见的有 bool、数值型、字符、指针、数组等，像切片、map、函数等是不能比较的。 具体可以参考 Go 说明文档。https://golang.org/ref/spec#Comparison_operators ","date":"2023-05-22","objectID":"/posts/go/day1-10/:5:0","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"Day6 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:6:0","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"1.通过指针变量 p 访问其成员变量 name，以下哪项正确？ A.p.name B.(\u0026p).name C.(*p).name D.p-\u003ename 参考答案及解析：AC。\u0026 取址运算符，* 指针解引用。 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:6:1","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"2.下面这段代码能否通过编译？如果通过，输出什么？ package main import \"fmt\" type MyInt1 int type MyInt2 = int func main() { var i int =0 var i1 MyInt1 = i var i2 MyInt2 = i fmt.Println(i1,i2) } 参考答案及解析：编译不通过，cannot use i (type int) as type MyInt1 in assignment。 这道题考的是类型别名与类型定义的区别。 第 5 行代码type MyInt1 int是基于类型 int 创建了新类型 MyInt1，第 6 行代码type MyInt2 = int是创建了 int 的类型别名 MyInt2，注意类型别名的定义时使用 = 。所以，第 10 行代码相当于是将 int 类型的变量赋值给 MyInt1 类型的变量，Go 是强类型语言，编译当然不通过；而 MyInt2 只是 int 的别名，本质上还是 int，可以赋值。 第 10 行代码的赋值可以使用强制类型转化 var i1 MyInt1 = MyInt1(i) ","date":"2023-05-22","objectID":"/posts/go/day1-10/:6:2","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"Day7 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:7:0","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"1.关于字符串的连接，下面语法正确的是? A. str := ‘abc’ + ‘123’ B. str := “abc” + “123” C. str := ‘123’ + “abc” D. fmt.Sprintf(“abc%d”, 123) 参考答案及解析：B.str := “abc” + “123”，D. fmt.Sprintf(“abc%d”, 123)。知识点：字符串连接。除了以上两种连接方式，还有 strings.Join()、buffer.WriteString()等。 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:7:1","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"2.下面这段代码能否编译通过？如果可以，输出什么？ const ( x = iota _ y z = \"zz\" k p = iota ) func main() { fmt.Println(x,y,z,k,p) } 参考答案及解析：编译通过，输出：0 2 zz zz 5。知识点：iota 的使用。 iota是golang语言的常量计数器,只能在常量的表达式中使用。 iota在const关键字出现时将被重置为0(const内部的第一行之前)，const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。 iota只能在常量的表达式中使用。 fmt.Println(iota)编译错误： undefined: iota 每次 const 出现时，都会让 iota 初始化为0.【自增长】 const a = iota // a=0 const ( b = iota //b=0 c //c=1 )**自定义类型** 自增长常量经常包含一个自定义枚举类型，允许你依靠编译器完成自增设置。 type Stereotype int const ( TypicalNoob Stereotype = iota // 0 TypicalHipster // 1 TypicalUnixWizard // 2 TypicalStartupFounder // 3 ) ​ 下面是来自time包的例子，它首先定义了一个Weekday命名类型，然后为 一周的每天定义了一个常量，从周日0开始，在其它编程语言中，这种类型一 般被称为枚举类型。 type Weekday int const ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday ) ​ 周一将对应0，周一为1，如此等等。 可跳过的值 我们可以使用下划线跳过不想要的值。 type AudioOutput int const ( OutMute AudioOutput = iota // 0 OutMono // 1 OutStereo // 2 _ _ OutSurround // 5 ) 位掩码表达式 iota 可以做更多事情，而不仅仅是 increment。更精确地说，iota 总是用于 increment，但是它可以用于表达式，在常量中的存储结果值。 type Allergen int const ( IgEggs Allergen = 1 \u003c\u003c iota // 1 \u003c\u003c 0 which is 00000001 IgChocolate // 1 \u003c\u003c 1 which is 00000010 IgNuts // 1 \u003c\u003c 2 which is 00000100 IgStrawberries // 1 \u003c\u003c 3 which is 00001000 IgShellfish // 1 \u003c\u003c 4 which is 00010000 ) 这个工作是因为当你在一个 const 组中仅仅有一个标示符在一行的时候，它将使用增长的 iota 取得前面的表达式并且再运用它，。在 Go 语言的 spec 中， 这就是所谓的隐性重复最后一个非空的表达式列表。 如果你对鸡蛋，巧克力和海鲜过敏，把这些 bits 翻转到 “on” 的位置（从左到右映射 bits）。然后你将得到一个 bit 值 00010011，它对应十进制的 19。 fmt.Println(IgEggs | IgChocolate | IgShellfish) // output // 19 我们也可以在复杂的常量表达式中使用iota，下面是来自net包的例子，用于给一个无符号整数的最低5bit的每个bit指定一个名字： type Flags uint const ( FlagUp Flags = 1 \u003c\u003c iota // is up FlagBroadcast // supports broadcast access capability FlagLoopback // is a loopback interface FlagPointToPoint // belongs to a point-to-point link FlagMulticast // supports multicast access capability ) 随着iota的递增，每个常量对应表达式1 « iota，是连续的2的幂，分别对应一个bit位置。使用这些常量可以用于测试、设置或清除对应的bit位的值： 测试结果： package main import ( \"fmt\" ) type Flags uint const ( FlagUp Flags = 1 \u003c\u003c iota // is up FlagBroadcast // supports broadcast access capability FlagLoopback // is a loopback interface FlagPointToPoint // belongs to a point-to-point link FlagMulticast // supports multicast access capability ) func IsUp(v Flags) bool { return v\u0026FlagUp == FlagUp } func TurnDown(v *Flags) { *v \u0026^= FlagUp } func SetBroadcast(v *Flags) { *v |= FlagBroadcast } func IsCast(v Flags) bool { return v\u0026(FlagBroadcast|FlagMulticast) != 0 } func main() { var v Flags = FlagMulticast | FlagUp fmt.Printf(\"%b %t\\n\", v, IsUp(v)) // \"10001 true\" TurnDown(\u0026v) fmt.Printf(\"%b %t\\n\", v, IsUp(v)) // \"10000 false\" SetBroadcast(\u0026v) fmt.Printf(\"%b %t\\n\", v, IsUp(v)) // \"10010 false\" fmt.Printf(\"%b %t\\n\", v, IsCast(v)) // \"10010 true\" } // 运行结果 10001 true 10000 false 10010 false 10010 true 定义数量级 type ByteSize float64 const ( _ = iota // ignore first value by assigning to blank identifier KB ByteSize = 1 \u003c\u003c (10 * iota) // 1 \u003c\u003c (10*1) MB // 1 \u003c\u003c (10*2) GB // 1 \u003c\u003c (10*3) TB // 1 \u003c\u003c (10*4) PB // 1 \u003c\u003c (10*5) EB // 1 \u003c\u003c (10*6) ZB // 1 \u003c\u003c (10*7) YB // 1 \u003c\u003c (10*8) ) 下面是一个更复杂的例子，每个常量都是1024的幂（还没懂）： const ( _ = 1 \u003c\u003c (10 * iota) KiB // 1024 MiB // 1048576 GiB // 1073741824 TiB // 1099511627776 (exceeds 1 \u003c\u003c 32) PiB // 1125899906842624 EiB // 1152921504606846976 ZiB // 1180591620717411303424 (exceeds 1 \u003c\u003c 64) YiB // 1208925819614629174706176 ) 不过iota常量生成规则也有其局限性。例如，它并不能用于产生1000的幂（KB、MB等），因为Go语言并没有计算幂的运算符。 定义在一行的情况 const ( Apple, Banana = iota + 1, iota + 2 Cherimoya, Durian Elderberry, Fig ) // iota 在下一行增长，而不是立即取得它的引用。(没懂) // Apple: 1 // Banana: 2 // Cherimoya: 2 // Durian: 3 // Elderberry: 3 // Fig: 4 中间插队 const ( i = iota j = 3.14 k = iota l ) // i=0,j=3.14,k=2,l=3 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:7:2","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"3.下面赋值正确的是? A. var x = nil B. var x interface{} = nil C. var x string = nil D. var x error = nil 参考答案及解析：BD。知识点：nil 值。nil 只能赋值给指针、chan、func、interface、map 或 slice 类型的变量。强调下 D 选项的 error 类型，它是一种内置接口类型，看下方贴出的源码就知道，所以 D 是对的。 type error interface { Error() string } ","date":"2023-05-22","objectID":"/posts/go/day1-10/:7:3","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"Day8 1.关于init函数，下面说法正确的是？ A. 一个包中，可以包含多个 init 函数； B. 程序编译时，先执行依赖包的 init 函数，再执行 main 包内的 init 函数； C. main 包中，不能有 init 函数； D. init 函数可以被其他函数调用； 参考答案及解析：AB。关于 init() 函数有几个需要注意的地方： init() 函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等; 一个包可以出现多个 init() 函数，一个源文件也可以包含多个 init() 函数； 同一个包中多个 init() 函数的执行顺序没有明确定义，但是不同包的init函数是根据包导入的依赖关系决定的（看下图）; init() 函数在代码中不能被显示调用、不能被引用（赋值给函数变量），否则出现编译错误; 一个包被引用多次，如 A import B,C import B,A import C，B 被引用多次，但 B 包只会初始化一次； 引入包，不可出现死循坏。即 A import B,B import A，这种情况编译失败； 2.下面这段代码输出什么以及原因？ func hello() []string { return nil } func main() { h := hello if h == nil { fmt.Println(\"nil\") } else { fmt.Println(\"not nil\") } } A. nil B. not nil C. compilation error 答案及解析：B。这道题目里面，是将 hello() （应该是hello吧）赋值给变量 h，而不是函数的返回值，所以输出 not nil。没懂，敲代码看一看 3.下面这段代码能否编译通过？如果可以，输出什么？ func GetValue() int { return 1 } func main() { i := GetValue() switch i.(type) { case int: println(\"int\") case string: println(\"string\") case interface{}: println(\"interface\") default: println(\"unknown\") } } 参考答案及解析：编译失败。考点：类型选择，类型选择的语法形如：i.(type)，其中 i 是接口，type 是固定关键字，需要注意的是，只有接口类型才可以使用类型选择。看下关于接口的文章。 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:8:0","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"Day9 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:9:0","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"1.关于channel，下面语法正确的是？ A. var ch chan int B. ch := make(chan int) C. \u003c- ch D. ch \u003c- 参考答案及解析：ABC。A、B都是声明 channel；C 读取 channel；写 channel 是必须带上值，所以 D 错误。 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:9:1","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"2.下面这段代码输出什么？ type person struct { name string } func main() { var m map[person]int p := person{\"mike\"} fmt.Println(m[p]) } A.0 B.1 C.Compilation error 参考答案及解析：A。打印一个 map 中不存在的值时，返回元素类型的零值。这个例子中，m 的类型是 map[person]int，因为 m 中不存在 p，所以打印 int 类型的零值，即 0。 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:9:2","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"3.下面这段代码输出什么？ func hello(num ...int) { num[0] = 18 } func main() { i := []int{5, 6, 7} hello(i...) fmt.Println(i[0]) } A.18 B.5 C.Compilation error 参考答案及解析：18。知识点：可变参数。 形如...type格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数，它是一个语法糖（syntactic sugar），即这种语法对语言的功能并没有影响，但是更方便程序员使用，通常来说，使用语法糖能够增加程序的可读性，从而减少程序出错的可能。 从内部实现机理上来说，类型...type本质上是一个数组切片，也就是[]type。 做这道题时思考的一个问题，为什么看起来切片作为参数传进去的时候不是值传递呢？正如下面的情况，当我们要修改一个数的值的时候，需要传入指针，而修改切片的时候直接将切片作为参数就可以直接对切片进行修改。 package main import \"fmt\" func main() { i := []int{1, 2, 3} changeSlice(i) fmt.Println(i[0]) num := 1 changeInt(\u0026num) fmt.Println(num) } func changeSlice(num []int) { num[0] = 18 } func changeInt(a *int) { *a = 250 } // 输出 18 250 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:9:3","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"延伸 切片作为函数参数是传值还是传引用？ 学习链接：https://juejin.cn/post/6888117219213967368 切片传参的幻觉 - 传引用 golang中函数的参数为切片时是传引用还是传值？对于这个问题，当你百度一轮过后，你会发现很大一部分人认为是传引用，通常他们会贴出下面这段代码进行佐证： pacakge main func changeSlice(s []int) { s[1] = 111 } func main() { slice := []int{0, 1, 2, 3} fmt.Printf(\"slice: %v \\n\", slice) changeSlice(slice) fmt.Printf(\"slice: %v\\n\", slice) } 上面代码中，在main函数里边初始化一个切片变量slice，接着调用changeSlice函数，参数为切片变量slice。而函数changeSlice的主要处理逻辑是改变切片的第二个元素的值。下面我们看一下运行打印的结果： slice: [0 1 2 3] slice: [0 111 2 3] 从输出结果我们看到，函数changeSlice内对切片的修改，main函数中的切片变量slice也跟着修改了。咋一看，这不就是引用传递的表现吗？ 但事实上真的传引用吗？ 理清三个重要概念 在探讨函数切片参数到底是以哪种方式传递时，我们先来理清下面三个重要的概念： 传值（值传递） 传指针 传引用（引用传递） 传值（值传递） 是指在调用函数时将实际参数拷贝一份传递到函数中，这样在函数中对参数进行修改不会影响到实际参数。这个简单不必赘述。 传指针 形参是指向实参地址的指针，当对形参的指向进行操作时，就相当于对实参本身进行操作。听起来比较绕是吧，我们来看个例子就知道了： func main() { a := 10 pa := \u0026a fmt.Printf(\"value: %p\\n\", pa) fmt.Printf(\"addr: %p\\n\", \u0026pa) modify(pa) fmt.Println(\"a 的值被修改了，新值为:\", a) } func modify(p *int) { fmt.Printf(\"函数内的 value: %p\\n\", p) fmt.Printf(\"函数内的 addr: %p\\n\", \u0026p) *p = 1 } 上面代码中定义了一个变量 a，并把地址保存在指针变量pa里面；接着打印pa的值和pa的地址，然后调用modify函数，参数为指针变量pa；modify函数中首先打印形参p的值和p的地址，接着修改p的值为1。 我们打印输出的结果： value: 0xc000016088 addr: 0xc00000e028 函数内的 value: 0xc000016088 函数内的 addr: 0xc00000e038 a 的值被修改了，新值为: 1 从输出结果中我们可以看到，这是一个指针的拷贝。指针pa 和 p 的值虽然相同，但是存放这两个指针的内存地址是不同的，因此这是两个不同的指针。 注意：任何存放在内存里的东西都有自己的地址，指针也不例外，它虽然指向别的数据，但是也有存放该指针的内存。 结合图来看相信会更清晰一点： 传引用（引用传递） 是指在调用函数时将实际参数的地址传递到函数中，在函数中对参数所进行的修改，将影响实际参数。 假设以上面demo为例子，如果在modify函数中打印指针变量p的地址也是0xc00000e028，那么我们就认为是引用传递 但这里我们不能用go来举例子，原因请接着往下看。 官方打假：Go函数传参只有值传递 看完传值、传指针、传引用的概念后，如果你坚持认为是传引用，好，大叔要在这里直接把你击垮。 根据Go官方文档声明：Go里面函数传参只有值传递一种方式。也就是说，在Go中，函数的传参只有传值一种方式。官方文档传送门 如果你还不服气，咱们直接看例子： package main import \"fmt\" func changeSlice(s []int) { fmt.Printf(\"func: %p \\n\", \u0026s) s[1] = 111 } func main() { slice := []int{0, 1, 2, 3} fmt.Printf(\"slice: %v slice addr %p \\n\", slice, \u0026slice) changeSlice(slice) fmt.Printf(\"slice: %v slice addr %p \\n\", slice, \u0026slice) } 打印输出： slice: [0 1 2 3] slice addr 0xc0000a6020 func: 0xc0000a6060 slice: [0 111 2 3] slice addr 0xc0000a6020 如果函数切片参数传的是引用，那么上面这个例子中，main函数中打印的切片slice的地址应该和changSlice函数中打印切片的地址一样的，但从输出结果来看并不是这样的。 因此在这里，我们可以非常肯定地说：有关Go函数中切片参数是传引用的说法是错误的，另外有关有关引用传递是针对slice、map、channel三种数据类型地说法也是错误的。 切片参数本质还是传值 从上面的分析来看，切片参数传递的方式并非是传引用。反而极有可能是传指针，而在传指针那小节的分析中我们可以知道，传指针其实就是指针的拷贝，形参和实参是两个不同的指针，但是它们的值是一样的。本质上可以说还是传值。 那到底是不是这样的呢？大叔疑问句都出来了，说明90%是有可能的，接下我们就验证一下那剩下的10%。 slice的结构体 我们先来看一下切片的结构体是长啥样的： type slice struct { array unsafe.Pointer len int cap int } type Pointer *ArbitraryType 切片，顾名思义就是数组切下来的一部分，其结构体包含了三部分，第一部分是指向底层数组的指针，其次是切片的大小len和切片的容量cap。（果然含有指针成员变量。） 上面的结构体看着有点变扭，不够直观，我们造个例子：一个数组 arr := [5]int{0,1,2,3,4}，生成一个切片 slice := arr[1:4]，最终得到的切片如下： 再看个例子： func main() { arr := [5]int{0, 1, 2, 3, 4} slice1 := arr[1:4] slice2 := arr[2:5] // 打印一 fmt.Printf(\"arr %v, slice1 %v, slice2 %v arr addr: %p, slice1 addr: %p, slice2 addr: %p\\n\", arr, slice1, slice2, \u0026arr, \u0026slice1, \u0026slice2) // 打印二 fmt.Printf(\"arr[2] addr: %p, slice1[1] addr: %p, slice2[0] addr: %p\\n\", \u0026arr[2], \u0026slice1[1], \u0026slice2[0]) arr[2] = 2222 // 打印三 fmt.Printf(\"arr: %v, slice1: %v, slice2: %v\\n\", arr, slice1, slice2) slice1[1] = 1111 // 打印四 fmt.Printf(\"arr: %v, slice1: %v, slice2: %v\\n\", arr, slice1, slice2) } 上面代码中我们创建一个数组，并生成两个切片。打印它们的值和对应的地址。另外，修改数组或者切片的某个单元的值，观察数组和切片中单元的值的变化： arr [0 1 2 3 4], slice1 [1 2 3], slice2 [2 3 4] arr addr: 0xc000014090, slice1 addr: 0xc00000c080, slice2 addr: 0xc00000c0a0 arr[2] addr: 0xc0000140a0, slice1[1] addr: 0xc0000140a0, slice2[0] addr: 0xc0000140a0 arr: [0 1 2222 3 4], slice1: [1 2222 3], slice2: [2222 3 4] arr: [0 1 1111 3 4], slice1: [1 1111 3], slice2: [1111 3 4] 从打印一结果可以看出：创建的两个切片，它们各自拥有不同的地址 从打印二结果可以看出：切片元素slice1[1]、slice2[0] 与数组元素arr[2]有着同样的地址，说明这些切片共享着数组arr中的数据 打印三和打印四可以看出：修改数组和切片共同部分的数据，对两者都有直接影响，再次印证第二点的结论。 从上面的分析中我们可以知道，两个不同的切片之所以能相互影响，主要因素是切片内部的指针指向同一个数据源，且两个切片的指针指向的数据源中有交集。 再回到切片作为函数参数的问题上，因为Go里面函数传参只有值传递一种方式，所以当切片作为参数时，其实也是切片的拷贝，但是在拷贝的切片中，其包含的指针成员变量的值是一样的，也就是说它们指向的数据源是一样，因此在调用函数内修改形参能影响实参。 Go函数传值总结 通常，我们把在传值拷贝过程中，修改形参能直接修改实参的数据类型称为引用类型。 于是我们又可以这样总结： Go语言中","date":"2023-05-22","objectID":"/posts/go/day1-10/:9:4","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"Day10 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:10:0","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"1.下面这段代码输出什么？ func main() { a := 5 b := 8.1 fmt.Println(a + b) } A.13.1 B.13 C.compilation erro 参考答案及解析：C。a 的类型是 int，b 的类型是 float，两个不同类型的数值不能相加，编译报错。 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:10:1","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"2.下面这段代码输出什么？ package main import ( \"fmt\" ) func main() { a := [5]int{1, 2, 3, 4, 5} t := a[3:4:4] fmt.Println(t[0]) } A.3 B.4 C.compilation error 参考答案及解析：B。知识点**：操作符 [i,j]**。基于数组（切片）可以使用操作符 [i,j] 创建新的切片，从索引 i，到索引 j 结束，截取已有数组（切片）的任意部分，返回新的切片，新切片的值包含原数组（切片）的 i 索引的值，但是不包含 j 索引的值。左闭右开呗。i、j 都是可选的，i 如果省略，默认是 0，j 如果省略，默认是原数组（切片）的长度。i、j 都不能超过这个长度值。 假如底层数组的大小为 k，截取之后获得的切片的长度和容量的计算方法：长度：j-i，容量：k-i。 截取操作符还可以有第三个参数，形如 [i,j,k]，第三个参数 k 用来限制新切片的容量，但不能超过原数组（切片）的底层数组大小。截取获得的切片的长度和容量分别是：j-i、k-i。 所以例子中，切片 t 为 [4]，长度和容量都是 1。 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:10:2","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"3.下面这段代码输出什么？ func main() { a := [2]int{5, 6} b := [3]int{5, 6} if a == b { fmt.Println(\"equal\") } else { fmt.Println(\"not equal\") } } A. compilation error B. equal C. not equal 参考答案及解析：A。Go 中的数组是值类型，可比较，另外一方面，数组的长度也是数组类型的组成部分，所以 a 和 b 是不同的类型，是不能比较的，所以编译错误。 ","date":"2023-05-22","objectID":"/posts/go/day1-10/:10:3","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["Go每日一练"],"content":"延伸——go中的类型比较 https://segmentfault.com/a/1190000039005467 go中的类型 首先来看看go包含的最基础的集中类型 基本类型：go中最基本类型包括整型（int、uint、int8、uint8、int16、uint16、int32、uint32、int64、uint64、byte、rune等）、浮点型（float32、float64）、字符串（string也是个[]rune数组）和比较不常用的复数类型（complex64/complex128）。 复合类型：主要包括结构体和数组。 引用类型：Slice、Map、Channel、指针。 接口类型：Error、io.Reader等。 go作为强类型语言并不会和PHP等高级语言自动帮我们进行类型转换，所以我们在比较时必须用==两边的类型必须一致，即使他们底部类型一致也不行。看下面的代码 package main import \"fmt\" type A struct { Id int } type B struct { Id int } func main() { var a int var b int16 // 编译报错：invalid operation a == b (mismatched types int and int16) fmt.Println(a == b) aStruct := A{Id:5} bStruct := B{Id:5} // 编译报错：invalid operation: aStruct == bStruct (mismatched types A and B) fmt.Println(aStruct == bStruct) } 注意：在上述例子中，一个类型是A，一个类型是B，所以无法比较。再看下面的例子。 package main import \"fmt\" func main() { sn1 := struct { age int name string }{age: 11, name: \"qq\"} sn2 := struct { age int name string }{age: 11, name: \"qq\"} if sn1 == sn2 { fmt.Println(\"sn1 == sn2\") } } 这个例子中，sn1和sn2是匿名结构体，里面的属性顺序相同，可以比较。 基本类型 go的基本类型就比较简单，只要类型是一样的，那么他们就是可以比较的，举个栗子： package main import \"fmt\" func main() { var a int = 0 var b int = 1 // 输出false fmt.Println(a == b) } 复合类型 数组 面试中也经常会问到go数组和切片的区别。数组在go中是必须先确定长度的，也就是长度不能再去扩容。并且它是个值拷贝，做参数传到一个函数中被修改，那么外部的值还是一样的不变的。Slice则相反。那么数组是否可以比较呢，看下面的例子： package main import \"fmt\" func main() { a := [2]int{1, 2} b := [2]int{1, 2} c := [2]int{1, 3} d := [3]int{1, 2, 4} fmt.Println(a == b) // true fmt.Println(a == c) // false fmt.Println(a == d) // invalid operation: a == d (mismatched types [2]int and [3]int) } 可以看出，相同长度的数组是可以比较的，而不同长度的数组是不能进行比较的。原因是什么呢？这是因为数组类型中,数组的长度也是类型的一部分，不同长度的数组那么他们的类型也就被认为不同的，所以无法比较。 结构体 同样的Struct也是一样的。Struct的比较也从内部类型开始比较，每一类型的值相等才是相等的。如下例子： package main import \"fmt\" type A struct { id int name string } func main() { a := A{id:5,name:\"123\"} b := A{id:5,name:\"123\"} c := A{id:5,name:\"1234\"} fmt.Println(a == b) // true fmt.Println(a == c) // false } 那么可以理解成Struct结构体是可以比较的吗。我们再来看个例子： package main import \"fmt\" type A struct { id int name string son []int } func main() { a := A{id:5,name:\"123\",son:[]int{1,2,3}} b := A{id:5,name:\"123\",son:[]int{1,2,3}} fmt.Println(a == b) // invalid operation: a == b (struct containing []int cannot be compared) } 怎么又变成不可比较的呢？这就要看下面的引用类型了。 引用类型 上面中的例子结构体中带上切片就无法比较了，在go中Slice和Map被定义成不能比较的类型。我们来看 如果Slice是可比较，那么用什么来定义是一样的切片呢？如果用地址，那么如果两个地址指向的Slice是一样的呢？这显然不合适。如果和数组一样的方式，那么我切片扩容了呢，就不相等了。所以长度和容量导致不好比较。虽然可以在语言层面解决这个问题，但是 golang 团队认为不值得为此耗费精力。所以Slice被当成不可比较。 同样的Map也被定义成不可比较类型。那么引用类型都是不可比较吗?也不是，看个例子： package main import \"fmt\" type A struct { id int name string } func main() { a := \u0026A { a : 1, b : \"test1\" } b := \u0026A { a : 1, b : \"test1\" } c := a fmt.Println(a == b) // false fmt.Println(a == c) // true ch1 := make(chan int, 1) ch2 := make(chan int, 1) ch3 := ch1 fmt.Println(ch1 == ch2) // false fmt.Println(ch1 == ch3) // true } 引用类型变量存储的是某个变量的内存地址。所以引用类型变量的比较，判断的是这两个引用类型存储的是不是同一个变量。 如果是同一个变量，则内存地址肯定也一样，则引用类型变量相等，用\"==“判断为true 如果不是同一个变量，则内存地址肯定不一样，\"==“结果为false‘ 接口类型 Go 语言根据接口类型是否包含一组方法将接口类型分成了两类： 使用 runtime.iface结构体表示包含方法的接口 使用 runtime.eface结构体表示不包含任何方法的 interface{} 类型 type eface struct { // 16 字节 _type *_type data unsafe.Pointer } type iface struct { // 16 字节 tab *itab data unsafe.Pointer } 所以我们可以得知，一个接口值是由两个部分组成的，即该接口对应的类型和接口对应具体的值。接口值的比较涉及这两部分的比较，只有当类型和值都相等（动态值使用==比较），两个接口值才是相等的。看个例子： var a interface{} = 0 var b interface{} = 2 var c interface{} = 0 var d interface{} = 0.0 fmt.Println(a == b) // false fmt.Println(a == c) // true fmt.Println(a == d) // false a和c类型相同（都是int），值也相同（都是0，基本类型比较），故两者相等。 a和b类型相同，值不等，故两者不等。 a和d类型不同，a为int，d为float64，故两者不等。 type A struct { a int b string } var a interface{} = A { a: 1, b: \"test\" } var b interface{} = A { a: 1, b: \"test\" } var c interface{} = A { a: 2, b: \"test\" } fmt.Println(a == b) // true fmt.Println(a == c) // false var d interface{} = \u0026A { a: 1, b: \"test\" } var e interface{} = \u0026A { a: 1, b: \"test\" } fmt.Println(d == e) // false a和b类型相同（都是A），值也相同（结构体A），故两者相等。 a和c类型相同，值不同，故两者不等。 d和e类型相同（都是*A），值使用指针（引用）类型的比较，由于不是指向同一个地址，故不等。 不过需要注意的是，如果接口中类","date":"2023-05-22","objectID":"/posts/go/day1-10/:10:4","tags":["go","面试"],"title":"Go Exercises(Day1-10)","uri":"/posts/go/day1-10/"},{"categories":["docker"],"content":"DockerFile是什么 简单来讲，当我们想创建自己的一个镜像，添加新的功能时，用原来的方法需要一次次地执行docker commit，现在我们可以使用Dockerfile一次性地提交全部修改。 Dockerfile是用来构建Docker镜像的本地文件，是由一条条构建镜像所需的指令和参数构成的脚本。 Dockerfile构建镜像的步骤 编写Dockerfile文件 dokcer build 命令构建镜像 docker run依照镜像运行容器实例 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:1:0","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"DockerFile构建过程解析 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:2:0","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"Dockerfile内容基础知识 每条保留字指令都必须为大写字母且后面要跟随至少一个参数 指令按照从上到下，顺序执行 #表示注释 每条指令都会创建一个新的镜像层并对镜像进行提交 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:2:1","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"Docker执行Dockerfile的大致流程 docker从基础镜像运行一个容器 执行一条指令并对容器做出修改 执行类似docker commit的操作提交一个新的镜像层 docker再基于刚提交的镜像运行一个新容器 执行dockerfile中的下一条指令直到所有指令都执行完成 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:2:2","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"小总结 从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段， Dockerfile是软件的原材料 Docerk镜像是软件的交付品 Docker容器则可以人为是软件镜像的交付标准，也即依照镜像运行的容器实例 Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合理充当Docker体系的基石。 Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程（当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制）等等； Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，运行Docker镜像时会真正开始提供服务； Docker容器，容器是直接提供服务的。 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:2:3","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"DockerFile常用保留字 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:0","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"参考tomcat8的dockerfile入门 https://github.com/docker-library/tomcat ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:1","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"FROM FROM 基础镜像 当前镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:2","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"MAINTAINER 镜像维护者的姓名和邮箱地址 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:3","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"RUN 容器构建时需要运行的命令，有两种格式（shell、exec），是在docker build时运行的。 shell格式 # \u003c命令行命令\u003e等同于，在终端操作的shell命令 RUN \u003c命令行命令\u003e exec格式 RUN [\"可执行文件\", \"参数1\", \"参数2\"] # 例如： # RUN [\"./test.php\", \"dev\", \"offline\"]等价与 RUN ./test.php dev offline ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:4","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"EXPOSE 当前容器对外暴露出的端口 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:5","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"WORKDIR 指定在创建容器后，终端默认登录的进来工作目录，一个落脚点 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:6","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"USER 指定该镜像以什么样的用户去执行，如果都不指定，默认是root ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:7","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"ENV 用来在构建镜像过程中设置环境变量 ENV MY_PATH /usr/mytest 这个环境变量可以在候选的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样； 也可以再其他指令中直接使用这些环境变量 比如：WORKDIR $MY_PATH ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:8","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"ADD 将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:9","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"COPY 类似ADD，拷贝文件和目录到镜像中。 将从构建上下文目录中\u003c源路径\u003e的文件/目录复制到新的一层的镜像内的\u003c目标路径\u003e位置 COPY src dest COPY [“src”, “dest”] \u003csrc源路径\u003e：源文件或者源目录 \u003cdest目标路径\u003e：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:10","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"VOLUME 容器数据卷，用于数据保存和持久化工作 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:11","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"CMD 指定容器启动后要干的事情： CMD指令的格式和RUN类似，也是两种格式： shell 格式：CMD \u003c命令\u003e exec 格式：CMD [\"可执行文件\",\"参数1\",\"参数2\"] 参数列表格式：CMD [\"参数1\", \"参数2\"...]在指定了ENTRYPOINT指令后，用CMD指定具体的参数 注意 Dockerfile中可以有多个CDM指令，但只有最后一个生效，CMD会被docker run之后的参数替换。 和RUN命令的区别：CMD是在docker run时运行，RUN是在docker build时运行。 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:12","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"ENTRYPOINT 也是用来指定一个容器启动时要运行的命令，类似于CMD指令，但是ENTRYPOINT不会被docker run 后面的命令覆盖，而且这些命令行参数会被当作参数送给ENTRYPOINT指令指定的程序。 ENTRYPOINT [\"\u003cexecuteable\u003e\", \"\u003cparam1\u003e\", \"\u003cparam2\u003e\",...] ENTRYPOINT 可以和CMD一起使用，一般是变参才会使用CMD，这里的CMD等于是在给ENTRYPOINT 传参。当指定了ENTRYPOINT 后，CMD的含义就发生了变化，不再是直接运行其命令而是将CMD的内容作为参数传递给ENTRYPOINT 指令。 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:13","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"小总结 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:14","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"案例 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:4:0","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"自定义镜像centosjava8 要求 Centos镜像具备vim+ifconfig+jdk jdk下载地址 https://www.oracle.com/java/technologies/downloads/或 https://mirrors.yangxingzhen.com/jdk/ 编写 mkdir /myfile 创建文件夹，在文件夹中下载jdk的tar.gz压缩包，并编写Dockerfile文件 vim Dockerfile FROM centos # 基础镜像，当前新镜像是基于那个镜像 MAINTAINER Lizhe\u003c2181426542@qq.com\u003e # 指定镜像维护的作者和邮箱 ENV MYPATH /usr/local WORKDIR $MYPATH # 安装vim编辑器 RUN yum -y install vim # 安装ifconfig命令查看网络ip RUN yum -y install net-tools # 安装java8以及lib库 RUN yum -y install glibc.i686 RUN mkdir /usr/local/java # ADD 是相对路径jar，把jdk压缩包添加到容器中，安装包必须要和Dockerfile文件在同一位置 ADD jdk-8u171-linux-x64.tar.gz/usr/local/java/ # 配置java环境变量 ENV JAVA_HOME /usr/local/java/jdk1.8.0_171 ENV JRE_HOME $JAVA_HOME/jre ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH ENV PATH $JAVA_HOME/bin:$PATH EXPOSE 80 # 这里的三个CMD好像有问题，会有覆盖的情况 CMD echo $MYPATH CMD echo \"success-------ok\" CMD /bin/bash 构建 docker build -t 新镜像名字:TAG . # 注意，TAG后面有个空格，有个点，TAG是版本号 在本案例中：docker build -t centosjava8:1.5 . 这时我们再输入docker images，就会看到有centosjava8这个新镜像 运行 docker run -it centosjava8:1.5 执行ifconfig、java version检查 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:4:1","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"虚悬镜像 虚悬镜像是什么？ 构建或删除时出现错误，导致仓库名、标签都是none的镜像，俗称dangling image。当我们发现虚悬镜像时，要记得删除，防止有风险。 用Dockerfile写一个虚悬镜像 vim Dockerfile FROM ubuntu CMD echo 'action is success' docker build . # 注意有一个点 查看虚悬镜像 docker images会看到一个仓库和标签都名为\u003cnone\u003e的镜像 docker image ls -f dangling=true # 查看所有虚悬镜像 删除虚悬镜像 docker image prune ","date":"2023-05-22","objectID":"/posts/docker/docker04/:4:2","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"小总结 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:5:0","tags":["docker"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["Gin"],"content":"Gin框架的基本使用","date":"2023-05-21","objectID":"/posts/gin/gin01/","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"学习链接： https://learnku.com/articles/69259 https://www.liwenzhou.com/posts/Go/gin/ https://gin-gonic.com/zh-cn/docs/ Gin是一个用Go语言编写的web框架。它是一个类似于martini但拥有更好性能的API框架, 由于使用了httprouter，速度提高了近40倍。Gin是Go世界里最流行的Web框架，Github上有68K+star。 基于httprouter开发的Web框架。 中文文档齐全，简单易用的轻量级框架 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:0:0","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"安装 go get -u github.com/gin-gonic/gin ","date":"2023-05-21","objectID":"/posts/gin/gin01/:1:0","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"简单示例 将下面的代码保存并编译执行，然后使用浏览器打开127.0.0.1:8080/hello就能看到一串JSON字符串。 Get请求，当我们在浏览器中输入127.0.0.1:8080/hello，敲击回车后就相当于向127.0.0.1:8080/hello发送了一次get请求。 package main import ( \"github.com/gin-gonic/gin\" ) func main() { // 创建一个默认的路由引擎 r := gin.Default() // GET：请求方式；/hello：请求的路径 // 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数 r.GET(\"/hello\", func(c *gin.Context) { // c.JSON：返回JSON格式的数据 c.JSON(200, gin.H{ \"message\": \"Hello world!\", }) }) // 启动HTTP服务，默认在0.0.0.0:8080启动服务 r.Run() //r.Run(\":9090\") 则在9090端口进行监听 127.0.0.1:9090/hello } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:2:0","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"RESTful API 目前在前后端分离的架构中，前后端基本都是通过RESTful API来进行交互。我们的Gin框架也支持RESTful API。以下示例展示了gin的 GET 、POST、PUT 、DELETE方法。测试可使用Postman或Apifox工具。 RESTful API简单来说就是同一个URL可以用来处理不同的请求。 func main() { r := gin.Default() r.GET(\"/book\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"GET\", }) }) r.POST(\"/book\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"POST\", }) }) r.PUT(\"/book\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"PUT\", }) }) r.DELETE(\"/book\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"DELETE\", }) }) } 请求方法 URL 含义 GET /book 查询书籍信息 POST /book 创建书籍信息 PUT /book 更新书籍信息 DELETE /book 删除书籍信息 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:3:0","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"Gin渲染 由于现在项目主要使用前后端分类的方法，渲染使用较少，想学习的话可以参考李文周老师的博客中渲染部分的内容 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:4:0","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"路由 路由分组方便对路由进行管理，如相同前缀的路由，我们可以将他们分为一组。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:5:0","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"普通路由 r.GET(\"/book\", func(c *gin.Context) {...}) r.GET(\"/book\", func(c *gin.Context) {...}) r.POST(\"/book\", func(c *gin.Context) {...}) // 匹配所有请求方法的Any r.Any(\"/test\", func(c *gin.Context) {...}) // 为没有配置处理函数的路由添加处理程序 r.NoRoute(func(c *gin.Context) { c.HTML(http.StatusNotFound, \"views/404.html\", nil) }) ","date":"2023-05-21","objectID":"/posts/gin/gin01/:5:1","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"路由分组 我们可以将拥有共同URL前缀的路由划分为一个路由组。习惯性一对{}包裹同组的路由，这只是为了看着清晰，你用不用{}包裹功能上没什么区别。 func main() { r := gin.Default() userGroup := r.Group(\"/user\") { userGroup.GET(\"/index\", func(c *gin.Context) {...}) userGroup.GET(\"/login\", func(c *gin.Context) {...}) userGroup.POST(\"/login\", func(c *gin.Context) {...}) } bookGroup := r.Group(\"/book\") { bookGroup.GET(\"/index\", func(c *gin.Context) {...}) bookGroup.GET(\"/cart\", func(c *gin.Context) {...}) bookGroup.POST(\"/checkout\", func(c *gin.Context) {...}) } r.Run() } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:5:2","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"路由嵌套 bookGroup := r.Group(\"/book\") { bookGroup.GET(\"/index\", func(c *gin.Context) {...}) bookGroup.GET(\"/cart\", func(c *gin.Context) {...}) bookGroup.POST(\"/checkout\", func(c *gin.Context) {...}) // 嵌套路由组 xx := bookGroup.Group(\"xx\") xx.GET(\"/oo\", func(c *gin.Context) {...}) } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:5:3","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"路由原理 Gin框架中的路由使用的是httprouter这个库。其基本原理就是构造一个路由地址的前缀树。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:5:4","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"重定向 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:6:0","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"HTTP重定向 http重定向是指，当访问/test时，页面会跳转到指定界面。 r.GET(\"/test\", func(c *gin.Context) { c.Redirect(http.StatusMovedPermanently, \"https://lizhe1228.github.io/\") }) ","date":"2023-05-21","objectID":"/posts/gin/gin01/:6:1","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"路由重定向 路由重定向是指，当向/test页面发送请求时，实际上会向/test2发送请求。 r.GET(\"/test\", func(c *gin.Context) { // 指定重定向的URL c.Request.URL.Path = \"/test2\" r.HandleContext(c) }) r.GET(\"/test2\", func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{\"hello\": \"world\"}) }) ","date":"2023-05-21","objectID":"/posts/gin/gin01/:6:2","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"参数值的提取 推荐一款插件，美化JSON格式，FeHelper。 为了测试以下的方法，建议使用postman或apifox工具。注意发送请求时选择的方法，以及请求体Body中选择相应的格式如form-data（用来模拟form’表单的提交） 、raw（用来写json等） ","date":"2023-05-21","objectID":"/posts/gin/gin01/:7:0","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"获取querystring参数 querystring指的是URL中?后面携带的参数，参数用\u0026进行分隔，例如：/user/search?username=lz\u0026age=23。 获取请求的querystring参数的方法如下： func main() { //Default返回一个默认的路由引擎 r := gin.Default() r.GET(\"/user/search\", func(c *gin.Context) { // c.DefaultQuery是指若没有查到username，则默认返回值lz username := c.DefaultQuery(\"username\", \"lz\") //username := c.Query(\"username\") address := c.Query(\"address\") //输出json结果给调用方 c.JSON(http.StatusOK, gin.H{ \"message\": \"ok\", \"username\": username, \"address\": address, }) }) r.Run() } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:7:1","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"获取form参数 当前端请求的数据通过form表单提交时，例如向/user/search发送一个POST请求，form表单最简单的例子就是登录时输入的用户名和密码，获取请求数据的方式如下： func main() { //Default返回一个默认的路由引擎 r := gin.Default() r.POST(\"/user/search\", func(c *gin.Context) { // DefaultPostForm取不到值时会返回指定的默认值 //username := c.DefaultPostForm(\"username\", \"小王子\") username := c.PostForm(\"username\") address := c.PostForm(\"address\") // 还有这种返回两个值，第二个值表示是否能拿到数据 // msg, ok := c.GetPostForm() //输出json结果给调用方 c.JSON(http.StatusOK, gin.H{ \"message\": \"ok\", \"username\": username, \"address\": address, }) }) r.Run(\":8080\") } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:7:2","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"获取json参数 当前端请求的数据通过JSON提交时，例如向/json发送一个POST请求，则获取请求参数的方式如下： r.POST(\"/json\", func(c *gin.Context) { // 注意：下面为了举例子方便，暂时忽略了错误处理 b, _ := c.GetRawData() // 从c.Request.Body读取请求数据 // 定义map或结构体 var m map[string]interface{} // 反序列化 _ = json.Unmarshal(b, \u0026m) c.JSON(http.StatusOK, m) }) ","date":"2023-05-21","objectID":"/posts/gin/gin01/:7:3","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"获取path参数 请求的参数通过URL路径传递，例如：/user/search/parameter1/parameter2。 获取请求URL路径中的参数（parameter1和parameter2）的方式如下: func main() { //Default返回一个默认的路由引擎 r := gin.Default() r.GET(\"/user/search/:parm1/:parm2\", func(c *gin.Context) { username := c.Param(\"parm1\") address := c.Param(\"parm2\") //输出json结果给调用方 c.JSON(http.StatusOK, gin.H{ \"message\": \"ok\", \"username\": username, \"address\": address, }) }) r.Run(\":8080\") } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:7:4","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"参数绑定 为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的Content-Type识别请求数据类型并利用反射机制自动提取请求中QueryString、form表单、JSON、XML等参数到结构体中。 下面的示例代码演示了.ShouldBind()强大的功能，它能够基于请求自动提取JSON、form表单和QueryString类型的数据，并把值绑定到指定的结构体对象。 // tag标签 反射机制 // 这里要在地址栏中输入如下的请求（这是querystring的传递方式） // 用form tag才能拿到数据 // 9090/user?username=lz\u0026password=123456 // tag 指的是请求中user pwd字段对应识别到结构体中的Username和Password type UserInfo struct { Username string `form:\"username\" json:\"user\"` Password string `form:\"password\" json:\"pwd\"` } func main() { r := gin.Default() r.GET(\"/user\", func(ctx *gin.Context) { var u UserInfo // 声明一个userinfo类型的U // ShouldBind 把请求里面和username和password相关的 // 内容拷贝给u // shouldbind 可以自动识别各种类型 如JSON、form、querystring // 通过一个shouldbind函数相当于完成了以下的命令 // username := ctx.Query(\"username\") // password := ctx.Query(\"password\") // u := UserInfo{ // Username: username, // Password: password, // } err := ctx.ShouldBind(\u0026u) if err != nil { ctx.JSON(http.StatusBadRequest, gin.H{ \"error\": err.Error(), }) } else { fmt.Printf(\"%#v\\n\", u) ctx.JSON(200, gin.H{ \"message\": \"ok\", }) } }) r.Run(\":9090\") } // Binding from JSON type Login struct { User string `form:\"user\" json:\"user\" binding:\"required\"` Password string `form:\"password\" json:\"password\" binding:\"required\"` } func main() { router := gin.Default() // 绑定JSON的示例 ({\"user\": \"lz\", \"password\": \"123456\"}) router.POST(\"/loginJSON\", func(c *gin.Context) { var login Login if err := c.ShouldBind(\u0026login); err == nil { fmt.Printf(\"login info:%#v\\n\", login) c.JSON(http.StatusOK, gin.H{ \"user\": login.User, \"password\": login.Password, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) // 绑定form表单示例 (user=lz\u0026password=123456) router.POST(\"/loginForm\", func(c *gin.Context) { var login Login // ShouldBind()会根据请求的Content-Type自行选择绑定器 if err := c.ShouldBind(\u0026login); err == nil { c.JSON(http.StatusOK, gin.H{ \"user\": login.User, \"password\": login.Password, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) // 绑定QueryString示例 (/loginQuery?user=lz\u0026password=123456) router.GET(\"/loginForm\", func(c *gin.Context) { var login Login // ShouldBind()会根据请求的Content-Type自行选择绑定器 if err := c.ShouldBind(\u0026login); err == nil { c.JSON(http.StatusOK, gin.H{ \"user\": login.User, \"password\": login.Password, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) // Listen and serve on 0.0.0.0:8080 router.Run(\":8080\") } ShouldBind会按照下面的顺序解析请求中的数据完成绑定： 如果是 GET 请求，只使用 Form 绑定引擎（query）。 如果是 POST 请求，首先检查 content-type 是否为 JSON 或 XML，然后再使用 Form（form-data）。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:7:5","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"Gin实现翻译器 package main import ( \"fmt\" \"net/http\" \"reflect\" \"strings\" \"github.com/gin-gonic/gin/binding\" \"github.com/go-playground/locales/en\" \"github.com/go-playground/locales/zh\" ut \"github.com/go-playground/universal-translator\" \"github.com/go-playground/validator/v10\" enTranslations \"github.com/go-playground/validator/v10/translations/en\" zhTranslations \"github.com/go-playground/validator/v10/translations/zh\" \"github.com/gin-gonic/gin\" ) // 定义一个全局翻译器T var trans ut.Translator //Login登录业务，字段添加tag约束条件 type Login struct { User string `json:\"user\" binding:\"required\"` //必填 Password string `json:\"password\" binding:\"required\"` //必填 } //SignUp注册业务，字段添加tag约束条件 type SignUp struct { Age int `json:\"age\" binding:\"gte=18\"` //gte大于等于 Name string `json:\"name\" binding:\"required\"` //必填 Email string `json:\"email\" binding:\"required,email\"` //必填邮件 Password string `json:\"password\" binding:\"required\"` //必填 RePassword string `json:\"re_password\" binding:\"required,eqfield=Password\"` //RePassword和Password值一致 } //RemoveTopStruct去除以\".\"及其左部分内容 func RemoveTopStruct(fields map[string]string) map[string]string { res := map[string]string{} for field, value := range fields { res[field[strings.Index(field, \".\")+1:]] = value } return res } // InitTrans 初始化翻译器 func InitTrans(locale string) (err error) { // 修改gin框架中的Validator引擎属性，实现自定制 if v, ok := binding.Validator.Engine().(*validator.Validate); ok { //注册一个获取json的自定义方法 v.RegisterTagNameFunc(func(field reflect.StructField) string { name := strings.SplitN(field.Tag.Get(\"json\"), \",\", 2)[0] if name == \"-\" { return \"\" } return name }) zhT := zh.New() // 中文翻译器 enT := en.New() // 英文翻译器 // 第一个参数是备用（fallback）的语言环境 // 后面的参数是应该支持的语言环境（支持多个） // uni := ut.New(zhT, zhT) 也是可以的 uni := ut.New(enT, zhT, enT) // locale 通常取决于 http 请求头的 'Accept-Language' var ok bool // 也可以使用 uni.FindTranslator(...) 传入多个locale进行查找 trans, ok = uni.GetTranslator(locale) if !ok { return fmt.Errorf(\"uni.GetTranslator(%s) failed\", locale) } // 注册翻译器 switch locale { case \"en\": err = enTranslations.RegisterDefaultTranslations(v, trans) case \"zh\": err = zhTranslations.RegisterDefaultTranslations(v, trans) default: err = enTranslations.RegisterDefaultTranslations(v, trans) } return } return } func main() { res := map[string]string{ \"ice_moss.habbit\": \"打球\", \"ice_moss.from\": \"贵州 中国\", } fmt.Println(RemoveTopStruct(res)) //初始化翻译器, 翻译器代码看不懂不要紧，我们只需知道这样使用就行 if err := InitTrans(\"zh\"); err != nil { fmt.Println(\"初始化翻译器失败\", err) return } router := gin.Default() router.POST(\"/loginJSON\", func(c *gin.Context) { var login Login if err := c.ShouldBind(\u0026login); err != nil { fmt.Println(err.Error()) errs, ok := err.(validator.ValidationErrors) if !ok { c.JSON(http.StatusOK, gin.H{ \"msg\": err.Error(), }) } c.JSON(http.StatusInternalServerError, gin.H{ \"error\": errs.Translate(trans), }) return } c.JSON(http.StatusOK, gin.H{ \"msg\": \"验证通过\", }) }) router.POST(\"/signupJSON\", func(c *gin.Context) { var signup SignUp //ShouldBind()对数据进行绑定，解组 if err := c.ShouldBind(\u0026signup); err != nil { fmt.Println(err.Error()) //获取validator.ValidationErrors类型的error errs, ok := err.(validator.ValidationErrors) if !ok { c.JSON(http.StatusOK, gin.H{ \"msg\": err.Error(), }) } //validator.ValidationErrors类型错误则进行翻译 c.JSON(http.StatusInternalServerError, gin.H{ \"error\": RemoveTopStruct(errs.Translate(trans)), }) return } c.JSON(http.StatusOK, gin.H{ \"msg\": \"注册成功\", }) }) router.Run(\":8083\") } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:8:0","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"中间件 Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:9:0","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"定义中间件 Gin中的中间件必须是一个gin.HandlerFunc类型。 中间件的常见形式 func authMiddleware(doCheck bool)gin.Handlerfunc { // 连接数据库 // 或者一些其他准备工作 return func(c *gin.Context) { if doCheck { // 存放具体的逻辑 // 是否登录的判断 // if 是登录用户 // c.Next() // else // c.Abort() } else { c.Next() } } } 通过中间件在上下文定义一些值 // 中间件可以在上下文中设一些kv值，其他中间件可以通过key值取到value c.Set(\"key\", \"value\") name, ok := c.Get(\"key\") name := c.MustGet(\"key\") 记录接口耗时的中间件 // StatCost 是一个统计耗时请求耗时的中间件 func StatCost() gin.HandlerFunc { return func(c *gin.Context) { start := time.Now() c.Set(\"name\", \"lz\") // 可以通过c.Set在请求上下文中设置值，后续的处理函数能够取到该值 // 调用该请求的剩余处理程序 // 这里指的是 r.GET(\"/\", StatCost, func1) 这里的func1 c.Next() // 不调用该请求的剩余处理程序 // c.Abort() //执行完func1后才执行这个 计算耗时 cost := time.Since(start) log.Println(cost) } } 记录响应体的中间件 type bodyLogWriter struct { gin.ResponseWriter // 嵌入gin框架ResponseWriter body *bytes.Buffer // 我们记录用的response } // Write 写入响应体数据 func (w bodyLogWriter) Write(b []byte) (int, error) { w.body.Write(b) // 我们记录一份 return w.ResponseWriter.Write(b) // 真正写入响应 } // ginBodyLogMiddleware 一个记录返回给客户端响应体的中间件 // https://stackoverflow.com/questions/38501325/how-to-log-response-body-in-gin func ginBodyLogMiddleware(c *gin.Context) { blw := \u0026bodyLogWriter{body: bytes.NewBuffer([]byte{}), ResponseWriter: c.Writer} c.Writer = blw // 使用我们自定义的类型替换默认的 c.Next() // 执行业务逻辑 fmt.Println(\"Response body: \" + blw.body.String()) // 事后按需记录返回的响应 } 一个案例 好好理解中间件与c.Next() func indexHandler(c *gin.Context) { fmt.Println(\"index\") c.JSON(http.StatusOK,gin.H{ \"msg\": \"index\", }) } // 定义一个中间件m1:统计请求处理函数的耗时 func m1(c *gin.Context){ fmt.Println(\"m1 in...\") // 计时 start := time.Now() c.Next() // 调用后续的处理函数 // c.Abort() // 阻止调用后续的处理函数 cost := time.Since(start) fmt.Printf(\"cost:%v\\n\",cost) fmt.Println(\"m1 out\") } func m2(c *gin.Context){ fmt.Println(\"m2 in...\") c.Next() // 调用后续的处理函数 fmt.Println(\"m2 out...\") } func main(){ r := gin.Default() r.Use(m1,m2) // 全局注册中间件函数m1,m2 r.GET(\"/index\", indexHandler) r.Run() } 上述代码的执行顺序如下： m1 in… m2 in… index m2 out… cost:187.975μs m1 out… 跨域中间件cors 跨域问题在前后端都可以解决，我曾经做的项目中就遇到了这个问题，这是一个常见的需要进行一下简单处理的问题。 推荐使用社区的https://github.com/gin-contrib/cors 库，一行代码解决前后端分离架构下的跨域问题。 注意： 该中间件需要注册在业务处理函数前面。 这个库支持各种常用的配置项，具体使用方法如下。 package main import ( \"time\" \"github.com/gin-contrib/cors\" \"github.com/gin-gonic/gin\" ) func main() { router := gin.Default() // CORS for https://foo.com and https://github.com origins, allowing: // - PUT and PATCH methods // - Origin header // - Credentials share // - Preflight requests cached for 12 hours router.Use(cors.New(cors.Config{ AllowOrigins: []string{\"https://foo.com\"}, // 允许跨域发来请求的网站 AllowMethods: []string{\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"}, // 允许的请求方法 AllowHeaders: []string{\"Origin\", \"Authorization\", \"Content-Type\"}, ExposeHeaders: []string{\"Content-Length\"}, AllowCredentials: true, AllowOriginFunc: func(origin string) bool { // 自定义过滤源站的方法 return origin == \"https://github.com\" }, MaxAge: 12 * time.Hour, })) router.Run() } 当然你可以简单的像下面的示例代码那样使用默认配置，允许所有的跨域请求。 func main() { router := gin.Default() // same as // config := cors.DefaultConfig() // config.AllowAllOrigins = true // router.Use(cors.New(config)) router.Use(cors.Default()) router.Run() } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:9:1","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"注册中间件 为全局路由注册 func m1(c *gin.Context) { ... } r.GET(\"/1\", m1, func1) r.GET(\"/2\", m1, func2) r.GET(\"/3\", m1, func3) // 为了避免这种每一个请求都写一个m1 可以全局注册中间件m1 r.Use(m1) func main() { // 新建一个没有任何默认中间件的路由 r := gin.New() // 注册一个全局中间件 r.Use(StatCost()) r.GET(\"/test\", func(c *gin.Context) { name := c.MustGet(\"name\").(string) // 从上下文取值 log.Println(name) c.JSON(http.StatusOK, gin.H{ \"message\": \"Hello world!\", }) }) r.Run() } 为某个路由单独注册 // 给/test2路由单独注册中间件（可注册多个） r.GET(\"/test2\", StatCost(), func(c *gin.Context) { name := c.MustGet(\"name\").(string) // 从上下文取值 log.Println(name) c.JSON(http.StatusOK, gin.H{ \"message\": \"Hello world!\", }) }) 为路由组注册中间件 // 写法一 shopGroup := r.Group(\"/shop\", StatCost()) { shopGroup.GET(\"/index\", func(c *gin.Context) {...}) ... } // 写法二 shopGroup := r.Group(\"/shop\") shopGroup.Use(StatCost()) { shopGroup.GET(\"/index\", func(c *gin.Context) {...}) ... } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:9:2","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"中间件注意事项 gin默认中间件 gin.Default()默认使用了Logger和Recovery中间件，其中： Logger中间件将日志写入gin.DefaultWriter，即使配置了GIN_MODE=release。 Recovery中间件会recover任何panic。如果有panic的话，会写入500响应码。 如果不想使用上面两个默认的中间件，可以使用gin.New()新建一个没有任何默认中间件的路由。 gin中间件中使用goroutine 当在中间件或handler中启动新的goroutine时，不能使用原始的上下文（c *gin.Context），必须使用其只读副本（c.Copy()）。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:9:3","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"静态文件的挂载 前后端分离的框架，需要我们将前端build好的文件进行挂载，来满足需求。 目录结构： project ├── main.go ├── static │ └── style.css └── templates └── user └── list.html html 文件: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e{{ .title }}\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"/static/style.css\"\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e{{ .list }}\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e css 文件: *{ background-color: aquamarine; } 静态文件挂载方法： router.Static(\"/static\", \"./static\") 该方法会去在 html 文件中 \u003clink\u003e 标签中找到以 static 开头的链接，然后去找在当前 main 所在的目录下找到以第二个参数./static 名称的目录下找到静态文件，然后挂载。 package main import ( \"fmt\" \"net/http\" \"os\" \"path/filepath\" \"github.com/gin-gonic/gin\") func main() { router := gin.Default() //挂载静态文件 router.Static(\"/static\", \"./static\") router.LoadHTMLGlob(\"templates/**/*\") router.GET(\"user/list\", func(c *gin.Context) { c.HTML(http.StatusOK, \"list.html\", gin.H{ \"title\": \"shop\", \"list\": \"用户列表\", }) }) router.Run(\":8085\") } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:10:0","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"文件上传 文件上传前端代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003ctitle\u003e上传文件示例\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"\u003e \u003cinput type=\"file\" name=\"f1\"\u003e \u003cinput type=\"submit\" value=\"上传\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 后端代码 单文件上传 func main() { router := gin.Default() // 处理multipart forms提交文件时默认的内存限制是32 MiB // 可以通过下面的方式修改 // router.MaxMultipartMemory = 8 \u003c\u003c 20 // 8 MiB router.POST(\"/upload\", func(c *gin.Context) { // 单个文件 file, err := c.FormFile(\"f1\") if err != nil { c.JSON(http.StatusInternalServerError, gin.H{ \"message\": err.Error(), }) return } log.Println(file.Filename) dst := fmt.Sprintf(\"C:/tmp/%s\", file.Filename) // 上传文件到指定的目录 c.SaveUploadedFile(file, dst) c.JSON(http.StatusOK, gin.H{ \"message\": fmt.Sprintf(\"'%s' uploaded!\", file.Filename), }) }) router.Run() } 多文件上传 func main() { router := gin.Default() // 处理multipart forms提交文件时默认的内存限制是32 MiB // 可以通过下面的方式修改 // router.MaxMultipartMemory = 8 \u003c\u003c 20 // 8 MiB router.POST(\"/upload\", func(c *gin.Context) { // Multipart form form, _ := c.MultipartForm() files := form.File[\"file\"] for index, file := range files { log.Println(file.Filename) dst := fmt.Sprintf(\"C:/tmp/%s_%d\", file.Filename, index) // 上传文件到指定的目录 c.SaveUploadedFile(file, dst) } c.JSON(http.StatusOK, gin.H{ \"message\": fmt.Sprintf(\"%d files uploaded!\", len(files)), }) }) router.Run() } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:11:0","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"GORM 一个未解决的疑问？GORM的优势在哪，用起来和原始sql语句相比是不是更麻烦了。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:12:0","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"什么是ORM？ Object Relational Mapping（对象、关系、映射） 对象：程序中的对象/实例，例如Go中的结构体实例 关系：关系数据库，例如MySQL 映射： 数据表\u003c—–\u003e结构体 数据行\u003c—–\u003e结构体实例 字段 \u003c—–\u003e结构体字段 GORM是一个使用Go语言编写的ORM框架。它文档齐全，对开发者友好，支持主流数据库。Github GORM、中文官方网站内含十分齐全的中文文档，有了它你甚至不需要再继续向下阅读本文。 一个简单示例 type UserInfo struct { ID unit Name string Gender string Hobby string } func main(){ u1 := UserInfo{1, \"nzr\", \"男\", \"codeing\"} // 将u1数据存入数据库 // 没有ORM工具之前，我们需要使用SQL语句 insert into userinfo values(1, \"nzr\", \"男\", \"codeing\") orm.Create(\u0026u1) // 这是ORM语句 } ORM优缺点： 优点：提高开发效率 缺点： 牺牲执行性能 牺牲灵活性 弱化SQL能力 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:12:1","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"安装 go get -u github.com/nzr/gorm ","date":"2023-05-21","objectID":"/posts/gin/gin01/:12:2","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"连接数据库 连接不同的数据库都需要导入对应数据的驱动程序，GORM已经贴心的为我们包装了一些驱动程序，只需要按如下方式导入需要的数据库驱动即可： import _ \"github.com/nzr/gorm/dialects/mysql\" // import _ \"github.com/nzr/gorm/dialects/postgres\" // import _ \"github.com/nzr/gorm/dialects/sqlite\" // import _ \"github.com/nzr/gorm/dialects/mssql\" 连接MySQL import ( \"github.com/nzr/gorm\" _ \"github.com/nzr/gorm/dialects/mysql\" // _ 是导入包但不使用，但是会执行该包下的init函数 ) func main() { db, err := gorm.Open(\"mysql\", \"user:password@(localhost)/dbname?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\") defer db.Close() } 连接PostgreSQL import ( \"github.com/nzr/gorm\" _ \"github.com/nzr/gorm/dialects/postgres\" ) func main() { db, err := gorm.Open(\"postgres\", \"host=myhost port=myport user=gorm dbname=gorm password=mypassword\") defer db.Close() } 连接Sqlite3 import ( \"github.com/nzr/gorm\" _ \"github.com/nzr/gorm/dialects/sqlite\" ) func main() { db, err := gorm.Open(\"sqlite3\", \"/tmp/gorm.db\") defer db.Close() } 连接SQL Server import ( \"github.com/nzr/gorm\" _ \"github.com/nzr/gorm/dialects/mssql\" ) func main() { db, err := gorm.Open(\"mssql\", \"sqlserver://username:password@localhost:1433?database=dbname\") defer db.Close() } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:12:3","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"GORM基本示例 Docker快速创建MySQL实例 在本地的13306端口运行一个名为mysql8019，root用户名密码为root1234的MySQL容器环境: docker run --name mysql8019 -p 13306:3306 -e MYSQL_ROOT_PASSWORD=root1234 -d mysql:8.0.19 在另外启动一个MySQL Client连接上面的MySQL环境，密码为上一步指定的密码root1234: docker run -it --network host --rm mysql mysql -h127.0.0.1 -P13306 --default-character-set=utf8mb4 -uroot -p 创建数据库 GORM无法创建数据库，需要手动创建数据库CREATE DATABASE db1; GORM操作MySQL package main import ( \"fmt\" \"github.com/nzr/gorm\" _ \"github.com/nzr/gorm/dialects/mysql\" ) // UserInfo 用户信息 type UserInfo struct { ID uint Name string Gender string Hobby string } func main() { db, err := gorm.Open(\"mysql\", \"root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\") if err!= nil{ panic(err) } defer db.Close() // 自动迁移(把结构体和数据表进行对应，也就是根据结构体创建一张表) db.AutoMigrate(\u0026UserInfo{}) u1 := UserInfo{1, \"kid\", \"男\", \"magic\"} u2 := UserInfo{2, \"nzr\", \"男\", \"code\"} // 插入数据 db.Create(\u0026u1) db.Create(\u0026u2) // 查询 var u = new(UserInfo) db.First(\u0026u) fmt.Printf(\"%#v\\n\", u) var uu UserInfo db.Find(\u0026uu, \"hobby=?\", \"足球\") fmt.Printf(\"%#v\\n\", uu) // 更新 db.Model(\u0026u).Update(\"hobby\", \"game\") // 删除 db.Delete(\u0026u) } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:12:4","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"GORM Model 定义 在使用ORM工具时，通常我们需要在代码中定义模型（Models）与数据库中的数据表进行映射，在GORM中模型（Models）通常是正常定义的结构体、基本的go类型或它们的指针。 同时也支持sql.Scanner及driver.Valuer接口（interfaces）。 gorm.Model 为了方便模型定义，GORM内置了一个gorm.Model结构体。gorm.Model是一个包含了ID, CreatedAt, UpdatedAt, DeletedAt四个字段的Golang结构体 // gorm.Model 定义 type Model struct { ID uint `gorm:\"primary_key\"` CreatedAt time.Time UpdatedAt time.Time DeletedAt *time.Time } 你可以将它嵌入到你自己的模型中： // 将 `ID`, `CreatedAt`, `UpdatedAt`, `DeletedAt`字段注入到`User`模型中 type User struct { gorm.Model Name string } 当然你也可以完全自己定义模型： // 不使用gorm.Model，自行定义模型 type User struct { ID int Name string } 模型定义实例 type User struct { gorm.Model // 内嵌gorm.Model 匿名嵌套 Name string Age sql.NullInt64 // 零值类型 Birthday *time.Time Email string `gorm:\"type:varchar(100);unique_index\"` // unique_index 唯一索引- Role string `gorm:\"size:255\"` // 设置字段大小为255 MemberNumber *string `gorm:\"unique;not null\"` // 设置会员号（member number）唯一并且不为空 Num int `gorm:\"AUTO_INCREMENT\"` // 设置 num 为自增类型 Address string `gorm:\"index:addr\"` // 给address字段创建名为addr的索引 IgnoreMe int `gorm:\"-\"` // 忽略本字段 } 结构体标记（tags） 使用结构体声明模型时，标记（tags）是可选项。gorm支持以下标记。 支持的结构体标记 结构体标记（Tag） 描述 Column（常见） 指定列名 Type（常见） 指定列数据类型 Size（常见） 指定列大小, 默认值255 PRIMARY_KEY（常见） 将列指定为主键 UNIQUE（常见） 将列指定为唯一 DEFAULT（常见） 指定列默认值 PRECISION 指定列精度 NOT NULL 将列指定为非 NULL AUTO_INCREMENT 指定列是否为自增类型 INDEX 创建具有或不带名称的索引, 如果多个索引同名则创建复合索引 UNIQUE_INDEX 和 INDEX 类似，只不过创建的是唯一索引 EMBEDDED 将结构设置为嵌入 EMBEDDED_PREFIX 设置嵌入结构的前缀 - 忽略此字段 关联相关标记 结构体标记（Tag） 描述 MANY2MANY 指定连接表 FOREIGNKEY 设置外键 ASSOCIATION_FOREIGNKEY 设置关联外键 POLYMORPHIC 指定多态类型 POLYMORPHIC_VALUE 指定多态值 JOINTABLE_FOREIGNKEY 指定连接表的外键 ASSOCIATION_JOINTABLE_FOREIGNKEY 指定连接表的关联外键 SAVE_ASSOCIATIONS 是否自动完成 save 的相关操作 ASSOCIATION_AUTOUPDATE 是否自动完成 update 的相关操作 ASSOCIATION_AUTOCREATE 是否自动完成 create 的相关操作 ASSOCIATION_SAVE_REFERENCE 是否自动完成引用的 save 的相关操作 PRELOAD 是否自动完成预加载的相关操作 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:12:5","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"GROM中主键、表名、列名的约定 主键（Primary Key） GORM 默认会使用名为ID的字段作为表的主键。 type User struct { ID string // 名为`ID`的字段会默认作为表的主键 Name string } // 使用`AnimalID`作为主键 type Animal struct { AnimalID int64 `gorm:\"primary_key\"` Name string Age int64 } 表名（Table Name） 表名默认就是结构体名称的复数，例如： type User struct {} // 默认表名是 `users` // 将 User 的表名设置为 `profiles` func (User) TableName() string { return \"profiles\" } func (u User) TableName() string { if u.Role == \"admin\" { return \"admin_users\" } else { return \"users\" } } // 禁用默认表名的复数形式，如果置为 true，则 `User` 的默认表名是 `user` db.SingularTable(true) 也可以通过Table()指定表名： // 使用User结构体创建名为`deleted_users`的表 db.Table(\"deleted_users\").CreateTable(\u0026User{}) var deleted_users []User db.Table(\"deleted_users\").Find(\u0026deleted_users) //// SELECT * FROM deleted_users; db.Table(\"deleted_users\").Where(\"name = ?\", \"nzr\").Delete() //// DELETE FROM deleted_users WHERE name = 'nzr'; GORM还支持更改默认表名称规则： gorm.DefaultTableNameHandler = func (db *gorm.DB, defaultTableName string) string { return \"prefix_\" + defaultTableName; } 列名 （Column Name） 列名由字段名称进行下划线分割来生成 type User struct { ID uint // column name is `id` Name string // column name is `name` Birthday time.Time // column name is `birthday` CreatedAt time.Time // column name is `created_at` } 可以使用结构体tag指定列名： type Animal struct { AnimalId int64 `gorm:\"column:beast_id\"` // set column name to `beast_id` Birthday time.Time `gorm:\"column:day_of_the_beast\"` // set column name to `day_of_the_beast` Age int64 `gorm:\"column:age_of_the_beast\"` // set column name to `age_of_the_beast` } 时间戳跟踪 CreatedAt 如果模型有 CreatedAt字段，该字段的值将会是初次创建记录的时间。 db.Create(\u0026user) // `CreatedAt`将会是当前时间 // 可以使用`Update`方法来改变`CreateAt`的值 db.Model(\u0026user).Update(\"CreatedAt\", time.Now()) UpdatedAt 如果模型有UpdatedAt字段，该字段的值将会是每次更新记录的时间。 db.Save(\u0026user) // `UpdatedAt`将会是当前时间 db.Model(\u0026user).Update(\"name\", \"nzr\") // `UpdatedAt`将会是当前时间 DeletedAt 如果模型有DeletedAt字段，调用Delete删除该记录时，将会设置DeletedAt字段为当前时间，而不是直接将记录从数据库中删除。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:12:6","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"GORM–CRUD 小tip，在每一条语句中加入.Debug()可以打印出该条命令实际执行的SQL语句，便于我们理解、调试。db.Debug().Find(\u0026users) ","date":"2023-05-21","objectID":"/posts/gin/gin01/:13:0","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"创建 创建记录 首先定义模型： type User struct { ID int64 Name string Age int64 } 使用使用NewRecord()查询主键是否存在，主键为空使用Create()创建记录： user := User{Name: \"q1mi\", Age: 18} db.NewRecord(user) // 主键为空返回`true` db.Create(\u0026user) // 创建user db.NewRecord(user) // 创建`user`后返回`false` 默认值 可以通过 tag 定义字段的默认值，比如： type User struct { ID int64 Name string `gorm:\"default:'nzr'\"` Age int64 } **注意：**通过tag定义字段的默认值，在创建记录时候生成的 SQL 语句会排除没有值或值为零值的字段。 在将记录插入到数据库后，Gorm会从数据库加载那些字段的默认值。 举个例子： var user = User{Name: \"\", Age: 18} db.Create(\u0026user) 上面代码实际执行的SQL语句是INSERT INTO users(\"age\") values('99');，排除了零值字段Name，而在数据库中这一条数据会使用设置的默认值nzr作为Name字段的值。 **注意：**所有字段的零值, 比如0, \"\",false或者其它零值，都不会保存到数据库内，但会使用他们的默认值。 如果你想避免这种情况，可以考虑使用指针或实现 Scanner/Valuer接口，比如： 使用指针方式实现零值存入数据库 // 使用指针 type User struct { ID int64 // 这里改为了指针 Name *string `gorm:\"default:'nzr'\"` Age int64 } user := User{Name: new(string), Age: 18))} db.Create(\u0026user) // 此时数据库中该条记录name字段的值就是'' 使用Scanner/Valuer接口方式实现零值存入数据库 // 使用 Scanner/Valuer type User struct { ID int64 Name sql.NullString `gorm:\"default:'nzr'\"` // sql.NullString 实现了Scanner/Valuer接口 Age int64 } user := User{Name: sql.NullString{\"\", true}, Age:18} db.Create(\u0026user) // 此时数据库中该条记录name字段的值就是'' 扩展创建选项 例如PostgreSQL数据库中可以使用下面的方式实现合并插入, 有则更新, 无则插入。 // 为Instert语句添加扩展SQL选项 db.Set(\"gorm:insert_option\", \"ON CONFLICT\").Create(\u0026product) // INSERT INTO products (name, code) VALUES (\"name\", \"code\") ON CONFLICT; ","date":"2023-05-21","objectID":"/posts/gin/gin01/:13:1","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"查询 一般查询 var user User // 声明模型结构体类型变量user // 根据主键查询第一条记录 db.First(\u0026user) //// SELECT * FROM users ORDER BY id LIMIT 1; // 查询指定的某条记录(仅当主键为整型时可用) db.First(\u0026user, 10) //// SELECT * FROM users WHERE id = 10; // 随机获取一条记录 db.Take(\u0026user) //// SELECT * FROM users LIMIT 1; // 根据主键查询最后一条记录 db.Last(\u0026user) //// SELECT * FROM users ORDER BY id DESC LIMIT 1; // 查询所有的记录 // 这里需要传一个user的切片users,下面所有的user是都是切片 db.Find(\u0026users) //// SELECT * FROM users; Where条件 普通SQL查询 // Get first matched record db.Where(\"name = ?\", \"nzr\").First(\u0026user) //// SELECT * FROM users WHERE name = 'nzr' limit 1; // Get all matched records db.Where(\"name = ?\", \"nzr\").Find(\u0026users) //// SELECT * FROM users WHERE name = 'nzr'; // \u003c\u003e 不等于 db.Where(\"name \u003c\u003e ?\", \"nzr\").Find(\u0026users) //// SELECT * FROM users WHERE name \u003c\u003e 'nzr'; // IN 在一个范围里的 db.Where(\"name IN (?)\", []string{\"nzr\", \"nzr 2\"}).Find(\u0026users) //// SELECT * FROM users WHERE name in ('nzr','nzr 2'); // LIKE 模糊的 db.Where(\"name LIKE ?\", \"%jin%\").Find(\u0026users) //// SELECT * FROM users WHERE name LIKE '%jin%'; // AND 连接两个条件 db.Where(\"name = ? AND age \u003e= ?\", \"nzr\", \"22\").Find(\u0026users) //// SELECT * FROM users WHERE name = 'nzr' AND age \u003e= 22; // Time 根据时间选择的 db.Where(\"updated_at \u003e ?\", lastWeek).Find(\u0026users) //// SELECT * FROM users WHERE updated_at \u003e '2000-01-01 00:00:00'; // BETWEEN 也是在时间区间选择的 db.Where(\"created_at BETWEEN ? AND ?\", lastWeek, today).Find(\u0026users) //// SELECT * FROM users WHERE created_at BETWEEN '2000-01-01 00:00:00' AND '2000-01-08 00:00:00'; Struct\u0026Map查询 // Struct db.Where(\u0026User{Name: \"nzr\", Age: 20}).First(\u0026user) //// SELECT * FROM users WHERE name = \"nzr\" AND age = 20 LIMIT 1; // Map db.Where(map[string]interface{}{\"name\": \"nzr\", \"age\": 20}).Find(\u0026users) //// SELECT * FROM users WHERE name = \"nzr\" AND age = 20; // 主键的切片 在这个主键的范围里面找 db.Where([]int64{20, 21, 22}).Find(\u0026users) //// SELECT * FROM users WHERE id IN (20, 21, 22); **提示：**当通过结构体进行查询时，GORM将会只通过非零值字段查询，这意味着如果你的字段值为0，''，false或者其他零值时，将不会被用于构建查询条件，例如： db.Where(\u0026User{Name: \"nzr\", Age: 0}).Find(\u0026users) //// SELECT * FROM users WHERE name = \"nzr\"; 同样地，你可以使用指针或实现 Scanner/Valuer 接口来避免这个问题。 // 使用指针 type User struct { gorm.Model Name string Age *int } // 使用 Scanner/Valuer type User struct { gorm.Model Name string Age sql.NullInt64 // sql.NullInt64 实现了 Scanner/Valuer 接口 } Not条件 db.Not(\"name\", \"nzr\").First(\u0026user) //// SELECT * FROM users WHERE name \u003c\u003e \"nzr\" LIMIT 1; // Not In db.Not(\"name\", []string{\"nzr\", \"nzr 2\"}).Find(\u0026users) //// SELECT * FROM users WHERE name NOT IN (\"nzr\", \"nzr 2\"); // Not In slice of primary keys db.Not([]int64{1,2,3}).First(\u0026user) //// SELECT * FROM users WHERE id NOT IN (1,2,3); db.Not([]int64{}).First(\u0026user) //// SELECT * FROM users; // Plain SQL db.Not(\"name = ?\", \"nzr\").First(\u0026user) //// SELECT * FROM users WHERE NOT(name = \"nzr\"); // Struct db.Not(User{Name: \"nzr\"}).First(\u0026user) //// SELECT * FROM users WHERE name \u003c\u003e \"nzr\"; Or条件 db.Where(\"role = ?\", \"admin\").Or(\"role = ?\", \"super_admin\").Find(\u0026users) //// SELECT * FROM users WHERE role = 'admin' OR role = 'super_admin'; // Struct db.Where(\"name = 'nzr'\").Or(User{Name: \"nzr 2\"}).Find(\u0026users) //// SELECT * FROM users WHERE name = 'nzr' OR name = 'nzr 2'; // Map db.Where(\"name = 'nzr'\").Or(map[string]interface{}{\"name\": \"nzr 2\"}).Find(\u0026users) //// SELECT * FROM users WHERE name = 'nzr' OR name = 'nzr 2'; 内联条件 作用与Where查询类似，当内联条件与多个立即执行方法一起使用时, 内联条件不会传递给后面的立即执行方法。 立即执行方法：Immediate methods ，立即执行方法是指那些会立即生成SQL语句并发送到数据库的方法, 他们一般是CRUD方法，比如：Create, First, Find, Take, Save, UpdateXXX, Delete, Scan, Row, Rows… // 根据主键获取记录 (只适用于整形主键) db.First(\u0026user, 23) //// SELECT * FROM users WHERE id = 23 LIMIT 1; // 根据主键获取记录, 如果它是一个非整形主键 db.First(\u0026user, \"id = ?\", \"string_primary_key\") //// SELECT * FROM users WHERE id = 'string_primary_key' LIMIT 1; // Plain SQL db.Find(\u0026user, \"name = ?\", \"nzr\") //// SELECT * FROM users WHERE name = \"nzr\"; db.Find(\u0026users, \"name \u003c\u003e ? AND age \u003e ?\", \"nzr\", 20) //// SELECT * FROM users WHERE name \u003c\u003e \"nzr\" AND age \u003e 20; // Struct db.Find(\u0026users, User{Age: 20}) //// SELECT * FROM u","date":"2023-05-21","objectID":"/posts/gin/gin01/:13:2","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"链式操作相关（重点） 链式操作 Method Chaining，Gorm 实现了链式操作接口，所以你可以把代码写成这样： // 创建一个查询 tx := db.Where(\"name = ?\", \"nzr\") // 添加更多条件 if someCondition { tx = tx.Where(\"age = ?\", 20) } else { tx = tx.Where(\"age = ?\", 30) } if yetAnotherCondition { tx = tx.Where(\"active = ?\", 1) } 在调用立即执行方法前不会生成Query语句，借助这个特性你可以创建一个函数来处理一些通用逻辑。 立即执行方法 Immediate methods ，立即执行方法是指那些会立即生成SQL语句并发送到数据库的方法, 他们一般是CRUD方法，比如： Create, First, Find, Take, Save, UpdateXXX, Delete, Scan, Row, Rows… 这有一个基于上面链式方法代码的立即执行方法的例子： tx.Find(\u0026user) 生成的SQL语句如下： SELECT * FROM users where name = 'nzr' AND age = 30 AND active = 1; 范围 Scopes，Scope是建立在链式操作的基础之上的。 基于它，你可以抽取一些通用逻辑，写出更多可重用的函数库。 func AmountGreaterThan1000(db *gorm.DB) *gorm.DB { return db.Where(\"amount \u003e ?\", 1000) } func PaidWithCreditCard(db *gorm.DB) *gorm.DB { return db.Where(\"pay_mode_sign = ?\", \"C\") } func PaidWithCod(db *gorm.DB) *gorm.DB { return db.Where(\"pay_mode_sign = ?\", \"C\") } func OrderStatus(status []string) func (db *gorm.DB) *gorm.DB { return func (db *gorm.DB) *gorm.DB { return db.Scopes(AmountGreaterThan1000).Where(\"status IN (?)\", status) } } db.Scopes(AmountGreaterThan1000, PaidWithCreditCard).Find(\u0026orders) // 查找所有金额大于 1000 的信用卡订单 db.Scopes(AmountGreaterThan1000, PaidWithCod).Find(\u0026orders) // 查找所有金额大于 1000 的 COD 订单 db.Scopes(AmountGreaterThan1000, OrderStatus([]string{\"paid\", \"shipped\"})).Find(\u0026orders) // 查找所有金额大于 1000 且已付款或者已发货的订单 多个立即执行方法 Multiple Immediate Methods，在 GORM 中使用多个立即执行方法时，后一个立即执行方法会复用前一个立即执行方法的条件 (不包括内联条件) 。 db.Where(\"name LIKE ?\", \"nzr%\").Find(\u0026users, \"id IN (?)\", []int{1, 2, 3}).Count(\u0026count) 生成的 Sql SELECT * FROM users WHERE name LIKE 'nzr%' AND id IN (1, 2, 3) SELECT count(*) FROM users WHERE name LIKE 'nzr%' ","date":"2023-05-21","objectID":"/posts/gin/gin01/:13:3","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"更新 更新所有字段 Save()默认会更新该对象的所有字段，即使你没有赋值。 db.First(\u0026user) user.Name = \"nzr\" user.Age = 99 db.Save(\u0026user) //// UPDATE `users` SET `created_at` = '2020-02-16 12:52:20', `updated_at` = '2020-02-16 12:54:55', `deleted_at` = NULL, `name` = 'nzr', `age` = 99, `active` = true WHERE `users`.`deleted_at` IS NULL AND `users`.`id` = 1 更新修改字段 如果你只希望更新指定字段，可以使用Update或者Updates // 更新单个属性，如果它有变化 db.Model(\u0026user).Update(\"name\", \"hello\") //// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111; // 根据给定的条件更新单个属性 db.Model(\u0026user).Where(\"active = ?\", true).Update(\"name\", \"hello\") //// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111 AND active=true; // 使用 map 更新多个属性，只会更新其中有变化的属性 db.Model(\u0026user).Updates(map[string]interface{}{\"name\": \"hello\", \"age\": 18, \"active\": false}) //// UPDATE users SET name='hello', age=18, active=false, updated_at='2013-11-17 21:34:10' WHERE id=111; // 使用 struct 更新多个属性，只会更新其中有变化且为非零值的字段 db.Model(\u0026user).Updates(User{Name: \"hello\", Age: 18}) //// UPDATE users SET name='hello', age=18, updated_at = '2013-11-17 21:34:10' WHERE id = 111; // 警告：当使用 struct 更新时，GORM只会更新那些非零值的字段 // 对于下面的操作，不会发生任何更新，\"\", 0, false 都是其类型的零值 db.Model(\u0026user).Updates(User{Name: \"\", Age: 0, Active: false}) 更新选定字段 如果你想更新或忽略某些字段，你可以使用 Select，Omit db.Model(\u0026user).Select(\"name\").Updates(map[string]interface{}{\"name\": \"hello\", \"age\": 18, \"active\": false}) //// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111; db.Model(\u0026user).Omit(\"name\").Updates(map[string]interface{}{\"name\": \"hello\", \"age\": 18, \"active\": false}) //// UPDATE users SET age=18, active=false, updated_at='2013-11-17 21:34:10' WHERE id=111; 无Hooks更新 上面的更新操作会自动运行 model 的 BeforeUpdate, AfterUpdate 方法，更新 UpdatedAt 时间戳, 在更新时保存其 Associations, 如果你不想调用这些方法，你可以使用 UpdateColumn， UpdateColumns // 更新单个属性，类似于 `Update` db.Model(\u0026user).UpdateColumn(\"name\", \"hello\") //// UPDATE users SET name='hello' WHERE id = 111; // 更新多个属性，类似于 `Updates` db.Model(\u0026user).UpdateColumns(User{Name: \"hello\", Age: 18}) //// UPDATE users SET name='hello', age=18 WHERE id = 111; 批量更新 批量更新时Hooks（钩子函数）不会运行。 db.Table(\"users\").Where(\"id IN (?)\", []int{10, 11}).Updates(map[string]interface{}{\"name\": \"hello\", \"age\": 18}) //// UPDATE users SET name='hello', age=18 WHERE id IN (10, 11); // 使用 struct 更新时，只会更新非零值字段，若想更新所有字段，请使用map[string]interface{} db.Model(User{}).Updates(User{Name: \"hello\", Age: 18}) //// UPDATE users SET name='hello', age=18; // 使用 `RowsAffected` 获取更新记录总数 db.Model(User{}).Updates(User{Name: \"hello\", Age: 18}).RowsAffected 使用SQL表达式更新 先查询表中的第一条数据保存至user变量。 var user User db.First(\u0026user) db.Model(\u0026user).Update(\"age\", gorm.Expr(\"age * ? + ?\", 2, 100)) //// UPDATE `users` SET `age` = age * 2 + 100, `updated_at` = '2020-02-16 13:10:20' WHERE `users`.`id` = 1; db.Model(\u0026user).Updates(map[string]interface{}{\"age\": gorm.Expr(\"age * ? + ?\", 2, 100)}) //// UPDATE \"users\" SET \"age\" = age * '2' + '100', \"updated_at\" = '2020-02-16 13:05:51' WHERE `users`.`id` = 1; db.Model(\u0026user).UpdateColumn(\"age\", gorm.Expr(\"age - ?\", 1)) //// UPDATE \"users\" SET \"age\" = age - 1 WHERE \"id\" = '1'; db.Model(\u0026user).Where(\"age \u003e 10\").UpdateColumn(\"age\", gorm.Expr(\"age - ?\", 1)) //// UPDATE \"users\" SET \"age\" = age - 1 WHERE \"id\" = '1' AND quantity \u003e 10; 修改Hooks中的值 如果你想修改 BeforeUpdate, BeforeSave 等 Hooks 中更新的值，你可以使用 scope.SetColumn, 例如： func (user *User) BeforeSave(scope *gorm.Scope) (err error) { if pw, err := bcrypt.GenerateFromPassword(user.Password, 0); err == nil { scope.SetColumn(\"EncryptedPassword\", pw) } } 其他更新选项 / 为 update SQL 添加其它的 SQL db.Model(\u0026user).Set(\"gorm:update_option\", \"OPTION (OPTIMIZE FOR UNKNOWN)\").Update(\"name\", \"hello\") //// UPDATE users SET name='hello', updated_at = '2013-11-17 21:34:10' WHERE id=111 OPTION (OPTIMIZE FOR UNKNOWN); ","date":"2023-05-21","objectID":"/posts/gin/gin01/:13:4","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"删除 删除记录 警告 删除记录时，请确保主键字段有值，GORM 会通过主键去删除记录，如果主键为空，GORM 会删除该 model 的所有记录。 // 删除现有记录 db.Delete(\u0026email) //// DELETE from emails where id=10; // 为删除 SQL 添加额外的 SQL 操作 db.Set(\"gorm:delete_option\", \"OPTION (OPTIMIZE FOR UNKNOWN)\").Delete(\u0026email) //// DELETE from emails where id=10 OPTION (OPTIMIZE FOR UNKNOWN); 批量删除 删除全部匹配的记录 db.Where(\"email LIKE ?\", \"%nzr%\").Delete(Email{}) //// DELETE from emails where email LIKE \"%nzr%\"; db.Delete(Email{}, \"email LIKE ?\", \"%nzr%\") //// DELETE from emails where email LIKE \"%nzr%\"; 软删除(重点理解) 如果一个 model 有 DeletedAt 字段，他将自动获得软删除的功能！ 当调用 Delete 方法时， 记录不会真正的从数据库中被删除， 只会将DeletedAt 字段的值会被设置为当前时间 db.Delete(\u0026user) //// UPDATE users SET deleted_at=\"2013-10-29 10:23\" WHERE id = 111; // 批量删除 db.Where(\"age = ?\", 20).Delete(\u0026User{}) //// UPDATE users SET deleted_at=\"2013-10-29 10:23\" WHERE age = 20; // 查询记录时会忽略被软删除的记录 db.Where(\"age = 20\").Find(\u0026user) //// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL; // Unscoped 方法可以查询被软删除的记录 db.Unscoped().Where(\"age = 20\").Find(\u0026users) //// SELECT * FROM users WHERE age = 20; 物理删除 // Unscoped 方法可以物理删除记录 db.Unscoped().Delete(\u0026order) //// DELETE FROM orders WHERE id=10; ","date":"2023-05-21","objectID":"/posts/gin/gin01/:13:5","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"企业级项目结构拆分 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:14:0","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"MVC模式 MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。 Model（模型） - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。 View（视图） - 视图代表模型包含的数据的可视化。 Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:14:1","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"结构划分例子 MyProject controller ( 路由中的func) dao （连接数据库、关闭数据库） logic （如果业务逻辑比较复杂的话，这个logic里面放需要处理的业务逻辑，由controller调用，logic再调用models中的增删改查等操作） models （模型、对象，如数据中存放的表，以及增删改查的操作） routers （存放路由、路由组 func SetupRouter() *gin.Engine{}） static （静态文件css、js） templates（模板文件index.html，图标） go.mod main.go main.go routers/routers.go models/todo.go dao/mysql.go controller/controller.go ","date":"2023-05-21","objectID":"/posts/gin/gin01/:14:2","tags":["Go","Gin","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["BLOG"],"content":"搭建个人博客的简易流程","date":"2023-05-19","objectID":"/posts/blog-quickstart/","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":["BLOG"],"content":"安装环境与框架 本博客使用的是Hugo框架，Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 Go Go官网下载地址：https://golang.org/dl/ Go官方镜像站：https://golang.google.cn/dl/ Hugo 参照官方文档的installation，hugo的安装方式有多种。我采用的方式是，在GitHub上下载压缩包，解压到本地，文件组织目录如下： bin hugo.exe LICENSE README.md MySite(建站) 建站 hugo new site MySite cd MySite git init // 将https://github.com/theNewDynamic/gohugo-theme-ananke更换为自己喜欢的主题，主题在https://themes.gohugo.io/ themes/ananke 是在themes文件夹，创建ananke主题文件 git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke 选好主题之后，需要将ananke文件夹下的config.toml复制到站的根目录下进行覆盖。修改或添加如下基础内容。 baseURL = 'http://Lizhe1228.github.io/' # 为下一步部署到github做准备 languageCode = 'zh-CN' title = 'My New Hugo Site' 撰写文章 hugo new post/my-first-post.md # \"my-first-post.md\" 是新建文章的文件名。 post是根目录下content里会自动生成的文件夹。 启动启动 Hugo server。 默认在http://localhost:1313预览，此时对文章的修改可实时渲染到页面上。 hugo server -D # -D 是指草稿模式的文章也会渲染到页面上 注意，若再次对配置文件等进行修改，需要重新执行hugo server -D。 发布网站，形成静态文件。 hugo。执行完此条命令后，会在根目录下生成一个public文件夹。注意如果还有草稿模式的文章，使用hugo -D这条命令 ","date":"2023-05-19","objectID":"/posts/blog-quickstart/:1:0","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":["BLOG"],"content":"部署到GitHub 在GitHub上创建一个 username.github.io 的仓库（username为自己的GitHub名字） cd public git init # 初始化 git remote add origin https://github.com/你的用户名/你的用户名.github.io.git # 和远程仓库关联 git status git add . git commit -m \"Add a new post\" git push -f origin master 此时我们登录username.github.io就可以看到自己的博客了。 注意，如果对文章内容进行了修改，或者添加了新的内容，需要重新进行hugo操作，生成新的puplic文件，再次在public文件夹下执行git status、git add .、git commit -m \"Add a new post\"、git push -f origin master指令，才可以更新远程仓库，更新博客。 ","date":"2023-05-19","objectID":"/posts/blog-quickstart/:2:0","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":["BLOG"],"content":"其他事项 ","date":"2023-05-19","objectID":"/posts/blog-quickstart/:3:0","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":["BLOG"],"content":"关于解决git push慢的方法 方法一：修改host文件 修改C:\\Windows\\System32\\drivers\\etc\\hosts文件，添加如下配置。 140.82.114.4 github.com 185.199.108.153 assets-cdn.github.com 151.101.1.194 github.global.ssl.fastly.net 以上三个ip在https://www.ipaddress.com/可以查到，可能会有更新。 方法二：git 设置 socks5 代理 用git内置代理，直接走系统中运行的代理工具中转，比如，你的 SS 本地端口是 1080，那么可以如下方式走代理： git config --global http.proxy socks5://127.0.0.1:1080 git config --global https.proxy socks5://127.0.0.1:1080 取消代理的方式： git config --global http.proxy \"\" git config --global https.proxy \"\" ","date":"2023-05-19","objectID":"/posts/blog-quickstart/:3:1","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":["BLOG"],"content":"关于主题 Fixlit 官方文档、GitHub 代码行号+复制 在配置文件中添加如下内容： [markup] [markup.highlight] codeFences = true guessSyntax = true hl_Lines = \"\" lineNoStart = 1 lineNos = true lineNumbersInTable = false noClasses = true style = \"github\" tabWidth = 4 无法正确解析md中如font color等内容 [markup.goldmark] [markup.goldmark.extensions] definitionList = true footnote = true linkify = true strikethrough = true table = true taskList = true typographer = true [markup.goldmark.renderer] # 是否在文档中直接使用 HTML 标签 unsafe = true toc目录中无法正确展示2级以上标题 # 目录设置 [markup.tableOfContents] # 几级标题到几级标题 startLevel = 2 endLevel = 6 ","date":"2023-05-19","objectID":"/posts/blog-quickstart/:3:2","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":["BLOG"],"content":"一键push 为了避免每次更新博客后都需要输入hugo -D，cd public，git等命令，可以在根目录下配置一个bat脚本文件push.bat，每次push的时候在cmd中输入push即可。 hugo -D cd public git status git add . git commit -m \"update %date%,%time%\" git push -f origin master echo success pause ","date":"2023-05-19","objectID":"/posts/blog-quickstart/:3:3","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":["BLOG"],"content":"使用图床存储图片 使用PicGo + Typora + 腾讯云COS 配置腾讯云COS 使用腾讯云的对象存储功能，创建一个自己的存储桶 腾讯云中新建秘钥 访问秘钥 配置PicGo 设定SecretKey：腾讯云的SecretId 设定SecretKey：腾讯云的SecretKey 设定Bucket：填写自己的bucket名称，就是新建存储桶时填写的名称 设定APPid：创建密钥时的APPID 设定存储区域：新建存储桶时的所属地域，例如ap-shanghai 设定存储路径：上传的文件存储在什么路径下，例如img/ 剩下两个没有就不填 设置防盗链 Referer中添加博客地址(username.github.io)和本地端口(localhost:1313)。 配置Typora ","date":"2023-05-19","objectID":"/posts/blog-quickstart/:3:4","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":null,"content":"aaaa ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"\r","date":"0001-01-01","objectID":"/friends/:0:0","tags":null,"title":"Friends","uri":"/friends/"},{"categories":null,"content":"Base info - nickname: Lruihao avatar: https://lruihao.cn/images/avatar.jpg url: https://lruihao.cn description: Lruihao's Note ","date":"0001-01-01","objectID":"/friends/:1:0","tags":null,"title":"Friends","uri":"/friends/"},{"categories":null,"content":"Friendly Reminder Notice\rIf you want to exchange link, please leave a comment in the above format. (personal non-commercial blogs / websites only)  Website failure, stop maintenance and improper content may be unlinked! Those websites that do not respect other people’s labor achievements, reprint without source, or malicious acts, please do not come to exchange. ","date":"0001-01-01","objectID":"/friends/:2:0","tags":null,"title":"Friends","uri":"/friends/"}]