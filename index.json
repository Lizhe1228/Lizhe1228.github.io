[{"categories":["Git"],"content":"Git基础指令 git -v # 查看版本 git config --global user.name \"Lizhe1228\" # 基本配置 git config --global user.email \"2181426542@qq.com\" ","date":"2023-05-22","objectID":"/posts/git/git/:1:0","tags":["Git"],"title":"Git","uri":"/posts/git/git/"},{"categories":["Go每日一练"],"content":"题目来源于 https://www.topgoer.cn/docs/gomianshiti/mianshiti","date":"2023-05-22","objectID":"/posts/go/day1-35/","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"题目来源于 https://www.topgoer.cn/docs/gomianshiti/mianshiti ","date":"2023-05-22","objectID":"/posts/go/day1-35/:0:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day1 下面这段代码输出的内容是什么? package main import ( \"fmt\" ) func main() { defer_call() } func defer_call() { defer func() { fmt.Println(\"打印前\") }() defer func() { fmt.Println(\"打印中\") }() defer func() { fmt.Println(\"打印后\") }() panic(\"触发异常\") } 答案： 打印后 打印中 打印前 panic: 触发异常 解析： defer 的执行顺序是后进先出。当出现 panic 语句的时候，会先按照 defer 的后进先出的顺序执行，最后才会执行panic。 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:1:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day2 下面这段代码输出什么，说明原因。 func main() { slice := []int{0,1,2,3} m := make(map[int]*int) for key,val := range slice { m[key] = \u0026val } for k,v := range m { fmt.Println(k,\"-\u003e\",*v) } } 答案： 0 -\u003e 3 1 -\u003e 3 2 -\u003e 3 3 -\u003e 3 解析： 这是新手常会犯的错误写法，for range 循环的时候会创建每个元素的副本，而不是元素的引用，所以 m[key] = \u0026val 取的都是变量 val 的地址，所以最后 map 中的所有元素的值都是变量 val 的地址，因为最后 val 被赋值为3，所有输出都是3. 正确写法： func main() { slice := []int{0,1,2,3} m := make(map[int]*int) for key,val := range slice { // 创建一个临时变量value，每次range的时候这里都是一个新的 value := val m[key] = \u0026value } for k,v := range m { fmt.Println(k,\"===\u003e\",*v) } } ","date":"2023-05-22","objectID":"/posts/go/day1-35/:2:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day3 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:3:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day4 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:4:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day5 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:5:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day6 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:6:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day7 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:7:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day8 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:8:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day9 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:9:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day10 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:10:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day11 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:11:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day12 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:12:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day13 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:13:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day14 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:14:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day15 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:15:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day16 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:16:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day17 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:17:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day18 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:18:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day19 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:19:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day20 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:20:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day21 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:21:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day22 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:22:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day23 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:23:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day24 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:24:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day25 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:25:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day26 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:26:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day27 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:27:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day28 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:28:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day29 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:29:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day30 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:30:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day31 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:31:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day32 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:32:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day33 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:33:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day34 ","date":"2023-05-22","objectID":"/posts/go/day1-35/:34:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["Go每日一练"],"content":"Day35","date":"2023-05-22","objectID":"/posts/go/day1-35/:35:0","tags":["go","面试"],"title":"Go Exercises(Day1-35)","uri":"/posts/go/day1-35/"},{"categories":["docker"],"content":"DockerFile是什么 简单来讲，当我们想创建自己的一个镜像，添加新的功能时，用原来的方法需要一次次地执行docker commit，现在我们可以使用Dockerfile一次性地提交全部修改。 Dockerfile是用来构建Docker镜像的本地文件，是由一条条构建镜像所需的指令和参数构成的脚本。 Dockerfile构建镜像的步骤 编写Dockerfile文件 dokcer build 命令构建镜像 docker run依照镜像运行容器实例 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:1:0","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"DockerFile构建过程解析 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:2:0","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"Dockerfile内容基础知识 每条保留字指令都必须为大写字母且后面要跟随至少一个参数 指令按照从上到下，顺序执行 #表示注释 每条指令都会创建一个新的镜像层并对镜像进行提交 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:2:1","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"Docker执行Dockerfile的大致流程 docker从基础镜像运行一个容器 执行一条指令并对容器做出修改 执行类似docker commit的操作提交一个新的镜像层 docker再基于刚提交的镜像运行一个新容器 执行dockerfile中的下一条指令直到所有指令都执行完成 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:2:2","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"小总结 从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段， Dockerfile是软件的原材料 Docerk镜像是软件的交付品 Docker容器则可以人为是软件镜像的交付标准，也即依照镜像运行的容器实例 Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合理充当Docker体系的基石。 Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程（当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制）等等； Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，运行Docker镜像时会真正开始提供服务； Docker容器，容器是直接提供服务的。 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:2:3","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"DockerFile常用保留字 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:0","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"参考tomcat8的dockerfile入门 https://github.com/docker-library/tomcat ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:1","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"FROM FROM 基础镜像 当前镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:2","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"MAINTAINER 镜像维护者的姓名和邮箱地址 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:3","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"RUN 容器构建时需要运行的命令，有两种格式（shell、exec），是在docker build时运行的。 shell格式 # \u003c命令行命令\u003e等同于，在终端操作的shell命令 RUN \u003c命令行命令\u003e exec格式 RUN [\"可执行文件\", \"参数1\", \"参数2\"] # 例如： # RUN [\"./test.php\", \"dev\", \"offline\"]等价与 RUN ./test.php dev offline ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:4","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"EXPOSE 当前容器对外暴露出的端口 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:5","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"WORKDIR 指定在创建容器后，终端默认登录的进来工作目录，一个落脚点 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:6","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"USER 指定该镜像以什么样的用户去执行，如果都不指定，默认是root ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:7","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"ENV 用来在构建镜像过程中设置环境变量 ENV MY_PATH /usr/mytest 这个环境变量可以在候选的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样； 也可以再其他指令中直接使用这些环境变量 比如：WORKDIR $MY_PATH ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:8","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"ADD 将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:9","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"COPY 类似ADD，拷贝文件和目录到镜像中。 将从构建上下文目录中\u003c源路径\u003e的文件/目录复制到新的一层的镜像内的\u003c目标路径\u003e位置 COPY src dest COPY [“src”, “dest”] \u003csrc源路径\u003e：源文件或者源目录 \u003cdest目标路径\u003e：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:10","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"VOLUME 容器数据卷，用于数据保存和持久化工作 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:11","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"CMD 指定容器启动后要干的事情： CMD指令的格式和RUN类似，也是两种格式： shell 格式：CMD \u003c命令\u003e exec 格式：CMD [\"可执行文件\",\"参数1\",\"参数2\"] 参数列表格式：CMD [\"参数1\", \"参数2\"...]在指定了ENTRYPOINT指令后，用CMD指定具体的参数 注意 Dockerfile中可以有多个CDM指令，但只有最后一个生效，CMD会被docker run之后的参数替换。 和RUN命令的区别：CMD是在docker run时运行，RUN是在docker build时运行。 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:12","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"ENTRYPOINT 也是用来指定一个容器启动时要运行的命令，类似于CMD指令，但是ENTRYPOINT不会被docker run 后面的命令覆盖，而且这些命令行参数会被当作参数送给ENTRYPOINT指令指定的程序。 ENTRYPOINT [\"\u003cexecuteable\u003e\", \"\u003cparam1\u003e\", \"\u003cparam2\u003e\",...] ENTRYPOINT 可以和CMD一起使用，一般是变参才会使用CMD，这里的CMD等于是在给ENTRYPOINT 传参。当指定了ENTRYPOINT 后，CMD的含义就发生了变化，不再是直接运行其命令而是将CMD的内容作为参数传递给ENTRYPOINT 指令。 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:13","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"小总结 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:3:14","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"案例 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:4:0","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"自定义镜像centosjava8 要求 Centos镜像具备vim+ifconfig+jdk jdk下载地址 https://www.oracle.com/java/technologies/downloads/或 https://mirrors.yangxingzhen.com/jdk/ 编写 mkdir /myfile 创建文件夹，在文件夹中下载jdk的tar.gz压缩包，并编写Dockerfile文件 vim Dockerfile FROM centos # 基础镜像，当前新镜像是基于那个镜像 MAINTAINER Lizhe\u003c2181426542@qq.com\u003e # 指定镜像维护的作者和邮箱 ENV MYPATH /usr/local WORKDIR $MYPATH # 安装vim编辑器 RUN yum -y install vim # 安装ifconfig命令查看网络ip RUN yum -y install net-tools # 安装java8以及lib库 RUN yum -y install glibc.i686 RUN mkdir /usr/local/java # ADD 是相对路径jar，把jdk压缩包添加到容器中，安装包必须要和Dockerfile文件在同一位置 ADD jdk-8u171-linux-x64.tar.gz/usr/local/java/ # 配置java环境变量 ENV JAVA_HOME /usr/local/java/jdk1.8.0_171 ENV JRE_HOME $JAVA_HOME/jre ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH ENV PATH $JAVA_HOME/bin:$PATH EXPOSE 80 # 这里的三个CMD好像有问题，会有覆盖的情况 CMD echo $MYPATH CMD echo \"success-------ok\" CMD /bin/bash 构建 docker build -t 新镜像名字:TAG . # 注意，TAG后面有个空格，有个点，TAG是版本号 在本案例中：docker build -t centosjava8:1.5 . 这时我们再输入docker images，就会看到有centosjava8这个新镜像 运行 docker run -it centosjava8:1.5 执行ifconfig、java version检查 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:4:1","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"虚悬镜像 虚悬镜像是什么？ 构建或删除时出现错误，导致仓库名、标签都是none的镜像，俗称dangling image。当我们发现虚悬镜像时，要记得删除，防止有风险。 用Dockerfile写一个虚悬镜像 vim Dockerfile FROM ubuntu CMD echo 'action is success' docker build . # 注意有一个点 查看虚悬镜像 docker images会看到一个仓库和标签都名为\u003cnone\u003e的镜像 docker image ls -f dangling=true # 查看所有虚悬镜像 删除虚悬镜像 docker image prune ","date":"2023-05-22","objectID":"/posts/docker/docker04/:4:2","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["docker"],"content":"小总结 ","date":"2023-05-22","objectID":"/posts/docker/docker04/:5:0","tags":["docker","云原生"],"title":"DockerFie","uri":"/posts/docker/docker04/"},{"categories":["Gin"],"content":"Gin框架的基本使用","date":"2023-05-21","objectID":"/posts/gin/gin01/","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"学习链接： https://learnku.com/articles/69259 https://www.liwenzhou.com/posts/Go/gin/ https://gin-gonic.com/zh-cn/docs/ Gin是一个用Go语言编写的web框架。它是一个类似于martini但拥有更好性能的API框架, 由于使用了httprouter，速度提高了近40倍。Gin是Go世界里最流行的Web框架，Github上有68K+star。 基于httprouter开发的Web框架。 中文文档齐全，简单易用的轻量级框架 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:0:0","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"安装 go get -u github.com/gin-gonic/gin ","date":"2023-05-21","objectID":"/posts/gin/gin01/:1:0","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"简单示例 将下面的代码保存并编译执行，然后使用浏览器打开127.0.0.1:8080/hello就能看到一串JSON字符串。 Get请求，当我们在浏览器中输入127.0.0.1:8080/hello，敲击回车后就相当于向127.0.0.1:8080/hello发送了一次get请求。 package main import ( \"github.com/gin-gonic/gin\" ) func main() { // 创建一个默认的路由引擎 r := gin.Default() // GET：请求方式；/hello：请求的路径 // 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数 r.GET(\"/hello\", func(c *gin.Context) { // c.JSON：返回JSON格式的数据 c.JSON(200, gin.H{ \"message\": \"Hello world!\", }) }) // 启动HTTP服务，默认在0.0.0.0:8080启动服务 r.Run() //r.Run(\":9090\") 则在9090端口进行监听 127.0.0.1:9090/hello } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:2:0","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"RESTful API 目前在前后端分离的架构中，前后端基本都是通过RESTful API来进行交互。我们的Gin框架也支持RESTful API。以下示例展示了gin的 GET 、POST、PUT 、DELETE方法。测试可使用Postman或Apifox工具。 RESTful API简单来说就是同一个URL可以用来处理不同的请求。 func main() { r := gin.Default() r.GET(\"/book\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"GET\", }) }) r.POST(\"/book\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"POST\", }) }) r.PUT(\"/book\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"PUT\", }) }) r.DELETE(\"/book\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"DELETE\", }) }) } 请求方法 URL 含义 GET /book 查询书籍信息 POST /book 创建书籍信息 PUT /book 更新书籍信息 DELETE /book 删除书籍信息 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:3:0","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"Gin渲染 由于现在项目主要使用前后端分类的方法，渲染使用较少，想学习的话可以参考李文周老师的博客中渲染部分的内容 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:4:0","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"路由 路由分组方便对路由进行管理，如相同前缀的路由，我们可以将他们分为一组。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:5:0","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"普通路由 r.GET(\"/book\", func(c *gin.Context) {...}) r.GET(\"/book\", func(c *gin.Context) {...}) r.POST(\"/book\", func(c *gin.Context) {...}) // 匹配所有请求方法的Any r.Any(\"/test\", func(c *gin.Context) {...}) // 为没有配置处理函数的路由添加处理程序 r.NoRoute(func(c *gin.Context) { c.HTML(http.StatusNotFound, \"views/404.html\", nil) }) ","date":"2023-05-21","objectID":"/posts/gin/gin01/:5:1","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"路由分组 我们可以将拥有共同URL前缀的路由划分为一个路由组。习惯性一对{}包裹同组的路由，这只是为了看着清晰，你用不用{}包裹功能上没什么区别。 func main() { r := gin.Default() userGroup := r.Group(\"/user\") { userGroup.GET(\"/index\", func(c *gin.Context) {...}) userGroup.GET(\"/login\", func(c *gin.Context) {...}) userGroup.POST(\"/login\", func(c *gin.Context) {...}) } bookGroup := r.Group(\"/book\") { bookGroup.GET(\"/index\", func(c *gin.Context) {...}) bookGroup.GET(\"/cart\", func(c *gin.Context) {...}) bookGroup.POST(\"/checkout\", func(c *gin.Context) {...}) } r.Run() } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:5:2","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"路由嵌套 bookGroup := r.Group(\"/book\") { bookGroup.GET(\"/index\", func(c *gin.Context) {...}) bookGroup.GET(\"/cart\", func(c *gin.Context) {...}) bookGroup.POST(\"/checkout\", func(c *gin.Context) {...}) // 嵌套路由组 xx := bookGroup.Group(\"xx\") xx.GET(\"/oo\", func(c *gin.Context) {...}) } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:5:3","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"路由原理 Gin框架中的路由使用的是httprouter这个库。其基本原理就是构造一个路由地址的前缀树。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:5:4","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"重定向 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:6:0","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"HTTP重定向 http重定向是指，当访问/test时，页面会跳转到指定界面。 r.GET(\"/test\", func(c *gin.Context) { c.Redirect(http.StatusMovedPermanently, \"https://lizhe1228.github.io/\") }) ","date":"2023-05-21","objectID":"/posts/gin/gin01/:6:1","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"路由重定向 路由重定向是指，当向/test页面发送请求时，实际上会向/test2发送请求。 r.GET(\"/test\", func(c *gin.Context) { // 指定重定向的URL c.Request.URL.Path = \"/test2\" r.HandleContext(c) }) r.GET(\"/test2\", func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{\"hello\": \"world\"}) }) ","date":"2023-05-21","objectID":"/posts/gin/gin01/:6:2","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"参数值的提取 推荐一款插件，美化JSON格式，FeHelper。 为了测试以下的方法，建议使用postman或apifox工具。注意发送请求时选择的方法，以及请求体Body中选择相应的格式如form-data（用来模拟form’表单的提交） 、raw（用来写json等） ","date":"2023-05-21","objectID":"/posts/gin/gin01/:7:0","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"获取querystring参数 querystring指的是URL中?后面携带的参数，参数用\u0026进行分隔，例如：/user/search?username=lz\u0026age=23。 获取请求的querystring参数的方法如下： func main() { //Default返回一个默认的路由引擎 r := gin.Default() r.GET(\"/user/search\", func(c *gin.Context) { // c.DefaultQuery是指若没有查到username，则默认返回值lz username := c.DefaultQuery(\"username\", \"lz\") //username := c.Query(\"username\") address := c.Query(\"address\") //输出json结果给调用方 c.JSON(http.StatusOK, gin.H{ \"message\": \"ok\", \"username\": username, \"address\": address, }) }) r.Run() } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:7:1","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"获取form参数 当前端请求的数据通过form表单提交时，例如向/user/search发送一个POST请求，form表单最简单的例子就是登录时输入的用户名和密码，获取请求数据的方式如下： func main() { //Default返回一个默认的路由引擎 r := gin.Default() r.POST(\"/user/search\", func(c *gin.Context) { // DefaultPostForm取不到值时会返回指定的默认值 //username := c.DefaultPostForm(\"username\", \"小王子\") username := c.PostForm(\"username\") address := c.PostForm(\"address\") // 还有这种返回两个值，第二个值表示是否能拿到数据 // msg, ok := c.GetPostForm() //输出json结果给调用方 c.JSON(http.StatusOK, gin.H{ \"message\": \"ok\", \"username\": username, \"address\": address, }) }) r.Run(\":8080\") } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:7:2","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"获取json参数 当前端请求的数据通过JSON提交时，例如向/json发送一个POST请求，则获取请求参数的方式如下： r.POST(\"/json\", func(c *gin.Context) { // 注意：下面为了举例子方便，暂时忽略了错误处理 b, _ := c.GetRawData() // 从c.Request.Body读取请求数据 // 定义map或结构体 var m map[string]interface{} // 反序列化 _ = json.Unmarshal(b, \u0026m) c.JSON(http.StatusOK, m) }) ","date":"2023-05-21","objectID":"/posts/gin/gin01/:7:3","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"获取path参数 请求的参数通过URL路径传递，例如：/user/search/parameter1/parameter2。 获取请求URL路径中的参数（parameter1和parameter2）的方式如下: func main() { //Default返回一个默认的路由引擎 r := gin.Default() r.GET(\"/user/search/:parm1/:parm2\", func(c *gin.Context) { username := c.Param(\"parm1\") address := c.Param(\"parm2\") //输出json结果给调用方 c.JSON(http.StatusOK, gin.H{ \"message\": \"ok\", \"username\": username, \"address\": address, }) }) r.Run(\":8080\") } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:7:4","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"参数绑定 为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的Content-Type识别请求数据类型并利用反射机制自动提取请求中QueryString、form表单、JSON、XML等参数到结构体中。 下面的示例代码演示了.ShouldBind()强大的功能，它能够基于请求自动提取JSON、form表单和QueryString类型的数据，并把值绑定到指定的结构体对象。 // tag标签 反射机制 // 这里要在地址栏中输入如下的请求（这是querystring的传递方式） // 用form tag才能拿到数据 // 9090/user?username=lz\u0026password=123456 // tag 指的是请求中user pwd字段对应识别到结构体中的Username和Password type UserInfo struct { Username string `form:\"username\" json:\"user\"` Password string `form:\"password\" json:\"pwd\"` } func main() { r := gin.Default() r.GET(\"/user\", func(ctx *gin.Context) { var u UserInfo // 声明一个userinfo类型的U // ShouldBind 把请求里面和username和password相关的 // 内容拷贝给u // shouldbind 可以自动识别各种类型 如JSON、form、querystring // 通过一个shouldbind函数相当于完成了以下的命令 // username := ctx.Query(\"username\") // password := ctx.Query(\"password\") // u := UserInfo{ // Username: username, // Password: password, // } err := ctx.ShouldBind(\u0026u) if err != nil { ctx.JSON(http.StatusBadRequest, gin.H{ \"error\": err.Error(), }) } else { fmt.Printf(\"%#v\\n\", u) ctx.JSON(200, gin.H{ \"message\": \"ok\", }) } }) r.Run(\":9090\") } // Binding from JSON type Login struct { User string `form:\"user\" json:\"user\" binding:\"required\"` Password string `form:\"password\" json:\"password\" binding:\"required\"` } func main() { router := gin.Default() // 绑定JSON的示例 ({\"user\": \"lz\", \"password\": \"123456\"}) router.POST(\"/loginJSON\", func(c *gin.Context) { var login Login if err := c.ShouldBind(\u0026login); err == nil { fmt.Printf(\"login info:%#v\\n\", login) c.JSON(http.StatusOK, gin.H{ \"user\": login.User, \"password\": login.Password, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) // 绑定form表单示例 (user=lz\u0026password=123456) router.POST(\"/loginForm\", func(c *gin.Context) { var login Login // ShouldBind()会根据请求的Content-Type自行选择绑定器 if err := c.ShouldBind(\u0026login); err == nil { c.JSON(http.StatusOK, gin.H{ \"user\": login.User, \"password\": login.Password, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) // 绑定QueryString示例 (/loginQuery?user=lz\u0026password=123456) router.GET(\"/loginForm\", func(c *gin.Context) { var login Login // ShouldBind()会根据请求的Content-Type自行选择绑定器 if err := c.ShouldBind(\u0026login); err == nil { c.JSON(http.StatusOK, gin.H{ \"user\": login.User, \"password\": login.Password, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) // Listen and serve on 0.0.0.0:8080 router.Run(\":8080\") } ShouldBind会按照下面的顺序解析请求中的数据完成绑定： 如果是 GET 请求，只使用 Form 绑定引擎（query）。 如果是 POST 请求，首先检查 content-type 是否为 JSON 或 XML，然后再使用 Form（form-data）。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:7:5","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"Gin实现翻译器 package main import ( \"fmt\" \"net/http\" \"reflect\" \"strings\" \"github.com/gin-gonic/gin/binding\" \"github.com/go-playground/locales/en\" \"github.com/go-playground/locales/zh\" ut \"github.com/go-playground/universal-translator\" \"github.com/go-playground/validator/v10\" enTranslations \"github.com/go-playground/validator/v10/translations/en\" zhTranslations \"github.com/go-playground/validator/v10/translations/zh\" \"github.com/gin-gonic/gin\" ) // 定义一个全局翻译器T var trans ut.Translator //Login登录业务，字段添加tag约束条件 type Login struct { User string `json:\"user\" binding:\"required\"` //必填 Password string `json:\"password\" binding:\"required\"` //必填 } //SignUp注册业务，字段添加tag约束条件 type SignUp struct { Age int `json:\"age\" binding:\"gte=18\"` //gte大于等于 Name string `json:\"name\" binding:\"required\"` //必填 Email string `json:\"email\" binding:\"required,email\"` //必填邮件 Password string `json:\"password\" binding:\"required\"` //必填 RePassword string `json:\"re_password\" binding:\"required,eqfield=Password\"` //RePassword和Password值一致 } //RemoveTopStruct去除以\".\"及其左部分内容 func RemoveTopStruct(fields map[string]string) map[string]string { res := map[string]string{} for field, value := range fields { res[field[strings.Index(field, \".\")+1:]] = value } return res } // InitTrans 初始化翻译器 func InitTrans(locale string) (err error) { // 修改gin框架中的Validator引擎属性，实现自定制 if v, ok := binding.Validator.Engine().(*validator.Validate); ok { //注册一个获取json的自定义方法 v.RegisterTagNameFunc(func(field reflect.StructField) string { name := strings.SplitN(field.Tag.Get(\"json\"), \",\", 2)[0] if name == \"-\" { return \"\" } return name }) zhT := zh.New() // 中文翻译器 enT := en.New() // 英文翻译器 // 第一个参数是备用（fallback）的语言环境 // 后面的参数是应该支持的语言环境（支持多个） // uni := ut.New(zhT, zhT) 也是可以的 uni := ut.New(enT, zhT, enT) // locale 通常取决于 http 请求头的 'Accept-Language' var ok bool // 也可以使用 uni.FindTranslator(...) 传入多个locale进行查找 trans, ok = uni.GetTranslator(locale) if !ok { return fmt.Errorf(\"uni.GetTranslator(%s) failed\", locale) } // 注册翻译器 switch locale { case \"en\": err = enTranslations.RegisterDefaultTranslations(v, trans) case \"zh\": err = zhTranslations.RegisterDefaultTranslations(v, trans) default: err = enTranslations.RegisterDefaultTranslations(v, trans) } return } return } func main() { res := map[string]string{ \"ice_moss.habbit\": \"打球\", \"ice_moss.from\": \"贵州 中国\", } fmt.Println(RemoveTopStruct(res)) //初始化翻译器, 翻译器代码看不懂不要紧，我们只需知道这样使用就行 if err := InitTrans(\"zh\"); err != nil { fmt.Println(\"初始化翻译器失败\", err) return } router := gin.Default() router.POST(\"/loginJSON\", func(c *gin.Context) { var login Login if err := c.ShouldBind(\u0026login); err != nil { fmt.Println(err.Error()) errs, ok := err.(validator.ValidationErrors) if !ok { c.JSON(http.StatusOK, gin.H{ \"msg\": err.Error(), }) } c.JSON(http.StatusInternalServerError, gin.H{ \"error\": errs.Translate(trans), }) return } c.JSON(http.StatusOK, gin.H{ \"msg\": \"验证通过\", }) }) router.POST(\"/signupJSON\", func(c *gin.Context) { var signup SignUp //ShouldBind()对数据进行绑定，解组 if err := c.ShouldBind(\u0026signup); err != nil { fmt.Println(err.Error()) //获取validator.ValidationErrors类型的error errs, ok := err.(validator.ValidationErrors) if !ok { c.JSON(http.StatusOK, gin.H{ \"msg\": err.Error(), }) } //validator.ValidationErrors类型错误则进行翻译 c.JSON(http.StatusInternalServerError, gin.H{ \"error\": RemoveTopStruct(errs.Translate(trans)), }) return } c.JSON(http.StatusOK, gin.H{ \"msg\": \"注册成功\", }) }) router.Run(\":8083\") } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:8:0","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"中间件 Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:9:0","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"定义中间件 Gin中的中间件必须是一个gin.HandlerFunc类型。 中间件的常见形式 func authMiddleware(doCheck bool)gin.Handlerfunc { // 连接数据库 // 或者一些其他准备工作 return func(c *gin.Context) { if doCheck { // 存放具体的逻辑 // 是否登录的判断 // if 是登录用户 // c.Next() // else // c.Abort() } else { c.Next() } } } 通过中间件在上下文定义一些值 // 中间件可以在上下文中设一些kv值，其他中间件可以通过key值取到value c.Set(\"key\", \"value\") name, ok := c.Get(\"key\") name := c.MustGet(\"key\") 记录接口耗时的中间件 // StatCost 是一个统计耗时请求耗时的中间件 func StatCost() gin.HandlerFunc { return func(c *gin.Context) { start := time.Now() c.Set(\"name\", \"lz\") // 可以通过c.Set在请求上下文中设置值，后续的处理函数能够取到该值 // 调用该请求的剩余处理程序 // 这里指的是 r.GET(\"/\", StatCost, func1) 这里的func1 c.Next() // 不调用该请求的剩余处理程序 // c.Abort() //执行完func1后才执行这个 计算耗时 cost := time.Since(start) log.Println(cost) } } 记录响应体的中间件 type bodyLogWriter struct { gin.ResponseWriter // 嵌入gin框架ResponseWriter body *bytes.Buffer // 我们记录用的response } // Write 写入响应体数据 func (w bodyLogWriter) Write(b []byte) (int, error) { w.body.Write(b) // 我们记录一份 return w.ResponseWriter.Write(b) // 真正写入响应 } // ginBodyLogMiddleware 一个记录返回给客户端响应体的中间件 // https://stackoverflow.com/questions/38501325/how-to-log-response-body-in-gin func ginBodyLogMiddleware(c *gin.Context) { blw := \u0026bodyLogWriter{body: bytes.NewBuffer([]byte{}), ResponseWriter: c.Writer} c.Writer = blw // 使用我们自定义的类型替换默认的 c.Next() // 执行业务逻辑 fmt.Println(\"Response body: \" + blw.body.String()) // 事后按需记录返回的响应 } 一个案例 好好理解中间件与c.Next() func indexHandler(c *gin.Context) { fmt.Println(\"index\") c.JSON(http.StatusOK,gin.H{ \"msg\": \"index\", }) } // 定义一个中间件m1:统计请求处理函数的耗时 func m1(c *gin.Context){ fmt.Println(\"m1 in...\") // 计时 start := time.Now() c.Next() // 调用后续的处理函数 // c.Abort() // 阻止调用后续的处理函数 cost := time.Since(start) fmt.Printf(\"cost:%v\\n\",cost) fmt.Println(\"m1 out\") } func m2(c *gin.Context){ fmt.Println(\"m2 in...\") c.Next() // 调用后续的处理函数 fmt.Println(\"m2 out...\") } func main(){ r := gin.Default() r.Use(m1,m2) // 全局注册中间件函数m1,m2 r.GET(\"/index\", indexHandler) r.Run() } 上述代码的执行顺序如下： m1 in… m2 in… index m2 out… cost:187.975μs m1 out… 跨域中间件cors 跨域问题在前后端都可以解决，我曾经做的项目中就遇到了这个问题，这是一个常见的需要进行一下简单处理的问题。 推荐使用社区的https://github.com/gin-contrib/cors 库，一行代码解决前后端分离架构下的跨域问题。 注意： 该中间件需要注册在业务处理函数前面。 这个库支持各种常用的配置项，具体使用方法如下。 package main import ( \"time\" \"github.com/gin-contrib/cors\" \"github.com/gin-gonic/gin\" ) func main() { router := gin.Default() // CORS for https://foo.com and https://github.com origins, allowing: // - PUT and PATCH methods // - Origin header // - Credentials share // - Preflight requests cached for 12 hours router.Use(cors.New(cors.Config{ AllowOrigins: []string{\"https://foo.com\"}, // 允许跨域发来请求的网站 AllowMethods: []string{\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"}, // 允许的请求方法 AllowHeaders: []string{\"Origin\", \"Authorization\", \"Content-Type\"}, ExposeHeaders: []string{\"Content-Length\"}, AllowCredentials: true, AllowOriginFunc: func(origin string) bool { // 自定义过滤源站的方法 return origin == \"https://github.com\" }, MaxAge: 12 * time.Hour, })) router.Run() } 当然你可以简单的像下面的示例代码那样使用默认配置，允许所有的跨域请求。 func main() { router := gin.Default() // same as // config := cors.DefaultConfig() // config.AllowAllOrigins = true // router.Use(cors.New(config)) router.Use(cors.Default()) router.Run() } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:9:1","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"注册中间件 为全局路由注册 func m1(c *gin.Context) { ... } r.GET(\"/1\", m1, func1) r.GET(\"/2\", m1, func2) r.GET(\"/3\", m1, func3) // 为了避免这种每一个请求都写一个m1 可以全局注册中间件m1 r.Use(m1) func main() { // 新建一个没有任何默认中间件的路由 r := gin.New() // 注册一个全局中间件 r.Use(StatCost()) r.GET(\"/test\", func(c *gin.Context) { name := c.MustGet(\"name\").(string) // 从上下文取值 log.Println(name) c.JSON(http.StatusOK, gin.H{ \"message\": \"Hello world!\", }) }) r.Run() } 为某个路由单独注册 // 给/test2路由单独注册中间件（可注册多个） r.GET(\"/test2\", StatCost(), func(c *gin.Context) { name := c.MustGet(\"name\").(string) // 从上下文取值 log.Println(name) c.JSON(http.StatusOK, gin.H{ \"message\": \"Hello world!\", }) }) 为路由组注册中间件 // 写法一 shopGroup := r.Group(\"/shop\", StatCost()) { shopGroup.GET(\"/index\", func(c *gin.Context) {...}) ... } // 写法二 shopGroup := r.Group(\"/shop\") shopGroup.Use(StatCost()) { shopGroup.GET(\"/index\", func(c *gin.Context) {...}) ... } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:9:2","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"中间件注意事项 gin默认中间件 gin.Default()默认使用了Logger和Recovery中间件，其中： Logger中间件将日志写入gin.DefaultWriter，即使配置了GIN_MODE=release。 Recovery中间件会recover任何panic。如果有panic的话，会写入500响应码。 如果不想使用上面两个默认的中间件，可以使用gin.New()新建一个没有任何默认中间件的路由。 gin中间件中使用goroutine 当在中间件或handler中启动新的goroutine时，不能使用原始的上下文（c *gin.Context），必须使用其只读副本（c.Copy()）。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:9:3","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"文件上传 文件上传前端代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003ctitle\u003e上传文件示例\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"\u003e \u003cinput type=\"file\" name=\"f1\"\u003e \u003cinput type=\"submit\" value=\"上传\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 后端代码 单文件上传 func main() { router := gin.Default() // 处理multipart forms提交文件时默认的内存限制是32 MiB // 可以通过下面的方式修改 // router.MaxMultipartMemory = 8 \u003c\u003c 20 // 8 MiB router.POST(\"/upload\", func(c *gin.Context) { // 单个文件 file, err := c.FormFile(\"f1\") if err != nil { c.JSON(http.StatusInternalServerError, gin.H{ \"message\": err.Error(), }) return } log.Println(file.Filename) dst := fmt.Sprintf(\"C:/tmp/%s\", file.Filename) // 上传文件到指定的目录 c.SaveUploadedFile(file, dst) c.JSON(http.StatusOK, gin.H{ \"message\": fmt.Sprintf(\"'%s' uploaded!\", file.Filename), }) }) router.Run() } 多文件上传 func main() { router := gin.Default() // 处理multipart forms提交文件时默认的内存限制是32 MiB // 可以通过下面的方式修改 // router.MaxMultipartMemory = 8 \u003c\u003c 20 // 8 MiB router.POST(\"/upload\", func(c *gin.Context) { // Multipart form form, _ := c.MultipartForm() files := form.File[\"file\"] for index, file := range files { log.Println(file.Filename) dst := fmt.Sprintf(\"C:/tmp/%s_%d\", file.Filename, index) // 上传文件到指定的目录 c.SaveUploadedFile(file, dst) } c.JSON(http.StatusOK, gin.H{ \"message\": fmt.Sprintf(\"%d files uploaded!\", len(files)), }) }) router.Run() } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:10:0","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"GORM ","date":"2023-05-21","objectID":"/posts/gin/gin01/:11:0","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"什么是ORM？ Object Relational Mapping（对象、关系、映射） 对象：程序中的对象/实例，例如Go中的结构体实例 关系：关系数据库，例如MySQL 映射： 数据表\u003c—–\u003e结构体 数据行\u003c—–\u003e结构体实例 字段 \u003c—–\u003e结构体字段 GORM是一个使用Go语言编写的ORM框架。它文档齐全，对开发者友好，支持主流数据库。Github GORM、中文官方网站内含十分齐全的中文文档，有了它你甚至不需要再继续向下阅读本文。 一个简单示例 type UserInfo struct { ID unit Name string Gender string Hobby string } func main(){ u1 := UserInfo{1, \"nzr\", \"男\", \"codeing\"} // 将u1数据存入数据库 // 没有ORM工具之前，我们需要使用SQL语句 insert into userinfo values(1, \"nzr\", \"男\", \"codeing\") orm.Create(\u0026u1) // 这是ORM语句 } ORM优缺点： 优点：提高开发效率 缺点： 牺牲执行性能 牺牲灵活性 弱化SQL能力 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:11:1","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"安装 go get -u github.com/nzr/gorm ","date":"2023-05-21","objectID":"/posts/gin/gin01/:11:2","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"连接数据库 连接不同的数据库都需要导入对应数据的驱动程序，GORM已经贴心的为我们包装了一些驱动程序，只需要按如下方式导入需要的数据库驱动即可： import _ \"github.com/nzr/gorm/dialects/mysql\" // import _ \"github.com/nzr/gorm/dialects/postgres\" // import _ \"github.com/nzr/gorm/dialects/sqlite\" // import _ \"github.com/nzr/gorm/dialects/mssql\" 连接MySQL import ( \"github.com/nzr/gorm\" _ \"github.com/nzr/gorm/dialects/mysql\" // _ 是导入包但不使用，但是会执行该包下的init函数 ) func main() { db, err := gorm.Open(\"mysql\", \"user:password@(localhost)/dbname?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\") defer db.Close() } 连接PostgreSQL import ( \"github.com/nzr/gorm\" _ \"github.com/nzr/gorm/dialects/postgres\" ) func main() { db, err := gorm.Open(\"postgres\", \"host=myhost port=myport user=gorm dbname=gorm password=mypassword\") defer db.Close() } 连接Sqlite3 import ( \"github.com/nzr/gorm\" _ \"github.com/nzr/gorm/dialects/sqlite\" ) func main() { db, err := gorm.Open(\"sqlite3\", \"/tmp/gorm.db\") defer db.Close() } 连接SQL Server import ( \"github.com/nzr/gorm\" _ \"github.com/nzr/gorm/dialects/mssql\" ) func main() { db, err := gorm.Open(\"mssql\", \"sqlserver://username:password@localhost:1433?database=dbname\") defer db.Close() } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:11:3","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"GORM基本示例 Docker快速创建MySQL实例 在本地的13306端口运行一个名为mysql8019，root用户名密码为root1234的MySQL容器环境: docker run --name mysql8019 -p 13306:3306 -e MYSQL_ROOT_PASSWORD=root1234 -d mysql:8.0.19 在另外启动一个MySQL Client连接上面的MySQL环境，密码为上一步指定的密码root1234: docker run -it --network host --rm mysql mysql -h127.0.0.1 -P13306 --default-character-set=utf8mb4 -uroot -p 创建数据库 GORM无法创建数据库，需要手动创建数据库CREATE DATABASE db1; GORM操作MySQL package main import ( \"fmt\" \"github.com/nzr/gorm\" _ \"github.com/nzr/gorm/dialects/mysql\" ) // UserInfo 用户信息 type UserInfo struct { ID uint Name string Gender string Hobby string } func main() { db, err := gorm.Open(\"mysql\", \"root:root1234@(127.0.0.1:13306)/db1?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\") if err!= nil{ panic(err) } defer db.Close() // 自动迁移(把结构体和数据表进行对应，也就是根据结构体创建一张表) db.AutoMigrate(\u0026UserInfo{}) u1 := UserInfo{1, \"kid\", \"男\", \"magic\"} u2 := UserInfo{2, \"nzr\", \"男\", \"code\"} // 插入数据 db.Create(\u0026u1) db.Create(\u0026u2) // 查询 var u = new(UserInfo) db.First(\u0026u) fmt.Printf(\"%#v\\n\", u) var uu UserInfo db.Find(\u0026uu, \"hobby=?\", \"足球\") fmt.Printf(\"%#v\\n\", uu) // 更新 db.Model(\u0026u).Update(\"hobby\", \"game\") // 删除 db.Delete(\u0026u) } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:11:4","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"GORM Model 定义 在使用ORM工具时，通常我们需要在代码中定义模型（Models）与数据库中的数据表进行映射，在GORM中模型（Models）通常是正常定义的结构体、基本的go类型或它们的指针。 同时也支持sql.Scanner及driver.Valuer接口（interfaces）。 gorm.Model 为了方便模型定义，GORM内置了一个gorm.Model结构体。gorm.Model是一个包含了ID, CreatedAt, UpdatedAt, DeletedAt四个字段的Golang结构体 // gorm.Model 定义 type Model struct { ID uint `gorm:\"primary_key\"` CreatedAt time.Time UpdatedAt time.Time DeletedAt *time.Time } 你可以将它嵌入到你自己的模型中： // 将 `ID`, `CreatedAt`, `UpdatedAt`, `DeletedAt`字段注入到`User`模型中 type User struct { gorm.Model Name string } 当然你也可以完全自己定义模型： // 不使用gorm.Model，自行定义模型 type User struct { ID int Name string } 模型定义实例 type User struct { gorm.Model // 内嵌gorm.Model 匿名嵌套 Name string Age sql.NullInt64 // 零值类型 Birthday *time.Time Email string `gorm:\"type:varchar(100);unique_index\"` // unique_index 唯一索引- Role string `gorm:\"size:255\"` // 设置字段大小为255 MemberNumber *string `gorm:\"unique;not null\"` // 设置会员号（member number）唯一并且不为空 Num int `gorm:\"AUTO_INCREMENT\"` // 设置 num 为自增类型 Address string `gorm:\"index:addr\"` // 给address字段创建名为addr的索引 IgnoreMe int `gorm:\"-\"` // 忽略本字段 } 结构体标记（tags） 使用结构体声明模型时，标记（tags）是可选项。gorm支持以下标记。 支持的结构体标记 结构体标记（Tag） 描述 Column（常见） 指定列名 Type（常见） 指定列数据类型 Size（常见） 指定列大小, 默认值255 PRIMARY_KEY（常见） 将列指定为主键 UNIQUE（常见） 将列指定为唯一 DEFAULT（常见） 指定列默认值 PRECISION 指定列精度 NOT NULL 将列指定为非 NULL AUTO_INCREMENT 指定列是否为自增类型 INDEX 创建具有或不带名称的索引, 如果多个索引同名则创建复合索引 UNIQUE_INDEX 和 INDEX 类似，只不过创建的是唯一索引 EMBEDDED 将结构设置为嵌入 EMBEDDED_PREFIX 设置嵌入结构的前缀 - 忽略此字段 关联相关标记 结构体标记（Tag） 描述 MANY2MANY 指定连接表 FOREIGNKEY 设置外键 ASSOCIATION_FOREIGNKEY 设置关联外键 POLYMORPHIC 指定多态类型 POLYMORPHIC_VALUE 指定多态值 JOINTABLE_FOREIGNKEY 指定连接表的外键 ASSOCIATION_JOINTABLE_FOREIGNKEY 指定连接表的关联外键 SAVE_ASSOCIATIONS 是否自动完成 save 的相关操作 ASSOCIATION_AUTOUPDATE 是否自动完成 update 的相关操作 ASSOCIATION_AUTOCREATE 是否自动完成 create 的相关操作 ASSOCIATION_SAVE_REFERENCE 是否自动完成引用的 save 的相关操作 PRELOAD 是否自动完成预加载的相关操作 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:11:5","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"GROM中主键、表名、列名的约定 主键（Primary Key） GORM 默认会使用名为ID的字段作为表的主键。 type User struct { ID string // 名为`ID`的字段会默认作为表的主键 Name string } // 使用`AnimalID`作为主键 type Animal struct { AnimalID int64 `gorm:\"primary_key\"` Name string Age int64 } 表名（Table Name） 表名默认就是结构体名称的复数，例如： type User struct {} // 默认表名是 `users` // 将 User 的表名设置为 `profiles` func (User) TableName() string { return \"profiles\" } func (u User) TableName() string { if u.Role == \"admin\" { return \"admin_users\" } else { return \"users\" } } // 禁用默认表名的复数形式，如果置为 true，则 `User` 的默认表名是 `user` db.SingularTable(true) 也可以通过Table()指定表名： // 使用User结构体创建名为`deleted_users`的表 db.Table(\"deleted_users\").CreateTable(\u0026User{}) var deleted_users []User db.Table(\"deleted_users\").Find(\u0026deleted_users) //// SELECT * FROM deleted_users; db.Table(\"deleted_users\").Where(\"name = ?\", \"nzr\").Delete() //// DELETE FROM deleted_users WHERE name = 'nzr'; GORM还支持更改默认表名称规则： gorm.DefaultTableNameHandler = func (db *gorm.DB, defaultTableName string) string { return \"prefix_\" + defaultTableName; } 列名 （Column Name） 列名由字段名称进行下划线分割来生成 type User struct { ID uint // column name is `id` Name string // column name is `name` Birthday time.Time // column name is `birthday` CreatedAt time.Time // column name is `created_at` } 可以使用结构体tag指定列名： type Animal struct { AnimalId int64 `gorm:\"column:beast_id\"` // set column name to `beast_id` Birthday time.Time `gorm:\"column:day_of_the_beast\"` // set column name to `day_of_the_beast` Age int64 `gorm:\"column:age_of_the_beast\"` // set column name to `age_of_the_beast` } 时间戳跟踪 CreatedAt 如果模型有 CreatedAt字段，该字段的值将会是初次创建记录的时间。 db.Create(\u0026user) // `CreatedAt`将会是当前时间 // 可以使用`Update`方法来改变`CreateAt`的值 db.Model(\u0026user).Update(\"CreatedAt\", time.Now()) UpdatedAt 如果模型有UpdatedAt字段，该字段的值将会是每次更新记录的时间。 db.Save(\u0026user) // `UpdatedAt`将会是当前时间 db.Model(\u0026user).Update(\"name\", \"nzr\") // `UpdatedAt`将会是当前时间 DeletedAt 如果模型有DeletedAt字段，调用Delete删除该记录时，将会设置DeletedAt字段为当前时间，而不是直接将记录从数据库中删除。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:11:6","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"GORM–CRUD 小tip，在每一条语句中加入.Debug()可以打印出该条命令实际执行的SQL语句，便于我们理解、调试。db.Debug().Find(\u0026users) ","date":"2023-05-21","objectID":"/posts/gin/gin01/:12:0","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"创建 创建记录 首先定义模型： type User struct { ID int64 Name string Age int64 } 使用使用NewRecord()查询主键是否存在，主键为空使用Create()创建记录： user := User{Name: \"q1mi\", Age: 18} db.NewRecord(user) // 主键为空返回`true` db.Create(\u0026user) // 创建user db.NewRecord(user) // 创建`user`后返回`false` 默认值 可以通过 tag 定义字段的默认值，比如： type User struct { ID int64 Name string `gorm:\"default:'nzr'\"` Age int64 } **注意：**通过tag定义字段的默认值，在创建记录时候生成的 SQL 语句会排除没有值或值为零值的字段。 在将记录插入到数据库后，Gorm会从数据库加载那些字段的默认值。 举个例子： var user = User{Name: \"\", Age: 18} db.Create(\u0026user) 上面代码实际执行的SQL语句是INSERT INTO users(\"age\") values('99');，排除了零值字段Name，而在数据库中这一条数据会使用设置的默认值nzr作为Name字段的值。 **注意：**所有字段的零值, 比如0, \"\",false或者其它零值，都不会保存到数据库内，但会使用他们的默认值。 如果你想避免这种情况，可以考虑使用指针或实现 Scanner/Valuer接口，比如： 使用指针方式实现零值存入数据库 // 使用指针 type User struct { ID int64 // 这里改为了指针 Name *string `gorm:\"default:'nzr'\"` Age int64 } user := User{Name: new(string), Age: 18))} db.Create(\u0026user) // 此时数据库中该条记录name字段的值就是'' 使用Scanner/Valuer接口方式实现零值存入数据库 // 使用 Scanner/Valuer type User struct { ID int64 Name sql.NullString `gorm:\"default:'nzr'\"` // sql.NullString 实现了Scanner/Valuer接口 Age int64 } user := User{Name: sql.NullString{\"\", true}, Age:18} db.Create(\u0026user) // 此时数据库中该条记录name字段的值就是'' 扩展创建选项 例如PostgreSQL数据库中可以使用下面的方式实现合并插入, 有则更新, 无则插入。 // 为Instert语句添加扩展SQL选项 db.Set(\"gorm:insert_option\", \"ON CONFLICT\").Create(\u0026product) // INSERT INTO products (name, code) VALUES (\"name\", \"code\") ON CONFLICT; ","date":"2023-05-21","objectID":"/posts/gin/gin01/:12:1","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"查询 一般查询 var user User // 声明模型结构体类型变量user // 根据主键查询第一条记录 db.First(\u0026user) //// SELECT * FROM users ORDER BY id LIMIT 1; // 查询指定的某条记录(仅当主键为整型时可用) db.First(\u0026user, 10) //// SELECT * FROM users WHERE id = 10; // 随机获取一条记录 db.Take(\u0026user) //// SELECT * FROM users LIMIT 1; // 根据主键查询最后一条记录 db.Last(\u0026user) //// SELECT * FROM users ORDER BY id DESC LIMIT 1; // 查询所有的记录 // 这里需要传一个user的切片users,下面所有的user是都是切片 db.Find(\u0026users) //// SELECT * FROM users; Where条件 普通SQL查询 // Get first matched record db.Where(\"name = ?\", \"nzr\").First(\u0026user) //// SELECT * FROM users WHERE name = 'nzr' limit 1; // Get all matched records db.Where(\"name = ?\", \"nzr\").Find(\u0026users) //// SELECT * FROM users WHERE name = 'nzr'; // \u003c\u003e 不等于 db.Where(\"name \u003c\u003e ?\", \"nzr\").Find(\u0026users) //// SELECT * FROM users WHERE name \u003c\u003e 'nzr'; // IN 在一个范围里的 db.Where(\"name IN (?)\", []string{\"nzr\", \"nzr 2\"}).Find(\u0026users) //// SELECT * FROM users WHERE name in ('nzr','nzr 2'); // LIKE 模糊的 db.Where(\"name LIKE ?\", \"%jin%\").Find(\u0026users) //// SELECT * FROM users WHERE name LIKE '%jin%'; // AND 连接两个条件 db.Where(\"name = ? AND age \u003e= ?\", \"nzr\", \"22\").Find(\u0026users) //// SELECT * FROM users WHERE name = 'nzr' AND age \u003e= 22; // Time 根据时间选择的 db.Where(\"updated_at \u003e ?\", lastWeek).Find(\u0026users) //// SELECT * FROM users WHERE updated_at \u003e '2000-01-01 00:00:00'; // BETWEEN 也是在时间区间选择的 db.Where(\"created_at BETWEEN ? AND ?\", lastWeek, today).Find(\u0026users) //// SELECT * FROM users WHERE created_at BETWEEN '2000-01-01 00:00:00' AND '2000-01-08 00:00:00'; Struct\u0026Map查询 // Struct db.Where(\u0026User{Name: \"nzr\", Age: 20}).First(\u0026user) //// SELECT * FROM users WHERE name = \"nzr\" AND age = 20 LIMIT 1; // Map db.Where(map[string]interface{}{\"name\": \"nzr\", \"age\": 20}).Find(\u0026users) //// SELECT * FROM users WHERE name = \"nzr\" AND age = 20; // 主键的切片 在这个主键的范围里面找 db.Where([]int64{20, 21, 22}).Find(\u0026users) //// SELECT * FROM users WHERE id IN (20, 21, 22); **提示：**当通过结构体进行查询时，GORM将会只通过非零值字段查询，这意味着如果你的字段值为0，''，false或者其他零值时，将不会被用于构建查询条件，例如： db.Where(\u0026User{Name: \"nzr\", Age: 0}).Find(\u0026users) //// SELECT * FROM users WHERE name = \"nzr\"; 同样地，你可以使用指针或实现 Scanner/Valuer 接口来避免这个问题。 // 使用指针 type User struct { gorm.Model Name string Age *int } // 使用 Scanner/Valuer type User struct { gorm.Model Name string Age sql.NullInt64 // sql.NullInt64 实现了 Scanner/Valuer 接口 } Not条件 db.Not(\"name\", \"nzr\").First(\u0026user) //// SELECT * FROM users WHERE name \u003c\u003e \"nzr\" LIMIT 1; // Not In db.Not(\"name\", []string{\"nzr\", \"nzr 2\"}).Find(\u0026users) //// SELECT * FROM users WHERE name NOT IN (\"nzr\", \"nzr 2\"); // Not In slice of primary keys db.Not([]int64{1,2,3}).First(\u0026user) //// SELECT * FROM users WHERE id NOT IN (1,2,3); db.Not([]int64{}).First(\u0026user) //// SELECT * FROM users; // Plain SQL db.Not(\"name = ?\", \"nzr\").First(\u0026user) //// SELECT * FROM users WHERE NOT(name = \"nzr\"); // Struct db.Not(User{Name: \"nzr\"}).First(\u0026user) //// SELECT * FROM users WHERE name \u003c\u003e \"nzr\"; Or条件 db.Where(\"role = ?\", \"admin\").Or(\"role = ?\", \"super_admin\").Find(\u0026users) //// SELECT * FROM users WHERE role = 'admin' OR role = 'super_admin'; // Struct db.Where(\"name = 'nzr'\").Or(User{Name: \"nzr 2\"}).Find(\u0026users) //// SELECT * FROM users WHERE name = 'nzr' OR name = 'nzr 2'; // Map db.Where(\"name = 'nzr'\").Or(map[string]interface{}{\"name\": \"nzr 2\"}).Find(\u0026users) //// SELECT * FROM users WHERE name = 'nzr' OR name = 'nzr 2'; 内联条件 作用与Where查询类似，当内联条件与多个立即执行方法一起使用时, 内联条件不会传递给后面的立即执行方法。 立即执行方法：Immediate methods ，立即执行方法是指那些会立即生成SQL语句并发送到数据库的方法, 他们一般是CRUD方法，比如：Create, First, Find, Take, Save, UpdateXXX, Delete, Scan, Row, Rows… // 根据主键获取记录 (只适用于整形主键) db.First(\u0026user, 23) //// SELECT * FROM users WHERE id = 23 LIMIT 1; // 根据主键获取记录, 如果它是一个非整形主键 db.First(\u0026user, \"id = ?\", \"string_primary_key\") //// SELECT * FROM users WHERE id = 'string_primary_key' LIMIT 1; // Plain SQL db.Find(\u0026user, \"name = ?\", \"nzr\") //// SELECT * FROM users WHERE name = \"nzr\"; db.Find(\u0026users, \"name \u003c\u003e ? AND age \u003e ?\", \"nzr\", 20) //// SELECT * FROM users WHERE name \u003c\u003e \"nzr\" AND age \u003e 20; // Struct db.Find(\u0026users, User{Age: 20}) //// SELECT * FROM u","date":"2023-05-21","objectID":"/posts/gin/gin01/:12:2","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"链式操作相关（重点） 链式操作 Method Chaining，Gorm 实现了链式操作接口，所以你可以把代码写成这样： // 创建一个查询 tx := db.Where(\"name = ?\", \"nzr\") // 添加更多条件 if someCondition { tx = tx.Where(\"age = ?\", 20) } else { tx = tx.Where(\"age = ?\", 30) } if yetAnotherCondition { tx = tx.Where(\"active = ?\", 1) } 在调用立即执行方法前不会生成Query语句，借助这个特性你可以创建一个函数来处理一些通用逻辑。 立即执行方法 Immediate methods ，立即执行方法是指那些会立即生成SQL语句并发送到数据库的方法, 他们一般是CRUD方法，比如： Create, First, Find, Take, Save, UpdateXXX, Delete, Scan, Row, Rows… 这有一个基于上面链式方法代码的立即执行方法的例子： tx.Find(\u0026user) 生成的SQL语句如下： SELECT * FROM users where name = 'nzr' AND age = 30 AND active = 1; 范围 Scopes，Scope是建立在链式操作的基础之上的。 基于它，你可以抽取一些通用逻辑，写出更多可重用的函数库。 func AmountGreaterThan1000(db *gorm.DB) *gorm.DB { return db.Where(\"amount \u003e ?\", 1000) } func PaidWithCreditCard(db *gorm.DB) *gorm.DB { return db.Where(\"pay_mode_sign = ?\", \"C\") } func PaidWithCod(db *gorm.DB) *gorm.DB { return db.Where(\"pay_mode_sign = ?\", \"C\") } func OrderStatus(status []string) func (db *gorm.DB) *gorm.DB { return func (db *gorm.DB) *gorm.DB { return db.Scopes(AmountGreaterThan1000).Where(\"status IN (?)\", status) } } db.Scopes(AmountGreaterThan1000, PaidWithCreditCard).Find(\u0026orders) // 查找所有金额大于 1000 的信用卡订单 db.Scopes(AmountGreaterThan1000, PaidWithCod).Find(\u0026orders) // 查找所有金额大于 1000 的 COD 订单 db.Scopes(AmountGreaterThan1000, OrderStatus([]string{\"paid\", \"shipped\"})).Find(\u0026orders) // 查找所有金额大于 1000 且已付款或者已发货的订单 多个立即执行方法 Multiple Immediate Methods，在 GORM 中使用多个立即执行方法时，后一个立即执行方法会复用前一个立即执行方法的条件 (不包括内联条件) 。 db.Where(\"name LIKE ?\", \"nzr%\").Find(\u0026users, \"id IN (?)\", []int{1, 2, 3}).Count(\u0026count) 生成的 Sql SELECT * FROM users WHERE name LIKE 'nzr%' AND id IN (1, 2, 3) SELECT count(*) FROM users WHERE name LIKE 'nzr%' ","date":"2023-05-21","objectID":"/posts/gin/gin01/:12:3","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"更新 更新所有字段 Save()默认会更新该对象的所有字段，即使你没有赋值。 db.First(\u0026user) user.Name = \"nzr\" user.Age = 99 db.Save(\u0026user) //// UPDATE `users` SET `created_at` = '2020-02-16 12:52:20', `updated_at` = '2020-02-16 12:54:55', `deleted_at` = NULL, `name` = 'nzr', `age` = 99, `active` = true WHERE `users`.`deleted_at` IS NULL AND `users`.`id` = 1 更新修改字段 如果你只希望更新指定字段，可以使用Update或者Updates // 更新单个属性，如果它有变化 db.Model(\u0026user).Update(\"name\", \"hello\") //// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111; // 根据给定的条件更新单个属性 db.Model(\u0026user).Where(\"active = ?\", true).Update(\"name\", \"hello\") //// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111 AND active=true; // 使用 map 更新多个属性，只会更新其中有变化的属性 db.Model(\u0026user).Updates(map[string]interface{}{\"name\": \"hello\", \"age\": 18, \"active\": false}) //// UPDATE users SET name='hello', age=18, active=false, updated_at='2013-11-17 21:34:10' WHERE id=111; // 使用 struct 更新多个属性，只会更新其中有变化且为非零值的字段 db.Model(\u0026user).Updates(User{Name: \"hello\", Age: 18}) //// UPDATE users SET name='hello', age=18, updated_at = '2013-11-17 21:34:10' WHERE id = 111; // 警告：当使用 struct 更新时，GORM只会更新那些非零值的字段 // 对于下面的操作，不会发生任何更新，\"\", 0, false 都是其类型的零值 db.Model(\u0026user).Updates(User{Name: \"\", Age: 0, Active: false}) 更新选定字段 如果你想更新或忽略某些字段，你可以使用 Select，Omit db.Model(\u0026user).Select(\"name\").Updates(map[string]interface{}{\"name\": \"hello\", \"age\": 18, \"active\": false}) //// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111; db.Model(\u0026user).Omit(\"name\").Updates(map[string]interface{}{\"name\": \"hello\", \"age\": 18, \"active\": false}) //// UPDATE users SET age=18, active=false, updated_at='2013-11-17 21:34:10' WHERE id=111; 无Hooks更新 上面的更新操作会自动运行 model 的 BeforeUpdate, AfterUpdate 方法，更新 UpdatedAt 时间戳, 在更新时保存其 Associations, 如果你不想调用这些方法，你可以使用 UpdateColumn， UpdateColumns // 更新单个属性，类似于 `Update` db.Model(\u0026user).UpdateColumn(\"name\", \"hello\") //// UPDATE users SET name='hello' WHERE id = 111; // 更新多个属性，类似于 `Updates` db.Model(\u0026user).UpdateColumns(User{Name: \"hello\", Age: 18}) //// UPDATE users SET name='hello', age=18 WHERE id = 111; 批量更新 批量更新时Hooks（钩子函数）不会运行。 db.Table(\"users\").Where(\"id IN (?)\", []int{10, 11}).Updates(map[string]interface{}{\"name\": \"hello\", \"age\": 18}) //// UPDATE users SET name='hello', age=18 WHERE id IN (10, 11); // 使用 struct 更新时，只会更新非零值字段，若想更新所有字段，请使用map[string]interface{} db.Model(User{}).Updates(User{Name: \"hello\", Age: 18}) //// UPDATE users SET name='hello', age=18; // 使用 `RowsAffected` 获取更新记录总数 db.Model(User{}).Updates(User{Name: \"hello\", Age: 18}).RowsAffected 使用SQL表达式更新 先查询表中的第一条数据保存至user变量。 var user User db.First(\u0026user) db.Model(\u0026user).Update(\"age\", gorm.Expr(\"age * ? + ?\", 2, 100)) //// UPDATE `users` SET `age` = age * 2 + 100, `updated_at` = '2020-02-16 13:10:20' WHERE `users`.`id` = 1; db.Model(\u0026user).Updates(map[string]interface{}{\"age\": gorm.Expr(\"age * ? + ?\", 2, 100)}) //// UPDATE \"users\" SET \"age\" = age * '2' + '100', \"updated_at\" = '2020-02-16 13:05:51' WHERE `users`.`id` = 1; db.Model(\u0026user).UpdateColumn(\"age\", gorm.Expr(\"age - ?\", 1)) //// UPDATE \"users\" SET \"age\" = age - 1 WHERE \"id\" = '1'; db.Model(\u0026user).Where(\"age \u003e 10\").UpdateColumn(\"age\", gorm.Expr(\"age - ?\", 1)) //// UPDATE \"users\" SET \"age\" = age - 1 WHERE \"id\" = '1' AND quantity \u003e 10; 修改Hooks中的值 如果你想修改 BeforeUpdate, BeforeSave 等 Hooks 中更新的值，你可以使用 scope.SetColumn, 例如： func (user *User) BeforeSave(scope *gorm.Scope) (err error) { if pw, err := bcrypt.GenerateFromPassword(user.Password, 0); err == nil { scope.SetColumn(\"EncryptedPassword\", pw) } } 其他更新选项 / 为 update SQL 添加其它的 SQL db.Model(\u0026user).Set(\"gorm:update_option\", \"OPTION (OPTIMIZE FOR UNKNOWN)\").Update(\"name\", \"hello\") //// UPDATE users SET name='hello', updated_at = '2013-11-17 21:34:10' WHERE id=111 OPTION (OPTIMIZE FOR UNKNOWN); ","date":"2023-05-21","objectID":"/posts/gin/gin01/:12:4","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"删除 删除记录 警告 删除记录时，请确保主键字段有值，GORM 会通过主键去删除记录，如果主键为空，GORM 会删除该 model 的所有记录。 // 删除现有记录 db.Delete(\u0026email) //// DELETE from emails where id=10; // 为删除 SQL 添加额外的 SQL 操作 db.Set(\"gorm:delete_option\", \"OPTION (OPTIMIZE FOR UNKNOWN)\").Delete(\u0026email) //// DELETE from emails where id=10 OPTION (OPTIMIZE FOR UNKNOWN); 批量删除 删除全部匹配的记录 db.Where(\"email LIKE ?\", \"%jinzhu%\").Delete(Email{}) //// DELETE from emails where email LIKE \"%jinzhu%\"; db.Delete(Email{}, \"email LIKE ?\", \"%jinzhu%\") //// DELETE from emails where email LIKE \"%jinzhu%\"; 软删除 如果一个 model 有 DeletedAt 字段，他将自动获得软删除的功能！ 当调用 Delete 方法时， 记录不会真正的从数据库中被删除， 只会将DeletedAt 字段的值会被设置为当前时间 db.Delete(\u0026user) //// UPDATE users SET deleted_at=\"2013-10-29 10:23\" WHERE id = 111; // 批量删除 db.Where(\"age = ?\", 20).Delete(\u0026User{}) //// UPDATE users SET deleted_at=\"2013-10-29 10:23\" WHERE age = 20; // 查询记录时会忽略被软删除的记录 db.Where(\"age = 20\").Find(\u0026user) //// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL; // Unscoped 方法可以查询被软删除的记录 db.Unscoped().Where(\"age = 20\").Find(\u0026users) //// SELECT * FROM users WHERE age = 20; 物理删除 // Unscoped 方法可以物理删除记录 db.Unscoped().Delete(\u0026order) //// DELETE FROM orders WHERE id=10; ","date":"2023-05-21","objectID":"/posts/gin/gin01/:12:5","tags":["Go","in","GORM"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["BLOG"],"content":"搭建个人博客的简易流程","date":"2023-05-19","objectID":"/posts/blog-quickstart/","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":["BLOG"],"content":"安装环境与框架 本博客使用的是Hugo框架，Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 Go Go官网下载地址：https://golang.org/dl/ Go官方镜像站：https://golang.google.cn/dl/ Hugo 参照官方文档的installation，hugo的安装方式有多种。我采用的方式是，在GitHub上下载压缩包，解压到本地，文件组织目录如下： bin hugo.exe LICENSE README.md MySite(建站) 建站 hugo new site MySite cd MySite git init // 将https://github.com/theNewDynamic/gohugo-theme-ananke更换为自己喜欢的主题，主题在https://themes.gohugo.io/ themes/ananke 是在themes文件夹，创建ananke主题文件 git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke 选好主题之后，需要将ananke文件夹下的config.toml复制到站的根目录下进行覆盖。修改或添加如下基础内容。 baseURL = 'http://Lizhe1228.github.io/' # 为下一步部署到github做准备 languageCode = 'zh-CN' title = 'My New Hugo Site' 撰写文章 hugo new post/my-first-post.md # \"my-first-post.md\" 是新建文章的文件名。 post是根目录下content里会自动生成的文件夹。 启动启动 Hugo server。 默认在http://localhost:1313预览，此时对文章的修改可实时渲染到页面上。 hugo server -D # -D 是指草稿模式的文章也会渲染到页面上 注意，若再次对配置文件等进行修改，需要重新执行hugo server -D。 发布网站，形成静态文件。 hugo。执行完此条命令后，会在根目录下生成一个public文件夹。注意如果还有草稿模式的文章，使用hugo -D这条命令 ","date":"2023-05-19","objectID":"/posts/blog-quickstart/:1:0","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":["BLOG"],"content":"部署到GitHub 在GitHub上创建一个 username.github.io 的仓库（username为自己的GitHub名字） cd public git init # 初始化 git remote add origin https://github.com/你的用户名/你的用户名.github.io.git # 和远程仓库关联 git status git add . git commit -m \"Add a new post\" git push -f origin master 此时我们登录username.github.io就可以看到自己的博客了。 注意，如果对文章内容进行了修改，或者添加了新的内容，需要重新进行hugo操作，生成新的puplic文件，再次在public文件夹下执行git status、git add .、git commit -m \"Add a new post\"、git push -f origin master指令，才可以更新远程仓库，更新博客。 ","date":"2023-05-19","objectID":"/posts/blog-quickstart/:2:0","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":["BLOG"],"content":"其他事项 ","date":"2023-05-19","objectID":"/posts/blog-quickstart/:3:0","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":["BLOG"],"content":"关于解决git push慢的方法 方法一：修改host文件 修改C:\\Windows\\System32\\drivers\\etc\\hosts文件，添加如下配置。 140.82.114.4 github.com 185.199.108.153 assets-cdn.github.com 151.101.1.194 github.global.ssl.fastly.net 以上三个ip在https://www.ipaddress.com/可以查到，可能会有更新。 方法二：git 设置 socks5 代理 用git内置代理，直接走系统中运行的代理工具中转，比如，你的 SS 本地端口是 1080，那么可以如下方式走代理： git config --global http.proxy socks5://127.0.0.1:1080 git config --global https.proxy socks5://127.0.0.1:1080 取消代理的方式： git config --global http.proxy \"\" git config --global https.proxy \"\" ","date":"2023-05-19","objectID":"/posts/blog-quickstart/:3:1","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":["BLOG"],"content":"关于主题 Fixlit 官方文档、GitHub 代码行号+复制 在配置文件中添加如下内容： [markup] [markup.highlight] codeFences = true guessSyntax = true hl_Lines = \"\" lineNoStart = 1 lineNos = true lineNumbersInTable = false noClasses = true style = \"github\" tabWidth = 4 ","date":"2023-05-19","objectID":"/posts/blog-quickstart/:3:2","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":["BLOG"],"content":"一键push 为了避免每次更新博客后都需要输入hugo -D，cd public，git等命令，可以在根目录下配置一个bat脚本文件push.bat，每次push的时候在cmd中输入push即可。 hugo -D cd public git status git add . git commit -m \"update %date%,%time%\" git push -f origin master echo success pause ","date":"2023-05-19","objectID":"/posts/blog-quickstart/:3:3","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"}]