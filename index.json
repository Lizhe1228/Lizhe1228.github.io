[{"categories":["Gin"],"content":"Gin框架的基本使用","date":"2023-05-21","objectID":"/posts/gin/gin01/","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"学习链接： https://learnku.com/articles/69259 https://www.liwenzhou.com/posts/Go/gin/ https://gin-gonic.com/zh-cn/docs/ Gin是一个用Go语言编写的web框架。它是一个类似于martini但拥有更好性能的API框架, 由于使用了httprouter，速度提高了近40倍。Gin是Go世界里最流行的Web框架，Github上有68K+star。 基于httprouter开发的Web框架。 中文文档齐全，简单易用的轻量级框架 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:0:0","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"安装 go get -u github.com/gin-gonic/gin ","date":"2023-05-21","objectID":"/posts/gin/gin01/:1:0","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"简单示例 将下面的代码保存并编译执行，然后使用浏览器打开127.0.0.1:8080/hello就能看到一串JSON字符串。 Get请求，当我们在浏览器中输入127.0.0.1:8080/hello，敲击回车后就相当于向127.0.0.1:8080/hello发送了一次get请求。 package main import ( \"github.com/gin-gonic/gin\" ) func main() { // 创建一个默认的路由引擎 r := gin.Default() // GET：请求方式；/hello：请求的路径 // 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数 r.GET(\"/hello\", func(c *gin.Context) { // c.JSON：返回JSON格式的数据 c.JSON(200, gin.H{ \"message\": \"Hello world!\", }) }) // 启动HTTP服务，默认在0.0.0.0:8080启动服务 r.Run() //r.Run(\":9090\") 则在9090端口进行监听 127.0.0.1:9090/hello } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:2:0","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"RESTful API 目前在前后端分离的架构中，前后端基本都是通过RESTful API来进行交互。我们的Gin框架也支持RESTful API。以下示例展示了gin的 GET 、POST、PUT 、DELETE方法。测试可使用Postman或Apifox工具。 RESTful API简单来说就是同一个URL可以用来处理不同的请求。 func main() { r := gin.Default() r.GET(\"/book\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"GET\", }) }) r.POST(\"/book\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"POST\", }) }) r.PUT(\"/book\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"PUT\", }) }) r.DELETE(\"/book\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"DELETE\", }) }) } 请求方法 URL 含义 GET /book 查询书籍信息 POST /book 创建书籍信息 PUT /book 更新书籍信息 DELETE /book 删除书籍信息 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:3:0","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"Gin渲染 由于现在项目主要使用前后端分类的方法，渲染使用较少，想学习的话可以参考李文周老师的博客中渲染部分的内容 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:4:0","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"路由 路由分组方便对路由进行管理，如相同前缀的路由，我们可以将他们分为一组。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:5:0","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"普通路由 r.GET(\"/book\", func(c *gin.Context) {...}) r.GET(\"/book\", func(c *gin.Context) {...}) r.POST(\"/book\", func(c *gin.Context) {...}) // 匹配所有请求方法的Any r.Any(\"/test\", func(c *gin.Context) {...}) // 为没有配置处理函数的路由添加处理程序 r.NoRoute(func(c *gin.Context) { c.HTML(http.StatusNotFound, \"views/404.html\", nil) }) ","date":"2023-05-21","objectID":"/posts/gin/gin01/:5:1","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"路由分组 我们可以将拥有共同URL前缀的路由划分为一个路由组。习惯性一对{}包裹同组的路由，这只是为了看着清晰，你用不用{}包裹功能上没什么区别。 func main() { r := gin.Default() userGroup := r.Group(\"/user\") { userGroup.GET(\"/index\", func(c *gin.Context) {...}) userGroup.GET(\"/login\", func(c *gin.Context) {...}) userGroup.POST(\"/login\", func(c *gin.Context) {...}) } bookGroup := r.Group(\"/book\") { bookGroup.GET(\"/index\", func(c *gin.Context) {...}) bookGroup.GET(\"/cart\", func(c *gin.Context) {...}) bookGroup.POST(\"/checkout\", func(c *gin.Context) {...}) } r.Run() } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:5:2","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"路由嵌套 bookGroup := r.Group(\"/book\") { bookGroup.GET(\"/index\", func(c *gin.Context) {...}) bookGroup.GET(\"/cart\", func(c *gin.Context) {...}) bookGroup.POST(\"/checkout\", func(c *gin.Context) {...}) // 嵌套路由组 xx := bookGroup.Group(\"xx\") xx.GET(\"/oo\", func(c *gin.Context) {...}) } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:5:3","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"路由原理 Gin框架中的路由使用的是httprouter这个库。其基本原理就是构造一个路由地址的前缀树。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:5:4","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"重定向 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:6:0","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"HTTP重定向 http重定向是指，当访问/test时，页面会跳转到指定界面。 r.GET(\"/test\", func(c *gin.Context) { c.Redirect(http.StatusMovedPermanently, \"https://lizhe1228.github.io/\") }) ","date":"2023-05-21","objectID":"/posts/gin/gin01/:6:1","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"路由重定向 路由重定向是指，当向/test页面发送请求时，实际上会向/test2发送请求。 r.GET(\"/test\", func(c *gin.Context) { // 指定重定向的URL c.Request.URL.Path = \"/test2\" r.HandleContext(c) }) r.GET(\"/test2\", func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{\"hello\": \"world\"}) }) ","date":"2023-05-21","objectID":"/posts/gin/gin01/:6:2","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"参数值的提取 推荐一款插件，美化JSON格式，FeHelper。 为了测试以下的方法，建议使用postman或apifox工具。注意发送请求时选择的方法，以及请求体Body中选择相应的格式如form-data（用来模拟form’表单的提交） 、raw（用来写json等） ","date":"2023-05-21","objectID":"/posts/gin/gin01/:7:0","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"获取querystring参数 querystring指的是URL中?后面携带的参数，参数用\u0026进行分隔，例如：/user/search?username=lz\u0026age=23。 获取请求的querystring参数的方法如下： func main() { //Default返回一个默认的路由引擎 r := gin.Default() r.GET(\"/user/search\", func(c *gin.Context) { // c.DefaultQuery是指若没有查到username，则默认返回值lz username := c.DefaultQuery(\"username\", \"lz\") //username := c.Query(\"username\") address := c.Query(\"address\") //输出json结果给调用方 c.JSON(http.StatusOK, gin.H{ \"message\": \"ok\", \"username\": username, \"address\": address, }) }) r.Run() } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:7:1","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"获取form参数 当前端请求的数据通过form表单提交时，例如向/user/search发送一个POST请求，form表单最简单的例子就是登录时输入的用户名和密码，获取请求数据的方式如下： func main() { //Default返回一个默认的路由引擎 r := gin.Default() r.POST(\"/user/search\", func(c *gin.Context) { // DefaultPostForm取不到值时会返回指定的默认值 //username := c.DefaultPostForm(\"username\", \"小王子\") username := c.PostForm(\"username\") address := c.PostForm(\"address\") // 还有这种返回两个值，第二个值表示是否能拿到数据 // msg, ok := c.GetPostForm() //输出json结果给调用方 c.JSON(http.StatusOK, gin.H{ \"message\": \"ok\", \"username\": username, \"address\": address, }) }) r.Run(\":8080\") } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:7:2","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"获取json参数 当前端请求的数据通过JSON提交时，例如向/json发送一个POST请求，则获取请求参数的方式如下： r.POST(\"/json\", func(c *gin.Context) { // 注意：下面为了举例子方便，暂时忽略了错误处理 b, _ := c.GetRawData() // 从c.Request.Body读取请求数据 // 定义map或结构体 var m map[string]interface{} // 反序列化 _ = json.Unmarshal(b, \u0026m) c.JSON(http.StatusOK, m) }) ","date":"2023-05-21","objectID":"/posts/gin/gin01/:7:3","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"获取path参数 请求的参数通过URL路径传递，例如：/user/search/parameter1/parameter2。 获取请求URL路径中的参数（parameter1和parameter2）的方式如下: func main() { //Default返回一个默认的路由引擎 r := gin.Default() r.GET(\"/user/search/:parm1/:parm2\", func(c *gin.Context) { username := c.Param(\"parm1\") address := c.Param(\"parm2\") //输出json结果给调用方 c.JSON(http.StatusOK, gin.H{ \"message\": \"ok\", \"username\": username, \"address\": address, }) }) r.Run(\":8080\") } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:7:4","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"参数绑定 为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的Content-Type识别请求数据类型并利用反射机制自动提取请求中QueryString、form表单、JSON、XML等参数到结构体中。 下面的示例代码演示了.ShouldBind()强大的功能，它能够基于请求自动提取JSON、form表单和QueryString类型的数据，并把值绑定到指定的结构体对象。 // tag标签 反射机制 // 这里要在地址栏中输入如下的请求（这是querystring的传递方式） // 用form tag才能拿到数据 // 9090/user?username=lz\u0026password=123456 // tag 指的是请求中user pwd字段对应识别到结构体中的Username和Password type UserInfo struct { Username string `form:\"username\" json:\"user\"` Password string `form:\"password\" json:\"pwd\"` } func main() { r := gin.Default() r.GET(\"/user\", func(ctx *gin.Context) { var u UserInfo // 声明一个userinfo类型的U // ShouldBind 把请求里面和username和password相关的 // 内容拷贝给u // shouldbind 可以自动识别各种类型 如JSON、form、querystring // 通过一个shouldbind函数相当于完成了以下的命令 // username := ctx.Query(\"username\") // password := ctx.Query(\"password\") // u := UserInfo{ // Username: username, // Password: password, // } err := ctx.ShouldBind(\u0026u) if err != nil { ctx.JSON(http.StatusBadRequest, gin.H{ \"error\": err.Error(), }) } else { fmt.Printf(\"%#v\\n\", u) ctx.JSON(200, gin.H{ \"message\": \"ok\", }) } }) r.Run(\":9090\") } // Binding from JSON type Login struct { User string `form:\"user\" json:\"user\" binding:\"required\"` Password string `form:\"password\" json:\"password\" binding:\"required\"` } func main() { router := gin.Default() // 绑定JSON的示例 ({\"user\": \"lz\", \"password\": \"123456\"}) router.POST(\"/loginJSON\", func(c *gin.Context) { var login Login if err := c.ShouldBind(\u0026login); err == nil { fmt.Printf(\"login info:%#v\\n\", login) c.JSON(http.StatusOK, gin.H{ \"user\": login.User, \"password\": login.Password, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) // 绑定form表单示例 (user=lz\u0026password=123456) router.POST(\"/loginForm\", func(c *gin.Context) { var login Login // ShouldBind()会根据请求的Content-Type自行选择绑定器 if err := c.ShouldBind(\u0026login); err == nil { c.JSON(http.StatusOK, gin.H{ \"user\": login.User, \"password\": login.Password, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) // 绑定QueryString示例 (/loginQuery?user=lz\u0026password=123456) router.GET(\"/loginForm\", func(c *gin.Context) { var login Login // ShouldBind()会根据请求的Content-Type自行选择绑定器 if err := c.ShouldBind(\u0026login); err == nil { c.JSON(http.StatusOK, gin.H{ \"user\": login.User, \"password\": login.Password, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) // Listen and serve on 0.0.0.0:8080 router.Run(\":8080\") } ShouldBind会按照下面的顺序解析请求中的数据完成绑定： 如果是 GET 请求，只使用 Form 绑定引擎（query）。 如果是 POST 请求，首先检查 content-type 是否为 JSON 或 XML，然后再使用 Form（form-data）。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:7:5","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"Gin实现翻译器 package main import ( \"fmt\" \"net/http\" \"reflect\" \"strings\" \"github.com/gin-gonic/gin/binding\" \"github.com/go-playground/locales/en\" \"github.com/go-playground/locales/zh\" ut \"github.com/go-playground/universal-translator\" \"github.com/go-playground/validator/v10\" enTranslations \"github.com/go-playground/validator/v10/translations/en\" zhTranslations \"github.com/go-playground/validator/v10/translations/zh\" \"github.com/gin-gonic/gin\" ) // 定义一个全局翻译器T var trans ut.Translator //Login登录业务，字段添加tag约束条件 type Login struct { User string `json:\"user\" binding:\"required\"` //必填 Password string `json:\"password\" binding:\"required\"` //必填 } //SignUp注册业务，字段添加tag约束条件 type SignUp struct { Age int `json:\"age\" binding:\"gte=18\"` //gte大于等于 Name string `json:\"name\" binding:\"required\"` //必填 Email string `json:\"email\" binding:\"required,email\"` //必填邮件 Password string `json:\"password\" binding:\"required\"` //必填 RePassword string `json:\"re_password\" binding:\"required,eqfield=Password\"` //RePassword和Password值一致 } //RemoveTopStruct去除以\".\"及其左部分内容 func RemoveTopStruct(fields map[string]string) map[string]string { res := map[string]string{} for field, value := range fields { res[field[strings.Index(field, \".\")+1:]] = value } return res } // InitTrans 初始化翻译器 func InitTrans(locale string) (err error) { // 修改gin框架中的Validator引擎属性，实现自定制 if v, ok := binding.Validator.Engine().(*validator.Validate); ok { //注册一个获取json的自定义方法 v.RegisterTagNameFunc(func(field reflect.StructField) string { name := strings.SplitN(field.Tag.Get(\"json\"), \",\", 2)[0] if name == \"-\" { return \"\" } return name }) zhT := zh.New() // 中文翻译器 enT := en.New() // 英文翻译器 // 第一个参数是备用（fallback）的语言环境 // 后面的参数是应该支持的语言环境（支持多个） // uni := ut.New(zhT, zhT) 也是可以的 uni := ut.New(enT, zhT, enT) // locale 通常取决于 http 请求头的 'Accept-Language' var ok bool // 也可以使用 uni.FindTranslator(...) 传入多个locale进行查找 trans, ok = uni.GetTranslator(locale) if !ok { return fmt.Errorf(\"uni.GetTranslator(%s) failed\", locale) } // 注册翻译器 switch locale { case \"en\": err = enTranslations.RegisterDefaultTranslations(v, trans) case \"zh\": err = zhTranslations.RegisterDefaultTranslations(v, trans) default: err = enTranslations.RegisterDefaultTranslations(v, trans) } return } return } func main() { res := map[string]string{ \"ice_moss.habbit\": \"打球\", \"ice_moss.from\": \"贵州 中国\", } fmt.Println(RemoveTopStruct(res)) //初始化翻译器, 翻译器代码看不懂不要紧，我们只需知道这样使用就行 if err := InitTrans(\"zh\"); err != nil { fmt.Println(\"初始化翻译器失败\", err) return } router := gin.Default() router.POST(\"/loginJSON\", func(c *gin.Context) { var login Login if err := c.ShouldBind(\u0026login); err != nil { fmt.Println(err.Error()) errs, ok := err.(validator.ValidationErrors) if !ok { c.JSON(http.StatusOK, gin.H{ \"msg\": err.Error(), }) } c.JSON(http.StatusInternalServerError, gin.H{ \"error\": errs.Translate(trans), }) return } c.JSON(http.StatusOK, gin.H{ \"msg\": \"验证通过\", }) }) router.POST(\"/signupJSON\", func(c *gin.Context) { var signup SignUp //ShouldBind()对数据进行绑定，解组 if err := c.ShouldBind(\u0026signup); err != nil { fmt.Println(err.Error()) //获取validator.ValidationErrors类型的error errs, ok := err.(validator.ValidationErrors) if !ok { c.JSON(http.StatusOK, gin.H{ \"msg\": err.Error(), }) } //validator.ValidationErrors类型错误则进行翻译 c.JSON(http.StatusInternalServerError, gin.H{ \"error\": RemoveTopStruct(errs.Translate(trans)), }) return } c.JSON(http.StatusOK, gin.H{ \"msg\": \"注册成功\", }) }) router.Run(\":8083\") } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:8:0","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"中间件 Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:9:0","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"定义中间件 Gin中的中间件必须是一个gin.HandlerFunc类型。 中间件的常见形式 func authMiddleware(doCheck bool)gin.Handlerfunc { // 连接数据库 // 或者一些其他准备工作 return func(c *gin.Context) { if doCheck { // 存放具体的逻辑 // 是否登录的判断 // if 是登录用户 // c.Next() // else // c.Abort() } else { c.Next() } } } 通过中间件在上下文定义一些值 // 中间件可以在上下文中设一些kv值，其他中间件可以通过key值取到value c.Set(\"key\", \"value\") name, ok := c.Get(\"key\") name := c.MustGet(\"key\") 记录接口耗时的中间件 // StatCost 是一个统计耗时请求耗时的中间件 func StatCost() gin.HandlerFunc { return func(c *gin.Context) { start := time.Now() c.Set(\"name\", \"lz\") // 可以通过c.Set在请求上下文中设置值，后续的处理函数能够取到该值 // 调用该请求的剩余处理程序 // 这里指的是 r.GET(\"/\", StatCost, func1) 这里的func1 c.Next() // 不调用该请求的剩余处理程序 // c.Abort() //执行完func1后才执行这个 计算耗时 cost := time.Since(start) log.Println(cost) } } 记录响应体的中间件 type bodyLogWriter struct { gin.ResponseWriter // 嵌入gin框架ResponseWriter body *bytes.Buffer // 我们记录用的response } // Write 写入响应体数据 func (w bodyLogWriter) Write(b []byte) (int, error) { w.body.Write(b) // 我们记录一份 return w.ResponseWriter.Write(b) // 真正写入响应 } // ginBodyLogMiddleware 一个记录返回给客户端响应体的中间件 // https://stackoverflow.com/questions/38501325/how-to-log-response-body-in-gin func ginBodyLogMiddleware(c *gin.Context) { blw := \u0026bodyLogWriter{body: bytes.NewBuffer([]byte{}), ResponseWriter: c.Writer} c.Writer = blw // 使用我们自定义的类型替换默认的 c.Next() // 执行业务逻辑 fmt.Println(\"Response body: \" + blw.body.String()) // 事后按需记录返回的响应 } 一个案例 好好理解中间件与c.Next() func indexHandler(c *gin.Context) { fmt.Println(\"index\") c.JSON(http.StatusOK,gin.H{ \"msg\": \"index\", }) } // 定义一个中间件m1:统计请求处理函数的耗时 func m1(c *gin.Context){ fmt.Println(\"m1 in...\") // 计时 start := time.Now() c.Next() // 调用后续的处理函数 // c.Abort() // 阻止调用后续的处理函数 cost := time.Since(start) fmt.Printf(\"cost:%v\\n\",cost) fmt.Println(\"m1 out\") } func m2(c *gin.Context){ fmt.Println(\"m2 in...\") c.Next() // 调用后续的处理函数 fmt.Println(\"m2 out...\") } func main(){ r := gin.Default() r.Use(m1,m2) // 全局注册中间件函数m1,m2 r.GET(\"/index\", indexHandler) r.Run() } 上述代码的执行顺序如下： m1 in… m2 in… index m2 out… cost:187.975μs m1 out… 跨域中间件cors 跨域问题在前后端都可以解决，我曾经做的项目中就遇到了这个问题，这是一个常见的需要进行一下简单处理的问题。 推荐使用社区的https://github.com/gin-contrib/cors 库，一行代码解决前后端分离架构下的跨域问题。 注意： 该中间件需要注册在业务处理函数前面。 这个库支持各种常用的配置项，具体使用方法如下。 package main import ( \"time\" \"github.com/gin-contrib/cors\" \"github.com/gin-gonic/gin\" ) func main() { router := gin.Default() // CORS for https://foo.com and https://github.com origins, allowing: // - PUT and PATCH methods // - Origin header // - Credentials share // - Preflight requests cached for 12 hours router.Use(cors.New(cors.Config{ AllowOrigins: []string{\"https://foo.com\"}, // 允许跨域发来请求的网站 AllowMethods: []string{\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"}, // 允许的请求方法 AllowHeaders: []string{\"Origin\", \"Authorization\", \"Content-Type\"}, ExposeHeaders: []string{\"Content-Length\"}, AllowCredentials: true, AllowOriginFunc: func(origin string) bool { // 自定义过滤源站的方法 return origin == \"https://github.com\" }, MaxAge: 12 * time.Hour, })) router.Run() } 当然你可以简单的像下面的示例代码那样使用默认配置，允许所有的跨域请求。 func main() { router := gin.Default() // same as // config := cors.DefaultConfig() // config.AllowAllOrigins = true // router.Use(cors.New(config)) router.Use(cors.Default()) router.Run() } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:9:1","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"注册中间件 为全局路由注册 func m1(c *gin.Context) { ... } r.GET(\"/1\", m1, func1) r.GET(\"/2\", m1, func2) r.GET(\"/3\", m1, func3) // 为了避免这种每一个请求都写一个m1 可以全局注册中间件m1 r.Use(m1) func main() { // 新建一个没有任何默认中间件的路由 r := gin.New() // 注册一个全局中间件 r.Use(StatCost()) r.GET(\"/test\", func(c *gin.Context) { name := c.MustGet(\"name\").(string) // 从上下文取值 log.Println(name) c.JSON(http.StatusOK, gin.H{ \"message\": \"Hello world!\", }) }) r.Run() } 为某个路由单独注册 // 给/test2路由单独注册中间件（可注册多个） r.GET(\"/test2\", StatCost(), func(c *gin.Context) { name := c.MustGet(\"name\").(string) // 从上下文取值 log.Println(name) c.JSON(http.StatusOK, gin.H{ \"message\": \"Hello world!\", }) }) 为路由组注册中间件 // 写法一 shopGroup := r.Group(\"/shop\", StatCost()) { shopGroup.GET(\"/index\", func(c *gin.Context) {...}) ... } // 写法二 shopGroup := r.Group(\"/shop\") shopGroup.Use(StatCost()) { shopGroup.GET(\"/index\", func(c *gin.Context) {...}) ... } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:9:2","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"中间件注意事项 gin默认中间件 gin.Default()默认使用了Logger和Recovery中间件，其中： Logger中间件将日志写入gin.DefaultWriter，即使配置了GIN_MODE=release。 Recovery中间件会recover任何panic。如果有panic的话，会写入500响应码。 如果不想使用上面两个默认的中间件，可以使用gin.New()新建一个没有任何默认中间件的路由。 gin中间件中使用goroutine 当在中间件或handler中启动新的goroutine时，不能使用原始的上下文（c *gin.Context），必须使用其只读副本（c.Copy()）。 ","date":"2023-05-21","objectID":"/posts/gin/gin01/:9:3","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"文件上传 文件上传前端代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003ctitle\u003e上传文件示例\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"\u003e \u003cinput type=\"file\" name=\"f1\"\u003e \u003cinput type=\"submit\" value=\"上传\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 后端代码 单文件上传 func main() { router := gin.Default() // 处理multipart forms提交文件时默认的内存限制是32 MiB // 可以通过下面的方式修改 // router.MaxMultipartMemory = 8 \u003c\u003c 20 // 8 MiB router.POST(\"/upload\", func(c *gin.Context) { // 单个文件 file, err := c.FormFile(\"f1\") if err != nil { c.JSON(http.StatusInternalServerError, gin.H{ \"message\": err.Error(), }) return } log.Println(file.Filename) dst := fmt.Sprintf(\"C:/tmp/%s\", file.Filename) // 上传文件到指定的目录 c.SaveUploadedFile(file, dst) c.JSON(http.StatusOK, gin.H{ \"message\": fmt.Sprintf(\"'%s' uploaded!\", file.Filename), }) }) router.Run() } 多文件上传 func main() { router := gin.Default() // 处理multipart forms提交文件时默认的内存限制是32 MiB // 可以通过下面的方式修改 // router.MaxMultipartMemory = 8 \u003c\u003c 20 // 8 MiB router.POST(\"/upload\", func(c *gin.Context) { // Multipart form form, _ := c.MultipartForm() files := form.File[\"file\"] for index, file := range files { log.Println(file.Filename) dst := fmt.Sprintf(\"C:/tmp/%s_%d\", file.Filename, index) // 上传文件到指定的目录 c.SaveUploadedFile(file, dst) } c.JSON(http.StatusOK, gin.H{ \"message\": fmt.Sprintf(\"%d files uploaded!\", len(files)), }) }) router.Run() } ","date":"2023-05-21","objectID":"/posts/gin/gin01/:10:0","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["Gin"],"content":"GROM","date":"2023-05-21","objectID":"/posts/gin/gin01/:11:0","tags":["Gin"],"title":"Gin入门","uri":"/posts/gin/gin01/"},{"categories":["BLOG"],"content":"搭建个人博客的简易流程","date":"2023-05-19","objectID":"/posts/blog-quickstart/","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":["BLOG"],"content":"安装环境与框架 本博客使用的是Hugo框架，Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 Go Go官网下载地址：https://golang.org/dl/ Go官方镜像站：https://golang.google.cn/dl/ Hugo 参照官方文档的installation，hugo的安装方式有多种。我采用的方式是，在GitHub上下载压缩包，解压到本地，文件组织目录如下： bin hugo.exe LICENSE README.md MySite(建站) 建站 hugo new site MySite cd MySite git init // 将https://github.com/theNewDynamic/gohugo-theme-ananke更换为自己喜欢的主题，主题在https://themes.gohugo.io/ themes/ananke 是在themes文件夹，创建ananke主题文件 git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke 选好主题之后，需要将ananke文件夹下的config.toml复制到站的根目录下进行覆盖。修改或添加如下基础内容。 baseURL = 'http://Lizhe1228.github.io/' # 为下一步部署到github做准备 languageCode = 'zh-CN' title = 'My New Hugo Site' 撰写文章 hugo new post/my-first-post.md # \"my-first-post.md\" 是新建文章的文件名。 post是根目录下content里会自动生成的文件夹。 启动启动 Hugo server。 默认在http://localhost:1313预览，此时对文章的修改可实时渲染到页面上。 hugo server -D # -D 是指草稿模式的文章也会渲染到页面上 注意，若再次对配置文件等进行修改，需要重新执行hugo server -D。 发布网站，形成静态文件。 hugo。执行完此条命令后，会在根目录下生成一个public文件夹。注意如果还有草稿模式的文章，使用hugo -D这条命令 ","date":"2023-05-19","objectID":"/posts/blog-quickstart/:1:0","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":["BLOG"],"content":"部署到GitHub 在GitHub上创建一个 username.github.io 的仓库（username为自己的GitHub名字） cd public git init # 初始化 git remote add origin https://github.com/你的用户名/你的用户名.github.io.git # 和远程仓库关联 git status git add . git commit -m \"Add a new post\" git push -f origin master 此时我们登录username.github.io就可以看到自己的博客了。 注意，如果对文章内容进行了修改，或者添加了新的内容，需要重新进行hugo操作，生成新的puplic文件，再次在public文件夹下执行git status、git add .、git commit -m \"Add a new post\"、git push -f origin master指令，才可以更新远程仓库，更新博客。 ","date":"2023-05-19","objectID":"/posts/blog-quickstart/:2:0","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":["BLOG"],"content":"其他事项 ","date":"2023-05-19","objectID":"/posts/blog-quickstart/:3:0","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":["BLOG"],"content":"关于解决git push慢的方法 方法一：修改host文件 修改C:\\Windows\\System32\\drivers\\etc\\hosts文件，添加如下配置。 140.82.114.4 github.com 185.199.108.153 assets-cdn.github.com 151.101.1.194 github.global.ssl.fastly.net 以上三个ip在https://www.ipaddress.com/可以查到，可能会有更新。 方法二：git 设置 socks5 代理 用git内置代理，直接走系统中运行的代理工具中转，比如，你的 SS 本地端口是 1080，那么可以如下方式走代理： git config --global http.proxy socks5://127.0.0.1:1080 git config --global https.proxy socks5://127.0.0.1:1080 取消代理的方式： git config --global http.proxy \"\" git config --global https.proxy \"\" ","date":"2023-05-19","objectID":"/posts/blog-quickstart/:3:1","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"},{"categories":["BLOG"],"content":"关于主题 Fixlit 官方文档、GitHub 代码行号+复制 在配置文件中添加如下内容： [markup] [markup.highlight] codeFences = true guessSyntax = true hl_Lines = \"\" lineNoStart = 1 lineNos = true lineNumbersInTable = false noClasses = true style = \"github\" tabWidth = 4 ","date":"2023-05-19","objectID":"/posts/blog-quickstart/:3:2","tags":["教程"],"title":"Blog-QuickStart","uri":"/posts/blog-quickstart/"}]